[
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/impl/event_manager_core.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/impl/event_manager_core.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/impl/event_manager_core.py:155:39 Incompatible parameter type [6]: Expected `typing.Tuple[typing.Callable[[typing.Any], typing.Union[typing.Coroutine[None, typing.Any, bool], bool]], aio.Future[typing.Any]]` for 1st positional only parameter to call `typing.MutableSet.add` but got `typing.Tuple[typing.Callable[[typing.Any], typing.Union[typing.Coroutine[None, typing.Any, bool], bool]], asyncio.futures.Future[typing.Any]]`.",
    "message": " Expected `typing.Tuple[typing.Callable[[typing.Any], typing.Union[typing.Coroutine[None, typing.Any, bool], bool]], aio.Future[typing.Any]]` for 1st positional only parameter to call `typing.MutableSet.add` but got `typing.Tuple[typing.Callable[[typing.Any], typing.Union[typing.Coroutine[None, typing.Any, bool], bool]], asyncio.futures.Future[typing.Any]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 155,
    "warning_line": "        self._waiters[event_type].add((predicate, future))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "    _ListenerMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSequence[_CallbackT]]\n    _WaiterT = typing.Tuple[_PredicateT, aio.Future[_EventT]]\n    _WaiterMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSet[_WaiterT]]\n",
        "source_code_len": 253,
        "target_code": "    _ListenerMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSequence[_CallbackT]]\n    _WaiterT = typing.Tuple[_PredicateT, asyncio.Future[_EventT]]\n    _WaiterMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSet[_WaiterT]]\n",
        "target_code_len": 257,
        "diff_format": "@@ -48,3 +48,3 @@\n     _ListenerMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSequence[_CallbackT]]\n-    _WaiterT = typing.Tuple[_PredicateT, aio.Future[_EventT]]\n+    _WaiterT = typing.Tuple[_PredicateT, asyncio.Future[_EventT]]\n     _WaiterMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSet[_WaiterT]]\n",
        "source_code_with_indent": "    _ListenerMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSequence[_CallbackT]]\n    _WaiterT = typing.Tuple[_PredicateT, aio.Future[_EventT]]\n    _WaiterMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSet[_WaiterT]]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    _ListenerMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSequence[_CallbackT]]\n    _WaiterT = typing.Tuple[_PredicateT, asyncio.Future[_EventT]]\n    _WaiterMapT = typing.MutableMapping[typing.Type[_EventT], typing.MutableSet[_WaiterT]]\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/impl/event_manager_core.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/impl/event_manager_core.py",
    "file_hunks_size": 3,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/impl/event_manager_core.py:215:8 Incompatible return type [7]: Expected `aio.Future[typing.Any]` but got `typing.Union[aio.Future[None], asyncio.futures.Future[typing.Tuple[typing.Any]]]`.",
    "message": " Expected `aio.Future[typing.Any]` but got `typing.Union[aio.Future[None], asyncio.futures.Future[typing.Tuple[typing.Any]]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 215,
    "warning_line": "        return asyncio.gather(*tasks) if tasks else aio.completed_future()"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/http_client.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/http_client.py",
    "file_hunks_size": 7,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": true,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/http_client.py:178:8 Incompatible attribute type [8]: Attribute `_ssl_context` declared in class `HTTPClient` has type `ssl.SSLContext` but is used as type `typing.Optional[ssl.SSLContext]`.",
    "message": " Attribute `_ssl_context` declared in class `HTTPClient` has type `ssl.SSLContext` but is used as type `typing.Optional[ssl.SSLContext]`.",
    "rule_id": "Incompatible attribute type [8]",
    "warning_line_no": 178,
    "warning_line": "        self._ssl_context: ssl.SSLContext = ssl_context",
    "min_patch": [
      {
        "hunk_fit_TFix": true,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "        self._proxy_url = proxy_url\n        self._ssl_context: ssl.SSLContext = ssl_context\n        self._request_timeout = timeout\n",
        "source_code_len": 132,
        "target_code": "        self._proxy_url = proxy_url\n        self._ssl_context = ssl_context\n        self._request_timeout = timeout\n",
        "target_code_len": 116,
        "diff_format": "@@ -177,3 +178,3 @@\n         self._proxy_url = proxy_url\n-        self._ssl_context: ssl.SSLContext = ssl_context\n+        self._ssl_context = ssl_context\n         self._request_timeout = timeout\n",
        "source_code_with_indent": "        self._proxy_url = proxy_url\n        self._ssl_context: ssl.SSLContext = ssl_context\n        self._request_timeout = timeout\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "        self._proxy_url = proxy_url\n        self._ssl_context = ssl_context\n        self._request_timeout = timeout\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:734:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 734,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_invite_with_metadata)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:734:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_invite_with_metadata)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], invites.InviteWithMetadata], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_invite_with_metadata)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], invites.InviteWithMetadata], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 734,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_invite_with_metadata)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:867:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 867,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_message)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:867:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_message)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], messages_.Message], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_message)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], messages_.Message], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 867,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_message)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1445:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1445,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_webhook)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1445:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_webhook)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], webhooks.Webhook], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_webhook)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], webhooks.Webhook], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1445,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_webhook)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1452:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1452,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_webhook)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1452:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_webhook)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], webhooks.Webhook], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_webhook)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], webhooks.Webhook], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1452,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_webhook)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1584:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1584,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_own_connection)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1584:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_own_connection)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], applications.OwnConnection], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_own_connection)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], applications.OwnConnection], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1584,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_own_connection)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1647:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1647,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_voice_region)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1647:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_voice_region)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], voices.VoiceRegion], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_voice_region)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], voices.VoiceRegion], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1647,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_voice_region)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1687:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1687,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_known_custom_emoji, set)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1687:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_known_custom_emoji)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], emojis.KnownCustomEmoji], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_known_custom_emoji)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], emojis.KnownCustomEmoji], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1687,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_known_custom_emoji, set)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1827:56 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1827,
    "warning_line": "        channel_sequence = data_binding.cast_json_array(response, self._app.entity_factory.deserialize_channel)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:1827:66 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_channel)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], channels.PartialChannel], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_channel)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], channels.PartialChannel], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 1827,
    "warning_line": "        channel_sequence = data_binding.cast_json_array(response, self._app.entity_factory.deserialize_channel)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2107:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2107,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_guild_member_ban)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2107:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_guild_member_ban)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], guilds.GuildMemberBan], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_guild_member_ban)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], guilds.GuildMemberBan], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2107,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_guild_member_ban)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2114:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2114,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_role)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2114:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_role)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], guilds.Role], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_role)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], guilds.Role], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2114,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_role)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2218:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2218,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_voice_region)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2218:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_voice_region)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], voices.VoiceRegion], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_voice_region)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], voices.VoiceRegion], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2218,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_voice_region)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2225:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2225,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_invite_with_metadata)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2225:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_invite_with_metadata)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], invites.InviteWithMetadata], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_invite_with_metadata)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], invites.InviteWithMetadata], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2225,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_invite_with_metadata)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2232:44 Incompatible parameter type [6]: Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "message": " Expected `typing.List[typing.Any]` for 1st positional only parameter to call `data_binding.cast_json_array` but got `typing.Optional[typing.Any]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2232,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_integration)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/net/rest.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/net/rest.py",
    "file_hunks_size": 4,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/net/rest.py:2232:54 Incompatible parameter type [6]: Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_integration)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], guilds.Integration], hikari.api.entity_factory.IEntityFactory]`.",
    "message": " Expected `typing.Callable[[typing.Union[None, typing.Dict[str, typing.Any], typing.List[typing.Any], bool, float, int, str]], Variable[data_binding.T](covariant)]` for 2nd positional only parameter to call `data_binding.cast_json_array` but got `BoundMethod[typing.Callable(hikari.api.entity_factory.IEntityFactory.deserialize_integration)[[Named(self, hikari.api.entity_factory.IEntityFactory), Named(payload, typing.Dict[str, typing.Any])], guilds.Integration], hikari.api.entity_factory.IEntityFactory]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 2232,
    "warning_line": "        return data_binding.cast_json_array(response, self._app.entity_factory.deserialize_integration)"
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:53:4 Incompatible return type [7]: Expected `Future[typing.Optional[Variable[T_contra](contravariant)]]` but got `asyncio.futures.Future[typing.Any]`.",
    "message": " Expected `Future[typing.Optional[Variable[T_contra](contravariant)]]` but got `asyncio.futures.Future[typing.Any]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 53,
    "warning_line": "    return future",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:92:8 Incompatible return type [7]: Expected `Variable[T_contra](contravariant)` but got implicit return value of `None`.",
    "message": " Expected `Variable[T_contra](contravariant)` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 92,
    "warning_line": "        \"\"\"See `asyncio.Future.result`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:101:8 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 101,
    "warning_line": "        \"\"\"See `asyncio.Future.done`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:104:8 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 104,
    "warning_line": "        \"\"\"See `asyncio.Future.cancelled`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:115:8 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 115,
    "warning_line": "        \"\"\"See `asyncio.Future.cancel`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:121:8 Incompatible return type [7]: Expected `asyncio.events.AbstractEventLoop` but got implicit return value of `None`.",
    "message": " Expected `asyncio.events.AbstractEventLoop` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 121,
    "warning_line": "        \"\"\"See `asyncio.Future.get_loop`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:135:8 Incompatible return type [7]: Expected `Variable[T_contra](contravariant)` but got implicit return value of `None`.",
    "message": " Expected `Variable[T_contra](contravariant)` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 135,
    "warning_line": "        \"\"\"See`asyncio.Future.result`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:144:8 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 144,
    "warning_line": "        \"\"\"See `asyncio.Future.done`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:147:8 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 147,
    "warning_line": "        \"\"\"See `asyncio.Future.cancelled`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:158:8 Incompatible return type [7]: Expected `bool` but got implicit return value of `None`.",
    "message": " Expected `bool` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 158,
    "warning_line": "        \"\"\"See `asyncio.Future.cancel`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:164:8 Incompatible return type [7]: Expected `asyncio.events.AbstractEventLoop` but got implicit return value of `None`.",
    "message": " Expected `asyncio.events.AbstractEventLoop` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 164,
    "warning_line": "        \"\"\"See `asyncio.Future.get_loop`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:167:8 Incompatible return type [7]: Expected `typing.Sequence[types.FrameType]` but got implicit return value of `None`.",
    "message": " Expected `typing.Sequence[types.FrameType]` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 167,
    "warning_line": "        \"\"\"See `asyncio.Task.get_stack`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "hikari-py/hikari",
    "commit": "f2cac8827620104419d0526664b420440e852f72",
    "filename": "hikari/utilities/aio.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari/hikari/utilities/aio.py",
    "file_hunks_size": 6,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "hikari/utilities/aio.py:173:8 Incompatible return type [7]: Expected `str` but got implicit return value of `None`.",
    "message": " Expected `str` but got implicit return value of `None`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 173,
    "warning_line": "        \"\"\"See `asyncio.Task.get_name`.\"\"\"",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\nif typing.TYPE_CHECKING:\n    import contextvars\n    import types\n\nT_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_len": 317,
        "target_code": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "target_code_len": 227,
        "diff_format": "@@ -28,10 +28,6 @@\n \n-if typing.TYPE_CHECKING:\n-    import contextvars\n-    import types\n-\n-T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n+T_inv = typing.TypeVar(\"T_inv\")\n \n \n-def completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n+def completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n     \"\"\"Create a future on the current running loop that is completed, then return it.\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\nif typing.TYPE_CHECKING:\n    <IND>import contextvars\n    import types\n\n<DED>T_contra = typing.TypeVar(\"T_contra\", contravariant=True)\n\n\ndef completed_future(result: typing.Optional[T_contra] = None, /) -> Future[typing.Optional[T_contra]]:\n    <IND>",
        "target_code_with_indent": "\nT_inv = typing.TypeVar(\"T_inv\")\n\n\ndef completed_future(result: typing.Optional[T_inv] = None, /) -> asyncio.Future[typing.Optional[T_inv]]:\n    <IND>"
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See `asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n\n\n@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    \"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        \"\"\"See`asyncio.Future.result`.\"\"\"\n\n    def set_result(self, result: T_contra, /) -> None:\n        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    def set_exception(self, exception: Exception, /) -> None:\n        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    def done(self) -> bool:\n        \"\"\"See `asyncio.Future.done`.\"\"\"\n\n    def cancelled(self) -> bool:\n        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    def cancel(self) -> bool:\n        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    def exception(self) -> typing.Optional[Exception]:\n        \"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    def get_loop(self) -> asyncio.AbstractEventLoop:\n        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    def get_name(self) -> str:\n        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    def set_name(self, value: str, /) -> None:\n        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        ...\n",
        "source_code_len": 3312,
        "target_code": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_len": 62,
        "diff_format": "@@ -81,99 +79,1 @@\n     return inspect.isfunction(attr) or inspect.ismethod(attr)\n-\n-\n-@typing.runtime_checkable\n-class Future(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Future`.\n-\n-    You should consult the documentation for `asyncio.Future` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See `asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n-\n-\n-@typing.runtime_checkable\n-class Task(typing.Protocol[T_contra]):\n-    \"\"\"Typed protocol representation of an `asyncio.Task`.\n-\n-    You should consult the documentation for `asyncio.Task` for usage.\n-    \"\"\"\n-\n-    def result(self) -> T_contra:\n-        \"\"\"See`asyncio.Future.result`.\"\"\"\n-\n-    def set_result(self, result: T_contra, /) -> None:\n-        \"\"\"See `asyncio.Future.set_result`.\"\"\"\n-\n-    def set_exception(self, exception: Exception, /) -> None:\n-        \"\"\"See `asyncio.Future.set_exception`.\"\"\"\n-\n-    def done(self) -> bool:\n-        \"\"\"See `asyncio.Future.done`.\"\"\"\n-\n-    def cancelled(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancelled`.\"\"\"\n-\n-    def add_done_callback(\n-        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n-    ) -> None:\n-        \"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n-\n-    def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n-        \"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n-\n-    def cancel(self) -> bool:\n-        \"\"\"See `asyncio.Future.cancel`.\"\"\"\n-\n-    def exception(self) -> typing.Optional[Exception]:\n-        \"\"\"See `asyncio.Future.exception`.\"\"\"\n-\n-    def get_loop(self) -> asyncio.AbstractEventLoop:\n-        \"\"\"See `asyncio.Future.get_loop`.\"\"\"\n-\n-    def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n-        \"\"\"See `asyncio.Task.get_stack`.\"\"\"\n-\n-    def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n-        \"\"\"See `asyncio.Task.print_stack`.\"\"\"\n-\n-    def get_name(self) -> str:\n-        \"\"\"See `asyncio.Task.get_name`.\"\"\"\n-\n-    def set_name(self, value: str, /) -> None:\n-        \"\"\"See `asyncio.Task.set_name`.\"\"\"\n-\n-    def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n-        ...\n",
        "source_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n\n\n<DED>@typing.runtime_checkable\nclass Future(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Future`.\n\n    You should consult the documentation for `asyncio.Future` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See `asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n\n\n<DED><DED>@typing.runtime_checkable\nclass Task(typing.Protocol[T_contra]):\n    <IND>\"\"\"Typed protocol representation of an `asyncio.Task`.\n\n    You should consult the documentation for `asyncio.Task` for usage.\n    \"\"\"\n\n    def result(self) -> T_contra:\n        <IND>\"\"\"See`asyncio.Future.result`.\"\"\"\n\n    <DED>def set_result(self, result: T_contra, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_result`.\"\"\"\n\n    <DED>def set_exception(self, exception: Exception, /) -> None:\n        <IND>\"\"\"See `asyncio.Future.set_exception`.\"\"\"\n\n    <DED>def done(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.done`.\"\"\"\n\n    <DED>def cancelled(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancelled`.\"\"\"\n\n    <DED>def add_done_callback(\n        self, callback: typing.Callable[[Future[T_contra]], None], /, *, context: typing.Optional[contextvars.Context],\n    ) -> None:\n        <IND>\"\"\"See `asyncio.Future.add_done_callback`.\"\"\"\n\n    <DED>def remove_done_callback(self, callback: typing.Callable[[Future[T_contra]], None], /) -> None:\n        <IND>\"\"\"See `asyncio.Future.remove_done_callback`.\"\"\"\n\n    <DED>def cancel(self) -> bool:\n        <IND>\"\"\"See `asyncio.Future.cancel`.\"\"\"\n\n    <DED>def exception(self) -> typing.Optional[Exception]:\n        <IND>\"\"\"See `asyncio.Future.exception`.\"\"\"\n\n    <DED>def get_loop(self) -> asyncio.AbstractEventLoop:\n        <IND>\"\"\"See `asyncio.Future.get_loop`.\"\"\"\n\n    <DED>def get_stack(self, *, limit: typing.Optional[int] = None) -> typing.Sequence[types.FrameType]:\n        <IND>\"\"\"See `asyncio.Task.get_stack`.\"\"\"\n\n    <DED>def print_stack(self, *, limit: typing.Optional[int] = None, file: typing.Optional[typing.IO] = None) -> None:\n        <IND>\"\"\"See `asyncio.Task.print_stack`.\"\"\"\n\n    <DED>def get_name(self) -> str:\n        <IND>\"\"\"See `asyncio.Task.get_name`.\"\"\"\n\n    <DED>def set_name(self, value: str, /) -> None:\n        <IND>\"\"\"See `asyncio.Task.set_name`.\"\"\"\n\n    <DED>def __await__(self) -> typing.Generator[T_contra, None, typing.Any]:\n        <IND>...\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "    return inspect.isfunction(attr) or inspect.ismethod(attr)\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]