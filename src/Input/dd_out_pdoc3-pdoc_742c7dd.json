[
  {
    "project": "pdoc3/pdoc",
    "commit": "742c7dd3a75447862029c6f0d303cdd604c9ff15",
    "filename": "pdoc/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pdoc3-pdoc/pdoc/__init__.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pdoc/__init__.py:203:20 Incompatible variable type [9]: _init_tree is declared to have type `_ast.FunctionDef` but is used as type `None`.",
    "message": " _init_tree is declared to have type `_ast.FunctionDef` but is used as type `None`.",
    "rule_id": "Incompatible variable type [9]",
    "warning_line_no": 203,
    "warning_line": "                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _var_docstrings(doc_obj: Union['Module', 'Class'], *,\n                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:\n    \"\"\"\n    Extracts docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a dict mapping variable names to `pdoc.Variable` objects.\n\n    For `pdoc.Class` objects, the dict contains class' instance\n    variables (defined as `self.something` in class' `__init__`),\n    recognized by `Variable.instance_var == True`.\n    \"\"\"\n    if _init_tree:\n        tree = _init_tree  # type: Union[ast.Module, ast.FunctionDef]\n    else:\n        # No variables in namespace packages\n        if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n            return {}\n        try:\n",
        "source_code_len": 751,
        "target_code": "\ndef _pep224_docstrings(doc_obj: Union['Module', 'Class'], *,\n                       _init_tree=None) -> Tuple[Dict[str, str],\n                                                 Dict[str, str]]:\n    \"\"\"\n    Extracts PEP-224 docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a tuple of two dicts mapping variable names to their docstrings.\n    The second dict contains instance variables and is non-empty only in case\n    `doc_obj` is a `pdoc.Class` which has `__init__` method.\n    \"\"\"\n    # No variables in namespace packages\n    if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n        return {}, {}\n\n    vars = {}  # type: Dict[str, str]\n    instance_vars = {}  # type: Dict[str, str]\n\n    if _init_tree:\n        tree = _init_tree\n    else:\n        try:\n",
        "target_code_len": 810,
        "diff_format": "@@ -201,20 +201,23 @@\n \n-def _var_docstrings(doc_obj: Union['Module', 'Class'], *,\n-                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:\n-    \"\"\"\n-    Extracts docstrings for variables of `doc_obj`\n+def _pep224_docstrings(doc_obj: Union['Module', 'Class'], *,\n+                       _init_tree=None) -> Tuple[Dict[str, str],\n+                                                 Dict[str, str]]:\n+    \"\"\"\n+    Extracts PEP-224 docstrings for variables of `doc_obj`\n     (either a `pdoc.Module` or `pdoc.Class`).\n \n-    Returns a dict mapping variable names to `pdoc.Variable` objects.\n-\n-    For `pdoc.Class` objects, the dict contains class' instance\n-    variables (defined as `self.something` in class' `__init__`),\n-    recognized by `Variable.instance_var == True`.\n-    \"\"\"\n+    Returns a tuple of two dicts mapping variable names to their docstrings.\n+    The second dict contains instance variables and is non-empty only in case\n+    `doc_obj` is a `pdoc.Class` which has `__init__` method.\n+    \"\"\"\n+    # No variables in namespace packages\n+    if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n+        return {}, {}\n+\n+    vars = {}  # type: Dict[str, str]\n+    instance_vars = {}  # type: Dict[str, str]\n+\n     if _init_tree:\n-        tree = _init_tree  # type: Union[ast.Module, ast.FunctionDef]\n+        tree = _init_tree\n     else:\n-        # No variables in namespace packages\n-        if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n-            return {}\n         try:\n",
        "source_code_with_indent": "\n<DED>def _var_docstrings(doc_obj: Union['Module', 'Class'], *,\n                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:\n    <IND>\"\"\"\n    Extracts docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a dict mapping variable names to `pdoc.Variable` objects.\n\n    For `pdoc.Class` objects, the dict contains class' instance\n    variables (defined as `self.something` in class' `__init__`),\n    recognized by `Variable.instance_var == True`.\n    \"\"\"\n    if _init_tree:\n        <IND>tree = _init_tree  # type: Union[ast.Module, ast.FunctionDef]\n    <DED>else:\n        # No variables in namespace packages\n        <IND>if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n            <IND>return {}\n        <DED>try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pep224_docstrings(doc_obj: Union['Module', 'Class'], *,\n                       _init_tree=None) -> Tuple[Dict[str, str],\n                                                 Dict[str, str]]:\n    <IND>\"\"\"\n    Extracts PEP-224 docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a tuple of two dicts mapping variable names to their docstrings.\n    The second dict contains instance variables and is non-empty only in case\n    `doc_obj` is a `pdoc.Class` which has `__init__` method.\n    \"\"\"\n    # No variables in namespace packages\n    if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n        <IND>return {}, {}\n\n    <DED>vars = {}  # type: Dict[str, str]\n    instance_vars = {}  # type: Dict[str, str]\n\n    if _init_tree:\n        <IND>tree = _init_tree\n    <DED>else:\n        <IND>try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}\n        if isinstance(doc_obj, Class):\n            tree = tree.body[0]  # type: ignore  # ast.parse creates a dummy ast.Module wrapper\n\n    vs = {}  # type: Dict[str, Variable]\n\n    cls = None\n    module = doc_obj\n    module_all = set(getattr(module.obj, '__all__', ()))\n    member_obj = dict(inspect.getmembers(doc_obj.obj)).get\n\n    if isinstance(doc_obj, Class):\n        cls = doc_obj\n        module = doc_obj.module\n\n        # For classes, first add instance variables defined in __init__\n        if not _init_tree:\n            # Recursive call with just the __init__ tree\n            for node in tree.body:\n                if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    vs.update(_var_docstrings(doc_obj, _init_tree=node))\n                    break\n",
        "source_code_len": 887,
        "target_code": "            warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}, {}\n\n        if isinstance(doc_obj, Class):\n            tree = tree.body[0]  # ast.parse creates a dummy ast.Module wrapper\n\n            # For classes, maybe add instance variables defined in __init__\n            for node in tree.body:\n                if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    instance_vars, _ = _pep224_docstrings(doc_obj, _init_tree=node)\n                    break\n",
        "target_code_len": 522,
        "diff_format": "@@ -223,23 +226,11 @@\n             warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n-            return {}\n+            return {}, {}\n+\n         if isinstance(doc_obj, Class):\n-            tree = tree.body[0]  # type: ignore  # ast.parse creates a dummy ast.Module wrapper\n-\n-    vs = {}  # type: Dict[str, Variable]\n-\n-    cls = None\n-    module = doc_obj\n-    module_all = set(getattr(module.obj, '__all__', ()))\n-    member_obj = dict(inspect.getmembers(doc_obj.obj)).get\n-\n-    if isinstance(doc_obj, Class):\n-        cls = doc_obj\n-        module = doc_obj.module\n-\n-        # For classes, first add instance variables defined in __init__\n-        if not _init_tree:\n-            # Recursive call with just the __init__ tree\n+            tree = tree.body[0]  # ast.parse creates a dummy ast.Module wrapper\n+\n+            # For classes, maybe add instance variables defined in __init__\n             for node in tree.body:\n                 if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n-                    vs.update(_var_docstrings(doc_obj, _init_tree=node))\n+                    instance_vars, _ = _pep224_docstrings(doc_obj, _init_tree=node)\n                     break\n",
        "source_code_with_indent": "            <IND>warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}\n        <DED>if isinstance(doc_obj, Class):\n            <IND>tree = tree.body[0]  # type: ignore  # ast.parse creates a dummy ast.Module wrapper\n\n    <DED><DED>vs = {}  # type: Dict[str, Variable]\n\n    cls = None\n    module = doc_obj\n    module_all = set(getattr(module.obj, '__all__', ()))\n    member_obj = dict(inspect.getmembers(doc_obj.obj)).get\n\n    if isinstance(doc_obj, Class):\n        <IND>cls = doc_obj\n        module = doc_obj.module\n\n        # For classes, first add instance variables defined in __init__\n        if not _init_tree:\n            # Recursive call with just the __init__ tree\n            <IND>for node in tree.body:\n                <IND>if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    <IND>vs.update(_var_docstrings(doc_obj, _init_tree=node))\n                    break\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}, {}\n\n        <DED>if isinstance(doc_obj, Class):\n            <IND>tree = tree.body[0]  # ast.parse creates a dummy ast.Module wrapper\n\n            # For classes, maybe add instance variables defined in __init__\n            for node in tree.body:\n                <IND>if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    <IND>instance_vars, _ = _pep224_docstrings(doc_obj, _init_tree=node)\n                    break\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n        if not _is_public(name):\n            continue\n\n        if module_all and name not in module_all:\n            continue\n\n        docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "source_code_len": 191,
        "target_code": "\n        docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "target_code_len": 64,
        "diff_format": "@@ -277,8 +267,2 @@\n \n-        if not _is_public(name):\n-            continue\n-\n-        if module_all and name not in module_all:\n-            continue\n-\n         docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "source_code_with_indent": "\n        <DED>if not _is_public(name):\n            <IND>continue\n\n        <DED>if module_all and name not in module_all:\n            <IND>continue\n\n        <DED>docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        vs[name] = Variable(name, module, docstring,\n                            obj=member_obj(name),\n                            cls=cls, instance_var=bool(_init_tree))\n    return vs\n\n",
        "source_code_len": 187,
        "target_code": "\n        vars[name] = docstring\n\n    return vars, instance_vars\n\n",
        "target_code_len": 65,
        "diff_format": "@@ -287,6 +271,5 @@\n \n-        vs[name] = Variable(name, module, docstring,\n-                            obj=member_obj(name),\n-                            cls=cls, instance_var=bool(_init_tree))\n-    return vs\n+        vars[name] = docstring\n+\n+    return vars, instance_vars\n \n",
        "source_code_with_indent": "\n        <DED>vs[name] = Variable(name, module, docstring,\n                            obj=member_obj(name),\n                            cls=cls, instance_var=bool(_init_tree))\n    <DED>return vs\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>vars[name] = docstring\n\n    <DED>return vars, instance_vars\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        # Populate self.doc with this module's public members\n",
        "source_code_len": 63,
        "target_code": "\n        var_docstrings, _ = _pep224_docstrings(self)\n\n        # Populate self.doc with this module's public members\n",
        "target_code_len": 117,
        "diff_format": "@@ -543,2 +530,4 @@\n \n+        var_docstrings, _ = _pep224_docstrings(self)\n+\n         # Populate self.doc with this module's public members\n",
        "source_code_with_indent": "\n        # Populate self.doc with this module's public members\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        var_docstrings, _ = _pep224_docstrings(self)\n\n        # Populate self.doc with this module's public members\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                self.doc[name] = Class(name, self, obj)\n\n        self.doc.update(_var_docstrings(self))\n\n",
        "source_code_len": 105,
        "target_code": "                self.doc[name] = Class(name, self, obj)\n            elif name in var_docstrings:\n                self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)\n\n",
        "target_code_len": 183,
        "diff_format": "@@ -568,4 +558,4 @@\n                 self.doc[name] = Class(name, self, obj)\n-\n-        self.doc.update(_var_docstrings(self))\n+            elif name in var_docstrings:\n+                self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)\n \n",
        "source_code_with_indent": "                <IND>self.doc[name] = Class(name, self, obj)\n\n        <DED><DED>self.doc.update(_var_docstrings(self))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                <IND>self.doc[name] = Class(name, self, obj)\n            <DED>elif name in var_docstrings:\n                <IND>self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "pdoc3/pdoc",
    "commit": "742c7dd3a75447862029c6f0d303cdd604c9ff15",
    "filename": "pdoc/__init__.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/pdoc3-pdoc/pdoc/__init__.py",
    "file_hunks_size": 14,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "pdoc/__init__.py:290:28 Incompatible parameter type [6]: Expected `Class` for 5th parameter `cls` to call `Variable.__init__` but got `typing.Optional[Class]`.",
    "message": " Expected `Class` for 5th parameter `cls` to call `Variable.__init__` but got `typing.Optional[Class]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 290,
    "warning_line": "                            cls=cls, instance_var=bool(_init_tree))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef _var_docstrings(doc_obj: Union['Module', 'Class'], *,\n                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:\n    \"\"\"\n    Extracts docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a dict mapping variable names to `pdoc.Variable` objects.\n\n    For `pdoc.Class` objects, the dict contains class' instance\n    variables (defined as `self.something` in class' `__init__`),\n    recognized by `Variable.instance_var == True`.\n    \"\"\"\n    if _init_tree:\n        tree = _init_tree  # type: Union[ast.Module, ast.FunctionDef]\n    else:\n        # No variables in namespace packages\n        if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n            return {}\n        try:\n",
        "source_code_len": 751,
        "target_code": "\ndef _pep224_docstrings(doc_obj: Union['Module', 'Class'], *,\n                       _init_tree=None) -> Tuple[Dict[str, str],\n                                                 Dict[str, str]]:\n    \"\"\"\n    Extracts PEP-224 docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a tuple of two dicts mapping variable names to their docstrings.\n    The second dict contains instance variables and is non-empty only in case\n    `doc_obj` is a `pdoc.Class` which has `__init__` method.\n    \"\"\"\n    # No variables in namespace packages\n    if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n        return {}, {}\n\n    vars = {}  # type: Dict[str, str]\n    instance_vars = {}  # type: Dict[str, str]\n\n    if _init_tree:\n        tree = _init_tree\n    else:\n        try:\n",
        "target_code_len": 810,
        "diff_format": "@@ -201,20 +201,23 @@\n \n-def _var_docstrings(doc_obj: Union['Module', 'Class'], *,\n-                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:\n-    \"\"\"\n-    Extracts docstrings for variables of `doc_obj`\n+def _pep224_docstrings(doc_obj: Union['Module', 'Class'], *,\n+                       _init_tree=None) -> Tuple[Dict[str, str],\n+                                                 Dict[str, str]]:\n+    \"\"\"\n+    Extracts PEP-224 docstrings for variables of `doc_obj`\n     (either a `pdoc.Module` or `pdoc.Class`).\n \n-    Returns a dict mapping variable names to `pdoc.Variable` objects.\n-\n-    For `pdoc.Class` objects, the dict contains class' instance\n-    variables (defined as `self.something` in class' `__init__`),\n-    recognized by `Variable.instance_var == True`.\n-    \"\"\"\n+    Returns a tuple of two dicts mapping variable names to their docstrings.\n+    The second dict contains instance variables and is non-empty only in case\n+    `doc_obj` is a `pdoc.Class` which has `__init__` method.\n+    \"\"\"\n+    # No variables in namespace packages\n+    if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n+        return {}, {}\n+\n+    vars = {}  # type: Dict[str, str]\n+    instance_vars = {}  # type: Dict[str, str]\n+\n     if _init_tree:\n-        tree = _init_tree  # type: Union[ast.Module, ast.FunctionDef]\n+        tree = _init_tree\n     else:\n-        # No variables in namespace packages\n-        if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n-            return {}\n         try:\n",
        "source_code_with_indent": "\n<DED>def _var_docstrings(doc_obj: Union['Module', 'Class'], *,\n                    _init_tree: ast.FunctionDef = None) -> Dict[str, 'Variable']:\n    <IND>\"\"\"\n    Extracts docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a dict mapping variable names to `pdoc.Variable` objects.\n\n    For `pdoc.Class` objects, the dict contains class' instance\n    variables (defined as `self.something` in class' `__init__`),\n    recognized by `Variable.instance_var == True`.\n    \"\"\"\n    if _init_tree:\n        <IND>tree = _init_tree  # type: Union[ast.Module, ast.FunctionDef]\n    <DED>else:\n        # No variables in namespace packages\n        <IND>if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n            <IND>return {}\n        <DED>try:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def _pep224_docstrings(doc_obj: Union['Module', 'Class'], *,\n                       _init_tree=None) -> Tuple[Dict[str, str],\n                                                 Dict[str, str]]:\n    <IND>\"\"\"\n    Extracts PEP-224 docstrings for variables of `doc_obj`\n    (either a `pdoc.Module` or `pdoc.Class`).\n\n    Returns a tuple of two dicts mapping variable names to their docstrings.\n    The second dict contains instance variables and is non-empty only in case\n    `doc_obj` is a `pdoc.Class` which has `__init__` method.\n    \"\"\"\n    # No variables in namespace packages\n    if isinstance(doc_obj, Module) and doc_obj.is_namespace:\n        <IND>return {}, {}\n\n    <DED>vars = {}  # type: Dict[str, str]\n    instance_vars = {}  # type: Dict[str, str]\n\n    if _init_tree:\n        <IND>tree = _init_tree\n    <DED>else:\n        <IND>try:\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "            warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}\n        if isinstance(doc_obj, Class):\n            tree = tree.body[0]  # type: ignore  # ast.parse creates a dummy ast.Module wrapper\n\n    vs = {}  # type: Dict[str, Variable]\n\n    cls = None\n    module = doc_obj\n    module_all = set(getattr(module.obj, '__all__', ()))\n    member_obj = dict(inspect.getmembers(doc_obj.obj)).get\n\n    if isinstance(doc_obj, Class):\n        cls = doc_obj\n        module = doc_obj.module\n\n        # For classes, first add instance variables defined in __init__\n        if not _init_tree:\n            # Recursive call with just the __init__ tree\n            for node in tree.body:\n                if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    vs.update(_var_docstrings(doc_obj, _init_tree=node))\n                    break\n",
        "source_code_len": 887,
        "target_code": "            warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}, {}\n\n        if isinstance(doc_obj, Class):\n            tree = tree.body[0]  # ast.parse creates a dummy ast.Module wrapper\n\n            # For classes, maybe add instance variables defined in __init__\n            for node in tree.body:\n                if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    instance_vars, _ = _pep224_docstrings(doc_obj, _init_tree=node)\n                    break\n",
        "target_code_len": 522,
        "diff_format": "@@ -223,23 +226,11 @@\n             warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n-            return {}\n+            return {}, {}\n+\n         if isinstance(doc_obj, Class):\n-            tree = tree.body[0]  # type: ignore  # ast.parse creates a dummy ast.Module wrapper\n-\n-    vs = {}  # type: Dict[str, Variable]\n-\n-    cls = None\n-    module = doc_obj\n-    module_all = set(getattr(module.obj, '__all__', ()))\n-    member_obj = dict(inspect.getmembers(doc_obj.obj)).get\n-\n-    if isinstance(doc_obj, Class):\n-        cls = doc_obj\n-        module = doc_obj.module\n-\n-        # For classes, first add instance variables defined in __init__\n-        if not _init_tree:\n-            # Recursive call with just the __init__ tree\n+            tree = tree.body[0]  # ast.parse creates a dummy ast.Module wrapper\n+\n+            # For classes, maybe add instance variables defined in __init__\n             for node in tree.body:\n                 if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n-                    vs.update(_var_docstrings(doc_obj, _init_tree=node))\n+                    instance_vars, _ = _pep224_docstrings(doc_obj, _init_tree=node)\n                     break\n",
        "source_code_with_indent": "            <IND>warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}\n        <DED>if isinstance(doc_obj, Class):\n            <IND>tree = tree.body[0]  # type: ignore  # ast.parse creates a dummy ast.Module wrapper\n\n    <DED><DED>vs = {}  # type: Dict[str, Variable]\n\n    cls = None\n    module = doc_obj\n    module_all = set(getattr(module.obj, '__all__', ()))\n    member_obj = dict(inspect.getmembers(doc_obj.obj)).get\n\n    if isinstance(doc_obj, Class):\n        <IND>cls = doc_obj\n        module = doc_obj.module\n\n        # For classes, first add instance variables defined in __init__\n        if not _init_tree:\n            # Recursive call with just the __init__ tree\n            <IND>for node in tree.body:\n                <IND>if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    <IND>vs.update(_var_docstrings(doc_obj, _init_tree=node))\n                    break\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "            <IND>warn(\"Couldn't get/parse source of '{!r}'\".format(doc_obj))\n            return {}, {}\n\n        <DED>if isinstance(doc_obj, Class):\n            <IND>tree = tree.body[0]  # ast.parse creates a dummy ast.Module wrapper\n\n            # For classes, maybe add instance variables defined in __init__\n            for node in tree.body:\n                <IND>if isinstance(node, ast.FunctionDef) and node.name == '__init__':\n                    <IND>instance_vars, _ = _pep224_docstrings(doc_obj, _init_tree=node)\n                    break\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": true,
        "has_suppression": false,
        "source_code": "\n        if not _is_public(name):\n            continue\n\n        if module_all and name not in module_all:\n            continue\n\n        docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "source_code_len": 191,
        "target_code": "\n        docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "target_code_len": 64,
        "diff_format": "@@ -277,8 +267,2 @@\n \n-        if not _is_public(name):\n-            continue\n-\n-        if module_all and name not in module_all:\n-            continue\n-\n         docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "source_code_with_indent": "\n        <DED>if not _is_public(name):\n            <IND>continue\n\n        <DED>if module_all and name not in module_all:\n            <IND>continue\n\n        <DED>docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>docstring = inspect.cleandoc(str_node.value.s).strip()\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        vs[name] = Variable(name, module, docstring,\n                            obj=member_obj(name),\n                            cls=cls, instance_var=bool(_init_tree))\n    return vs\n\n",
        "source_code_len": 187,
        "target_code": "\n        vars[name] = docstring\n\n    return vars, instance_vars\n\n",
        "target_code_len": 65,
        "diff_format": "@@ -287,6 +271,5 @@\n \n-        vs[name] = Variable(name, module, docstring,\n-                            obj=member_obj(name),\n-                            cls=cls, instance_var=bool(_init_tree))\n-    return vs\n+        vars[name] = docstring\n+\n+    return vars, instance_vars\n \n",
        "source_code_with_indent": "\n        <DED>vs[name] = Variable(name, module, docstring,\n                            obj=member_obj(name),\n                            cls=cls, instance_var=bool(_init_tree))\n    <DED>return vs\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        <DED>vars[name] = docstring\n\n    <DED>return vars, instance_vars\n\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\n        # Populate self.doc with this module's public members\n",
        "source_code_len": 63,
        "target_code": "\n        var_docstrings, _ = _pep224_docstrings(self)\n\n        # Populate self.doc with this module's public members\n",
        "target_code_len": 117,
        "diff_format": "@@ -543,2 +530,4 @@\n \n+        var_docstrings, _ = _pep224_docstrings(self)\n+\n         # Populate self.doc with this module's public members\n",
        "source_code_with_indent": "\n        # Populate self.doc with this module's public members\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n        var_docstrings, _ = _pep224_docstrings(self)\n\n        # Populate self.doc with this module's public members\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "                self.doc[name] = Class(name, self, obj)\n\n        self.doc.update(_var_docstrings(self))\n\n",
        "source_code_len": 105,
        "target_code": "                self.doc[name] = Class(name, self, obj)\n            elif name in var_docstrings:\n                self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)\n\n",
        "target_code_len": 183,
        "diff_format": "@@ -568,4 +558,4 @@\n                 self.doc[name] = Class(name, self, obj)\n-\n-        self.doc.update(_var_docstrings(self))\n+            elif name in var_docstrings:\n+                self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)\n \n",
        "source_code_with_indent": "                <IND>self.doc[name] = Class(name, self, obj)\n\n        <DED><DED>self.doc.update(_var_docstrings(self))\n\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "                <IND>self.doc[name] = Class(name, self, obj)\n            <DED>elif name in var_docstrings:\n                <IND>self.doc[name] = Variable(name, self, var_docstrings[name], obj=obj)\n\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]