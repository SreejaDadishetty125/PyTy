[
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/parsers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/parsers.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/parsers.py:113:48 Incompatible parameter type [6]: Expected `Tuple[Union[int, str]]` for 2nd positional only parameter to call `get_path_parser` but got `typing.Tuple[Union[int, str], ...]`.",
    "message": " Expected `Tuple[Union[int, str]]` for 2nd positional only parameter to call `get_path_parser` but got `typing.Tuple[Union[int, str], ...]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 113,
    "warning_line": "        return item[0], get_path_parser(parser, item[1:])",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from .exceptions import InvalidFieldError\nfrom .schema import Schema, get_dataclass_fields\n",
        "source_code_len": 91,
        "target_code": "from .exceptions import InvalidFieldError\nfrom .path_utils import Path\nfrom .schema import Schema, get_dataclass_fields\n",
        "target_code_len": 120,
        "diff_format": "@@ -12,2 +12,3 @@\n from .exceptions import InvalidFieldError\n+from .path_utils import Path\n from .schema import Schema, get_dataclass_fields\n",
        "source_code_with_indent": "from .exceptions import InvalidFieldError\nfrom .schema import Schema, get_dataclass_fields\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from .exceptions import InvalidFieldError\nfrom .path_utils import Path\nfrom .schema import Schema, get_dataclass_fields\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_path_parser(parser: Parser[T], path: Tuple[Union[str, int]]) -> Parser[T]:\n    def path_parser(data):\n",
        "source_code_len": 111,
        "target_code": "\ndef get_path_parser(parser: Parser[T], path: Path) -> Parser[T]:\n    def path_parser(data):\n",
        "target_code_len": 93,
        "diff_format": "@@ -95,3 +96,3 @@\n \n-def get_path_parser(parser: Parser[T], path: Tuple[Union[str, int]]) -> Parser[T]:\n+def get_path_parser(parser: Parser[T], path: Path) -> Parser[T]:\n     def path_parser(data):\n",
        "source_code_with_indent": "\n<DED>def get_path_parser(parser: Parser[T], path: Tuple[Union[str, int]]) -> Parser[T]:\n    <IND>def path_parser(data):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_path_parser(parser: Parser[T], path: Path) -> Parser[T]:\n    <IND>def path_parser(data):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/parsers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/parsers.py",
    "file_hunks_size": 3,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/parsers.py:123:33 Incompatible parameter type [6]: Expected `Union[Tuple[str, int], int, str]` for 1st positional only parameter to call `get_field_parser` but got `Union[str, typing.Tuple[Union[int, str], ...]]`.",
    "message": " Expected `Union[Tuple[str, int], int, str]` for 1st positional only parameter to call `get_field_parser` but got `Union[str, typing.Tuple[Union[int, str], ...]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 123,
    "warning_line": "        (name, *get_field_parser(item, parsers[name]))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from .exceptions import InvalidFieldError\nfrom .schema import Schema, get_dataclass_fields\n",
        "source_code_len": 91,
        "target_code": "from .exceptions import InvalidFieldError\nfrom .path_utils import Path\nfrom .schema import Schema, get_dataclass_fields\n",
        "target_code_len": 120,
        "diff_format": "@@ -12,2 +12,3 @@\n from .exceptions import InvalidFieldError\n+from .path_utils import Path\n from .schema import Schema, get_dataclass_fields\n",
        "source_code_with_indent": "from .exceptions import InvalidFieldError\nfrom .schema import Schema, get_dataclass_fields\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from .exceptions import InvalidFieldError\nfrom .path_utils import Path\nfrom .schema import Schema, get_dataclass_fields\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef get_field_parser(item: Union[str, int, Tuple[str, int]], parser: Parser[T]) -> Tuple[Union[str, int], Parser[T]]:\n    if isinstance(item, tuple):\n",
        "source_code_len": 151,
        "target_code": "\ndef get_field_parser(item: Union[str, int, Path], parser: Parser[T]) -> Tuple[Union[str, int], Parser[T]]:\n    if isinstance(item, tuple):\n",
        "target_code_len": 140,
        "diff_format": "@@ -108,3 +109,3 @@\n \n-def get_field_parser(item: Union[str, int, Tuple[str, int]], parser: Parser[T]) -> Tuple[Union[str, int], Parser[T]]:\n+def get_field_parser(item: Union[str, int, Path], parser: Parser[T]) -> Tuple[Union[str, int], Parser[T]]:\n     if isinstance(item, tuple):\n",
        "source_code_with_indent": "\n<DED>def get_field_parser(item: Union[str, int, Tuple[str, int]], parser: Parser[T]) -> Tuple[Union[str, int], Parser[T]]:\n    <IND>if isinstance(item, tuple):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED>def get_field_parser(item: Union[str, int, Path], parser: Parser[T]) -> Tuple[Union[str, int], Parser[T]]:\n    <IND>if isinstance(item, tuple):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/path_utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/path_utils.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/path_utils.py:36:55 Incompatible parameter type [6]: Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__getitem__` but got `Union[int, str]`.",
    "message": " Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__getitem__` but got `Union[int, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 36,
    "warning_line": "            elif isinstance(current, List) and current[prev_key] is None:",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_len": 154,
        "target_code": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_len": 161,
        "diff_format": "@@ -1,5 +1,5 @@\n-from typing import Dict, List, Union, Iterable, Tuple\n+from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n \n Key = Union[str, int]\n-Container = Union[None, List, Dict[Key, \"Container\"]]\n+Container = Union[None, List, Dict[Key, Any]]\n Path = Tuple[Key, ...]\n",
        "source_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef init_structure(paths: Iterable[Path]) -> Container:\n    root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_len": 135,
        "target_code": "\ndef init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_len": 210,
        "diff_format": "@@ -24,5 +24,5 @@\n \n-def init_structure(paths: Iterable[Path]) -> Container:\n-    root: Container = [None]\n-    field_containers = []\n+def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n+    root: List[Container] = [None]\n+    field_containers: List[Tuple[Container, Key]] = []\n     for path in paths:\n",
        "source_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Container:\n    <IND>root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    <IND>root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/path_utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/path_utils.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/path_utils.py:41:24 Incompatible parameter type [6]: Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__setitem__` but got `Union[int, str]`.",
    "message": " Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__setitem__` but got `Union[int, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 41,
    "warning_line": "                current[prev_key] = make_container(next_key)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_len": 154,
        "target_code": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_len": 161,
        "diff_format": "@@ -1,5 +1,5 @@\n-from typing import Dict, List, Union, Iterable, Tuple\n+from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n \n Key = Union[str, int]\n-Container = Union[None, List, Dict[Key, \"Container\"]]\n+Container = Union[None, List, Dict[Key, Any]]\n Path = Tuple[Key, ...]\n",
        "source_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef init_structure(paths: Iterable[Path]) -> Container:\n    root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_len": 135,
        "target_code": "\ndef init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_len": 210,
        "diff_format": "@@ -24,5 +24,5 @@\n \n-def init_structure(paths: Iterable[Path]) -> Container:\n-    root: Container = [None]\n-    field_containers = []\n+def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n+    root: List[Container] = [None]\n+    field_containers: List[Tuple[Container, Key]] = []\n     for path in paths:\n",
        "source_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Container:\n    <IND>root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    <IND>root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/path_utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/path_utils.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/path_utils.py:41:36 Incompatible parameter type [6]: Expected `None` for 2nd positional only parameter to call `list.__setitem__` but got `dataclass_factory.path_utils.Container (resolves to Union[None, Dict[Union[int, str], Container], List[typing.Any]])`.",
    "message": " Expected `None` for 2nd positional only parameter to call `list.__setitem__` but got `dataclass_factory.path_utils.Container (resolves to Union[None, Dict[Union[int, str], Container], List[typing.Any]])`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 41,
    "warning_line": "                current[prev_key] = make_container(next_key)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_len": 154,
        "target_code": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_len": 161,
        "diff_format": "@@ -1,5 +1,5 @@\n-from typing import Dict, List, Union, Iterable, Tuple\n+from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n \n Key = Union[str, int]\n-Container = Union[None, List, Dict[Key, \"Container\"]]\n+Container = Union[None, List, Dict[Key, Any]]\n Path = Tuple[Key, ...]\n",
        "source_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef init_structure(paths: Iterable[Path]) -> Container:\n    root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_len": 135,
        "target_code": "\ndef init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_len": 210,
        "diff_format": "@@ -24,5 +24,5 @@\n \n-def init_structure(paths: Iterable[Path]) -> Container:\n-    root: Container = [None]\n-    field_containers = []\n+def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n+    root: List[Container] = [None]\n+    field_containers: List[Tuple[Container, Key]] = []\n     for path in paths:\n",
        "source_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Container:\n    <IND>root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    <IND>root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/path_utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/path_utils.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/path_utils.py:43:41 Incompatible parameter type [6]: Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__getitem__` but got `Union[int, str]`.",
    "message": " Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__getitem__` but got `Union[int, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 43,
    "warning_line": "                extend_container(current[prev_key], next_key)",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_len": 154,
        "target_code": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_len": 161,
        "diff_format": "@@ -1,5 +1,5 @@\n-from typing import Dict, List, Union, Iterable, Tuple\n+from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n \n Key = Union[str, int]\n-Container = Union[None, List, Dict[Key, \"Container\"]]\n+Container = Union[None, List, Dict[Key, Any]]\n Path = Tuple[Key, ...]\n",
        "source_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef init_structure(paths: Iterable[Path]) -> Container:\n    root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_len": 135,
        "target_code": "\ndef init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_len": 210,
        "diff_format": "@@ -24,5 +24,5 @@\n \n-def init_structure(paths: Iterable[Path]) -> Container:\n-    root: Container = [None]\n-    field_containers = []\n+def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n+    root: List[Container] = [None]\n+    field_containers: List[Tuple[Container, Key]] = []\n     for path in paths:\n",
        "source_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Container:\n    <IND>root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    <IND>root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/path_utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/path_utils.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/path_utils.py:44:30 Incompatible parameter type [6]: Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__getitem__` but got `Union[int, str]`.",
    "message": " Expected `typing_extensions.SupportsIndex` for 1st positional only parameter to call `list.__getitem__` but got `Union[int, str]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 44,
    "warning_line": "            current = current[prev_key]",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_len": 154,
        "target_code": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_len": 161,
        "diff_format": "@@ -1,5 +1,5 @@\n-from typing import Dict, List, Union, Iterable, Tuple\n+from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n \n Key = Union[str, int]\n-Container = Union[None, List, Dict[Key, \"Container\"]]\n+Container = Union[None, List, Dict[Key, Any]]\n Path = Tuple[Key, ...]\n",
        "source_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef init_structure(paths: Iterable[Path]) -> Container:\n    root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_len": 135,
        "target_code": "\ndef init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_len": 210,
        "diff_format": "@@ -24,5 +24,5 @@\n \n-def init_structure(paths: Iterable[Path]) -> Container:\n-    root: Container = [None]\n-    field_containers = []\n+def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n+    root: List[Container] = [None]\n+    field_containers: List[Tuple[Container, Key]] = []\n     for path in paths:\n",
        "source_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Container:\n    <IND>root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    <IND>root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/path_utils.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/path_utils.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/path_utils.py:47:4 Incompatible return type [7]: Expected `dataclass_factory.path_utils.Container (resolves to Union[None, Dict[Union[int, str], Container], List[typing.Any]])` but got `Tuple[None, List[typing.Any]]`.",
    "message": " Expected `dataclass_factory.path_utils.Container (resolves to Union[None, Dict[Union[int, str], Container], List[typing.Any]])` but got `Tuple[None, List[typing.Any]]`.",
    "rule_id": "Incompatible return type [7]",
    "warning_line_no": 47,
    "warning_line": "    return root[0], field_containers",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_len": 154,
        "target_code": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_len": 161,
        "diff_format": "@@ -1,5 +1,5 @@\n-from typing import Dict, List, Union, Iterable, Tuple\n+from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n \n Key = Union[str, int]\n-Container = Union[None, List, Dict[Key, \"Container\"]]\n+Container = Union[None, List, Dict[Key, Any]]\n Path = Tuple[Key, ...]\n",
        "source_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, \"Container\"]]\nPath = Tuple[Key, ...]\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from typing import Dict, List, Union, Iterable, Tuple, Sequence, Any\n\nKey = Union[str, int]\nContainer = Union[None, List, Dict[Key, Any]]\nPath = Tuple[Key, ...]\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef init_structure(paths: Iterable[Path]) -> Container:\n    root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_len": 135,
        "target_code": "\ndef init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_len": 210,
        "diff_format": "@@ -24,5 +24,5 @@\n \n-def init_structure(paths: Iterable[Path]) -> Container:\n-    root: Container = [None]\n-    field_containers = []\n+def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n+    root: List[Container] = [None]\n+    field_containers: List[Tuple[Container, Key]] = []\n     for path in paths:\n",
        "source_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Container:\n    <IND>root: Container = [None]\n    field_containers = []\n    for path in paths:\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\n<DED><DED>def init_structure(paths: Iterable[Path]) -> Tuple[Container, Sequence[Tuple[Container, Key]]]:\n    <IND>root: List[Container] = [None]\n    field_containers: List[Tuple[Container, Key]] = []\n    for path in paths:\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  },
  {
    "project": "Tishka17/dataclass_factory",
    "commit": "933b06d2899685b263d6695be14a105dae6403f9",
    "filename": "dataclass_factory/serializers.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/Tishka17-dataclass_factory/dataclass_factory/serializers.py",
    "file_hunks_size": 4,
    "min_patch_found": true,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "dataclass_factory/serializers.py:25:31 Incompatible parameter type [6]: Expected `Union[Tuple[Union[int, str]], int, str]` for 1st positional only parameter to call `to_tuple` but got `Union[str, typing.Tuple[Union[int, str], ...]]`.",
    "message": " Expected `Union[Tuple[Union[int, str]], int, str]` for 1st positional only parameter to call `to_tuple` but got `Union[str, typing.Tuple[Union[int, str], ...]]`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 25,
    "warning_line": "            (i, name, to_tuple(path), serializers[name])",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "from marshal import loads, dumps\nfrom typing import Any, Type, get_type_hints, List, Dict, Optional, Tuple, Union\n\nfrom .common import Serializer, T\nfrom .path_utils import Key, init_structure\nfrom .schema import Schema, get_dataclass_fields\n",
        "source_code_len": 242,
        "target_code": "from marshal import loads, dumps\nfrom typing import Any, Type, get_type_hints, List, Dict, Optional, Union\n\nfrom .common import Serializer, T\nfrom .path_utils import init_structure, Path\nfrom .schema import Schema, get_dataclass_fields\n",
        "target_code_len": 236,
        "diff_format": "@@ -4,6 +4,6 @@\n from marshal import loads, dumps\n-from typing import Any, Type, get_type_hints, List, Dict, Optional, Tuple, Union\n+from typing import Any, Type, get_type_hints, List, Dict, Optional, Union\n \n from .common import Serializer, T\n-from .path_utils import Key, init_structure\n+from .path_utils import init_structure, Path\n from .schema import Schema, get_dataclass_fields\n",
        "source_code_with_indent": "from marshal import loads, dumps\nfrom typing import Any, Type, get_type_hints, List, Dict, Optional, Tuple, Union\n\nfrom .common import Serializer, T\nfrom .path_utils import Key, init_structure\nfrom .schema import Schema, get_dataclass_fields\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "from marshal import loads, dumps\nfrom typing import Any, Type, get_type_hints, List, Dict, Optional, Union\n\nfrom .common import Serializer, T\nfrom .path_utils import init_structure, Path\nfrom .schema import Schema, get_dataclass_fields\n",
        "target_code_with_indent_exact_match": true
      },
      {
        "hunk_fit_TFix": false,
        "inside_window": false,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "\ndef to_tuple(key: Union[Key, Tuple[Key]]) -> Tuple[Key]:\n    if isinstance(key, tuple):\n",
        "source_code_len": 89,
        "target_code": "\ndef to_tuple(key: Union[str, Path]) -> Path:\n    if isinstance(key, tuple):\n",
        "target_code_len": 77,
        "diff_format": "@@ -15,3 +15,3 @@\n \n-def to_tuple(key: Union[Key, Tuple[Key]]) -> Tuple[Key]:\n+def to_tuple(key: Union[str, Path]) -> Path:\n     if isinstance(key, tuple):\n",
        "source_code_with_indent": "\ndef to_tuple(key: Union[Key, Tuple[Key]]) -> Tuple[Key]:\n    <IND>if isinstance(key, tuple):\n",
        "source_code_with_indent_exact_match": true,
        "target_code_with_indent": "\ndef to_tuple(key: Union[str, Path]) -> Path:\n    <IND>if isinstance(key, tuple):\n",
        "target_code_with_indent_exact_match": true
      }
    ]
  }
]