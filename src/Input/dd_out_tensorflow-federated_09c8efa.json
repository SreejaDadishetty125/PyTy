[
  {
    "project": "tensorflow/federated",
    "commit": "09c8efa26aafd12be08d36f7808b225c55a11c3b",
    "filename": "tensorflow_federated/python/aggregators/clipping_factory.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-federated/tensorflow_federated/python/aggregators/robust_factory.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorflow_federated/python/aggregators/clipping_factory.py:155:12 Incompatible parameter type [6]: Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "message": " Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 155,
    "warning_line": "            computation_types.to_type(COUNT_TF_TYPE)))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  being aggregated.\n  \"\"\"\n\n  def __init__(self, clipping_norm: Union[float,\n                                          estimation_process.EstimationProcess],\n               inner_agg_factory: _InnerFactoryType):\n    \"\"\"Initializes `ClippingFactory`.\n\n    Args:\n      clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n        (for adaptive norm) that specifies the norm over which the values should\n        be clipped.\n      inner_agg_factory: A factory specifying the type of aggregation to be done\n        after clipping.\n    \"\"\"\n    py_typecheck.check_type(inner_agg_factory, _InnerFactoryType.__args__)\n    self._inner_agg_factory = inner_agg_factory\n\n    py_typecheck.check_type(clipping_norm,\n                            (float, estimation_process.EstimationProcess))\n    if isinstance(clipping_norm, float):\n      clipping_norm = _constant_process(clipping_norm)\n    _check_norm_process(clipping_norm, 'clipping_norm')\n    self._clipping_norm_process = clipping_norm\n\n    # The aggregation factory that will be used to count the number of clipped\n    # values at each iteration. For now we are just creating it here, but soon\n    # we will make this customizable to allow DP measurements.\n    self._clipped_count_agg_factory = sum_factory.SumFactory()\n\n  def create_unweighted(\n      self,\n      value_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    inner_agg_process = self._inner_agg_factory.create_unweighted(value_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  def create_weighted(\n      self, value_type: factory.ValueType,\n      weight_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    py_typecheck.check_type(weight_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    inner_agg_process = self._inner_agg_factory.create_weighted(\n        value_type, weight_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  def _create_init_fn(self, inner_agg_initialize, clipped_count_agg_initialize):\n\n    @computations.federated_computation()\n    def init_fn():\n      return intrinsics.federated_zip(\n          collections.OrderedDict(\n              clipping_norm=self._clipping_norm_process.initialize(),\n              inner_agg=inner_agg_initialize(),\n              clipped_count_agg=clipped_count_agg_initialize()))\n\n    return init_fn\n\n  def _create_next_fn(self, inner_agg_next, clipped_count_agg_next, state_type):\n\n    @computations.tf_computation(\n        inner_agg_next.type_signature.parameter[1].member, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n",
        "source_code_len": 4129,
        "target_code": "  being aggregated.\n\n  The returned `AggregationFactory` takes its weightedness\n  (`UnweightedAggregationFactory` vs. `WeightedAggregationFactory`) from\n  `inner_agg_factory`.\n\n  Args:\n    clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n      (for adaptive norm) that specifies the norm over which the values should\n      be clipped.\n    inner_agg_factory: A factory specifying the type of aggregation to be done\n      after clipping.\n\n  Returns:\n    An aggregation factory to perform L2 clipping.\n  \"\"\"\n\n  def make_clip_fn(value_type):\n\n    @computations.tf_computation(value_type, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n",
        "target_code_len": 661,
        "diff_format": "@@ -114,91 +114,21 @@\n   being aggregated.\n+\n+  The returned `AggregationFactory` takes its weightedness\n+  (`UnweightedAggregationFactory` vs. `WeightedAggregationFactory`) from\n+  `inner_agg_factory`.\n+\n+  Args:\n+    clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n+      (for adaptive norm) that specifies the norm over which the values should\n+      be clipped.\n+    inner_agg_factory: A factory specifying the type of aggregation to be done\n+      after clipping.\n+\n+  Returns:\n+    An aggregation factory to perform L2 clipping.\n   \"\"\"\n \n-  def __init__(self, clipping_norm: Union[float,\n-                                          estimation_process.EstimationProcess],\n-               inner_agg_factory: _InnerFactoryType):\n-    \"\"\"Initializes `ClippingFactory`.\n-\n-    Args:\n-      clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n-        (for adaptive norm) that specifies the norm over which the values should\n-        be clipped.\n-      inner_agg_factory: A factory specifying the type of aggregation to be done\n-        after clipping.\n-    \"\"\"\n-    py_typecheck.check_type(inner_agg_factory, _InnerFactoryType.__args__)\n-    self._inner_agg_factory = inner_agg_factory\n-\n-    py_typecheck.check_type(clipping_norm,\n-                            (float, estimation_process.EstimationProcess))\n-    if isinstance(clipping_norm, float):\n-      clipping_norm = _constant_process(clipping_norm)\n-    _check_norm_process(clipping_norm, 'clipping_norm')\n-    self._clipping_norm_process = clipping_norm\n-\n-    # The aggregation factory that will be used to count the number of clipped\n-    # values at each iteration. For now we are just creating it here, but soon\n-    # we will make this customizable to allow DP measurements.\n-    self._clipped_count_agg_factory = sum_factory.SumFactory()\n-\n-  def create_unweighted(\n-      self,\n-      value_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n-    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n-    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n-      raise TypeError(f'All values in provided value_type must be of floating '\n-                      f'dtype. Provided value_type: {value_type}')\n-\n-    inner_agg_process = self._inner_agg_factory.create_unweighted(value_type)\n-    clipped_count_agg_process = (\n-        self._clipped_count_agg_factory.create_unweighted(\n-            computation_types.to_type(COUNT_TF_TYPE)))\n-\n-    init_fn = self._create_init_fn(inner_agg_process.initialize,\n-                                   clipped_count_agg_process.initialize)\n-    next_fn = self._create_next_fn(inner_agg_process.next,\n-                                   clipped_count_agg_process.next,\n-                                   init_fn.type_signature.result)\n-\n-    return aggregation_process.AggregationProcess(init_fn, next_fn)\n-\n-  def create_weighted(\n-      self, value_type: factory.ValueType,\n-      weight_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n-    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n-    py_typecheck.check_type(weight_type, factory.ValueType.__args__)\n-    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n-      raise TypeError(f'All values in provided value_type must be of floating '\n-                      f'dtype. Provided value_type: {value_type}')\n-\n-    inner_agg_process = self._inner_agg_factory.create_weighted(\n-        value_type, weight_type)\n-    clipped_count_agg_process = (\n-        self._clipped_count_agg_factory.create_unweighted(\n-            computation_types.to_type(COUNT_TF_TYPE)))\n-\n-    init_fn = self._create_init_fn(inner_agg_process.initialize,\n-                                   clipped_count_agg_process.initialize)\n-    next_fn = self._create_next_fn(inner_agg_process.next,\n-                                   clipped_count_agg_process.next,\n-                                   init_fn.type_signature.result)\n-\n-    return aggregation_process.AggregationProcess(init_fn, next_fn)\n-\n-  def _create_init_fn(self, inner_agg_initialize, clipped_count_agg_initialize):\n-\n-    @computations.federated_computation()\n-    def init_fn():\n-      return intrinsics.federated_zip(\n-          collections.OrderedDict(\n-              clipping_norm=self._clipping_norm_process.initialize(),\n-              inner_agg=inner_agg_initialize(),\n-              clipped_count_agg=clipped_count_agg_initialize()))\n-\n-    return init_fn\n-\n-  def _create_next_fn(self, inner_agg_next, clipped_count_agg_next, state_type):\n-\n-    @computations.tf_computation(\n-        inner_agg_next.type_signature.parameter[1].member, NORM_TF_TYPE)\n+  def make_clip_fn(value_type):\n+\n+    @computations.tf_computation(value_type, NORM_TF_TYPE)\n     def clip_fn(value, clipping_norm):\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n  def __init__(self, clipping_norm: Union[float,\n                                          estimation_process.EstimationProcess],\n               inner_agg_factory: _InnerFactoryType):\n    <IND>\"\"\"Initializes `ClippingFactory`.\n\n    Args:\n      clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n        (for adaptive norm) that specifies the norm over which the values should\n        be clipped.\n      inner_agg_factory: A factory specifying the type of aggregation to be done\n        after clipping.\n    \"\"\"\n    py_typecheck.check_type(inner_agg_factory, _InnerFactoryType.__args__)\n    self._inner_agg_factory = inner_agg_factory\n\n    py_typecheck.check_type(clipping_norm,\n                            (float, estimation_process.EstimationProcess))\n    if isinstance(clipping_norm, float):\n      <IND>clipping_norm = _constant_process(clipping_norm)\n    <DED>_check_norm_process(clipping_norm, 'clipping_norm')\n    self._clipping_norm_process = clipping_norm\n\n    # The aggregation factory that will be used to count the number of clipped\n    # values at each iteration. For now we are just creating it here, but soon\n    # we will make this customizable to allow DP measurements.\n    self._clipped_count_agg_factory = sum_factory.SumFactory()\n\n  <DED>def create_unweighted(\n      self,\n      value_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    <IND>py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      <IND>raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    <DED>inner_agg_process = self._inner_agg_factory.create_unweighted(value_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  <DED>def create_weighted(\n      self, value_type: factory.ValueType,\n      weight_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    <IND>py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    py_typecheck.check_type(weight_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      <IND>raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    <DED>inner_agg_process = self._inner_agg_factory.create_weighted(\n        value_type, weight_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  <DED>def _create_init_fn(self, inner_agg_initialize, clipped_count_agg_initialize):\n\n    <IND>@computations.federated_computation()\n    def init_fn():\n      <IND>return intrinsics.federated_zip(\n          collections.OrderedDict(\n              clipping_norm=self._clipping_norm_process.initialize(),\n              inner_agg=inner_agg_initialize(),\n              clipped_count_agg=clipped_count_agg_initialize()))\n\n    <DED>return init_fn\n\n  <DED>def _create_next_fn(self, inner_agg_next, clipped_count_agg_next, state_type):\n\n    <IND>@computations.tf_computation(\n        inner_agg_next.type_signature.parameter[1].member, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n",
        "target_code_with_indent": "\n\n  def make_clip_fn(value_type):\n\n    <IND>@computations.tf_computation(value_type, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n"
      }
    ]
  },
  {
    "project": "tensorflow/federated",
    "commit": "09c8efa26aafd12be08d36f7808b225c55a11c3b",
    "filename": "tensorflow_federated/python/aggregators/clipping_factory.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-federated/tensorflow_federated/python/aggregators/robust_factory.py",
    "file_hunks_size": 8,
    "min_patch_found": true,
    "single_hunk": true,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorflow_federated/python/aggregators/clipping_factory.py:178:12 Incompatible parameter type [6]: Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "message": " Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 178,
    "warning_line": "            computation_types.to_type(COUNT_TF_TYPE)))",
    "min_patch": [
      {
        "hunk_fit_TFix": false,
        "inside_window": true,
        "delete_only": false,
        "has_suppression": false,
        "source_code": "  being aggregated.\n  \"\"\"\n\n  def __init__(self, clipping_norm: Union[float,\n                                          estimation_process.EstimationProcess],\n               inner_agg_factory: _InnerFactoryType):\n    \"\"\"Initializes `ClippingFactory`.\n\n    Args:\n      clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n        (for adaptive norm) that specifies the norm over which the values should\n        be clipped.\n      inner_agg_factory: A factory specifying the type of aggregation to be done\n        after clipping.\n    \"\"\"\n    py_typecheck.check_type(inner_agg_factory, _InnerFactoryType.__args__)\n    self._inner_agg_factory = inner_agg_factory\n\n    py_typecheck.check_type(clipping_norm,\n                            (float, estimation_process.EstimationProcess))\n    if isinstance(clipping_norm, float):\n      clipping_norm = _constant_process(clipping_norm)\n    _check_norm_process(clipping_norm, 'clipping_norm')\n    self._clipping_norm_process = clipping_norm\n\n    # The aggregation factory that will be used to count the number of clipped\n    # values at each iteration. For now we are just creating it here, but soon\n    # we will make this customizable to allow DP measurements.\n    self._clipped_count_agg_factory = sum_factory.SumFactory()\n\n  def create_unweighted(\n      self,\n      value_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    inner_agg_process = self._inner_agg_factory.create_unweighted(value_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  def create_weighted(\n      self, value_type: factory.ValueType,\n      weight_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    py_typecheck.check_type(weight_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    inner_agg_process = self._inner_agg_factory.create_weighted(\n        value_type, weight_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  def _create_init_fn(self, inner_agg_initialize, clipped_count_agg_initialize):\n\n    @computations.federated_computation()\n    def init_fn():\n      return intrinsics.federated_zip(\n          collections.OrderedDict(\n              clipping_norm=self._clipping_norm_process.initialize(),\n              inner_agg=inner_agg_initialize(),\n              clipped_count_agg=clipped_count_agg_initialize()))\n\n    return init_fn\n\n  def _create_next_fn(self, inner_agg_next, clipped_count_agg_next, state_type):\n\n    @computations.tf_computation(\n        inner_agg_next.type_signature.parameter[1].member, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n",
        "source_code_len": 4129,
        "target_code": "  being aggregated.\n\n  The returned `AggregationFactory` takes its weightedness\n  (`UnweightedAggregationFactory` vs. `WeightedAggregationFactory`) from\n  `inner_agg_factory`.\n\n  Args:\n    clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n      (for adaptive norm) that specifies the norm over which the values should\n      be clipped.\n    inner_agg_factory: A factory specifying the type of aggregation to be done\n      after clipping.\n\n  Returns:\n    An aggregation factory to perform L2 clipping.\n  \"\"\"\n\n  def make_clip_fn(value_type):\n\n    @computations.tf_computation(value_type, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n",
        "target_code_len": 661,
        "diff_format": "@@ -114,91 +114,21 @@\n   being aggregated.\n+\n+  The returned `AggregationFactory` takes its weightedness\n+  (`UnweightedAggregationFactory` vs. `WeightedAggregationFactory`) from\n+  `inner_agg_factory`.\n+\n+  Args:\n+    clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n+      (for adaptive norm) that specifies the norm over which the values should\n+      be clipped.\n+    inner_agg_factory: A factory specifying the type of aggregation to be done\n+      after clipping.\n+\n+  Returns:\n+    An aggregation factory to perform L2 clipping.\n   \"\"\"\n \n-  def __init__(self, clipping_norm: Union[float,\n-                                          estimation_process.EstimationProcess],\n-               inner_agg_factory: _InnerFactoryType):\n-    \"\"\"Initializes `ClippingFactory`.\n-\n-    Args:\n-      clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n-        (for adaptive norm) that specifies the norm over which the values should\n-        be clipped.\n-      inner_agg_factory: A factory specifying the type of aggregation to be done\n-        after clipping.\n-    \"\"\"\n-    py_typecheck.check_type(inner_agg_factory, _InnerFactoryType.__args__)\n-    self._inner_agg_factory = inner_agg_factory\n-\n-    py_typecheck.check_type(clipping_norm,\n-                            (float, estimation_process.EstimationProcess))\n-    if isinstance(clipping_norm, float):\n-      clipping_norm = _constant_process(clipping_norm)\n-    _check_norm_process(clipping_norm, 'clipping_norm')\n-    self._clipping_norm_process = clipping_norm\n-\n-    # The aggregation factory that will be used to count the number of clipped\n-    # values at each iteration. For now we are just creating it here, but soon\n-    # we will make this customizable to allow DP measurements.\n-    self._clipped_count_agg_factory = sum_factory.SumFactory()\n-\n-  def create_unweighted(\n-      self,\n-      value_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n-    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n-    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n-      raise TypeError(f'All values in provided value_type must be of floating '\n-                      f'dtype. Provided value_type: {value_type}')\n-\n-    inner_agg_process = self._inner_agg_factory.create_unweighted(value_type)\n-    clipped_count_agg_process = (\n-        self._clipped_count_agg_factory.create_unweighted(\n-            computation_types.to_type(COUNT_TF_TYPE)))\n-\n-    init_fn = self._create_init_fn(inner_agg_process.initialize,\n-                                   clipped_count_agg_process.initialize)\n-    next_fn = self._create_next_fn(inner_agg_process.next,\n-                                   clipped_count_agg_process.next,\n-                                   init_fn.type_signature.result)\n-\n-    return aggregation_process.AggregationProcess(init_fn, next_fn)\n-\n-  def create_weighted(\n-      self, value_type: factory.ValueType,\n-      weight_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n-    py_typecheck.check_type(value_type, factory.ValueType.__args__)\n-    py_typecheck.check_type(weight_type, factory.ValueType.__args__)\n-    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n-      raise TypeError(f'All values in provided value_type must be of floating '\n-                      f'dtype. Provided value_type: {value_type}')\n-\n-    inner_agg_process = self._inner_agg_factory.create_weighted(\n-        value_type, weight_type)\n-    clipped_count_agg_process = (\n-        self._clipped_count_agg_factory.create_unweighted(\n-            computation_types.to_type(COUNT_TF_TYPE)))\n-\n-    init_fn = self._create_init_fn(inner_agg_process.initialize,\n-                                   clipped_count_agg_process.initialize)\n-    next_fn = self._create_next_fn(inner_agg_process.next,\n-                                   clipped_count_agg_process.next,\n-                                   init_fn.type_signature.result)\n-\n-    return aggregation_process.AggregationProcess(init_fn, next_fn)\n-\n-  def _create_init_fn(self, inner_agg_initialize, clipped_count_agg_initialize):\n-\n-    @computations.federated_computation()\n-    def init_fn():\n-      return intrinsics.federated_zip(\n-          collections.OrderedDict(\n-              clipping_norm=self._clipping_norm_process.initialize(),\n-              inner_agg=inner_agg_initialize(),\n-              clipped_count_agg=clipped_count_agg_initialize()))\n-\n-    return init_fn\n-\n-  def _create_next_fn(self, inner_agg_next, clipped_count_agg_next, state_type):\n-\n-    @computations.tf_computation(\n-        inner_agg_next.type_signature.parameter[1].member, NORM_TF_TYPE)\n+  def make_clip_fn(value_type):\n+\n+    @computations.tf_computation(value_type, NORM_TF_TYPE)\n     def clip_fn(value, clipping_norm):\n",
        "source_code_with_indent_exact_match": false,
        "target_code_with_indent_exact_match": false,
        "source_code_with_indent": "\n\n  def __init__(self, clipping_norm: Union[float,\n                                          estimation_process.EstimationProcess],\n               inner_agg_factory: _InnerFactoryType):\n    <IND>\"\"\"Initializes `ClippingFactory`.\n\n    Args:\n      clipping_norm: Either a float (for fixed norm) or an `EstimationProcess`\n        (for adaptive norm) that specifies the norm over which the values should\n        be clipped.\n      inner_agg_factory: A factory specifying the type of aggregation to be done\n        after clipping.\n    \"\"\"\n    py_typecheck.check_type(inner_agg_factory, _InnerFactoryType.__args__)\n    self._inner_agg_factory = inner_agg_factory\n\n    py_typecheck.check_type(clipping_norm,\n                            (float, estimation_process.EstimationProcess))\n    if isinstance(clipping_norm, float):\n      <IND>clipping_norm = _constant_process(clipping_norm)\n    <DED>_check_norm_process(clipping_norm, 'clipping_norm')\n    self._clipping_norm_process = clipping_norm\n\n    # The aggregation factory that will be used to count the number of clipped\n    # values at each iteration. For now we are just creating it here, but soon\n    # we will make this customizable to allow DP measurements.\n    self._clipped_count_agg_factory = sum_factory.SumFactory()\n\n  <DED>def create_unweighted(\n      self,\n      value_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    <IND>py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      <IND>raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    <DED>inner_agg_process = self._inner_agg_factory.create_unweighted(value_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  <DED>def create_weighted(\n      self, value_type: factory.ValueType,\n      weight_type: factory.ValueType) -> aggregation_process.AggregationProcess:\n    <IND>py_typecheck.check_type(value_type, factory.ValueType.__args__)\n    py_typecheck.check_type(weight_type, factory.ValueType.__args__)\n    if type_analysis.contains(value_type, predicate=_contains_non_float_dtype):\n      <IND>raise TypeError(f'All values in provided value_type must be of floating '\n                      f'dtype. Provided value_type: {value_type}')\n\n    <DED>inner_agg_process = self._inner_agg_factory.create_weighted(\n        value_type, weight_type)\n    clipped_count_agg_process = (\n        self._clipped_count_agg_factory.create_unweighted(\n            computation_types.to_type(COUNT_TF_TYPE)))\n\n    init_fn = self._create_init_fn(inner_agg_process.initialize,\n                                   clipped_count_agg_process.initialize)\n    next_fn = self._create_next_fn(inner_agg_process.next,\n                                   clipped_count_agg_process.next,\n                                   init_fn.type_signature.result)\n\n    return aggregation_process.AggregationProcess(init_fn, next_fn)\n\n  <DED>def _create_init_fn(self, inner_agg_initialize, clipped_count_agg_initialize):\n\n    <IND>@computations.federated_computation()\n    def init_fn():\n      <IND>return intrinsics.federated_zip(\n          collections.OrderedDict(\n              clipping_norm=self._clipping_norm_process.initialize(),\n              inner_agg=inner_agg_initialize(),\n              clipped_count_agg=clipped_count_agg_initialize()))\n\n    <DED>return init_fn\n\n  <DED>def _create_next_fn(self, inner_agg_next, clipped_count_agg_next, state_type):\n\n    <IND>@computations.tf_computation(\n        inner_agg_next.type_signature.parameter[1].member, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n",
        "target_code_with_indent": "\n\n  def make_clip_fn(value_type):\n\n    <IND>@computations.tf_computation(value_type, NORM_TF_TYPE)\n    def clip_fn(value, clipping_norm):\n"
      }
    ]
  },
  {
    "project": "tensorflow/federated",
    "commit": "09c8efa26aafd12be08d36f7808b225c55a11c3b",
    "filename": "tensorflow_federated/python/aggregators/clipping_factory.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-federated/tensorflow_federated/python/aggregators/robust_factory.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorflow_federated/python/aggregators/clipping_factory.py:334:12 Incompatible parameter type [6]: Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "message": " Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 334,
    "warning_line": "            computation_types.to_type(COUNT_TF_TYPE)))"
  },
  {
    "project": "tensorflow/federated",
    "commit": "09c8efa26aafd12be08d36f7808b225c55a11c3b",
    "filename": "tensorflow_federated/python/aggregators/clipping_factory.py",
    "filename_after_commit": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-federated/tensorflow_federated/python/aggregators/robust_factory.py",
    "file_hunks_size": 8,
    "min_patch_found": false,
    "single_hunk": false,
    "fit_TFix": false,
    "delete_only_patch": false,
    "has_suppression_all_hunks": false,
    "full_warning_msg": "tensorflow_federated/python/aggregators/clipping_factory.py:358:12 Incompatible parameter type [6]: Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "message": " Expected `Union[computation_types.StructType, computation_types.TensorType]` for 1st positional only parameter to call `sum_factory.SumFactory.create_unweighted` but got `computation_types.Type`.",
    "rule_id": "Incompatible parameter type [6]",
    "warning_line_no": 358,
    "warning_line": "            computation_types.to_type(COUNT_TF_TYPE)))"
  }
]