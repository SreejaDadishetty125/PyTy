[
  {
    "repo": "getsentry/zeus",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/getsentry-zeus",
    "commit": "95d4a82109fbc0d67f42caa85a198fecb9681a03",
    "filename": "zeus/web/views/__init__.py",
    "source_code": "from zeus.utils.imports import import_submodules\n\nimport_submodules(locals(), __name__, __path__)",
    "target_code": "from .auth_github import *  # NOQA\nfrom .index import *  # NOQA\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `__path__` is used but not defined in the current scope.",
    "warning_line": 3,
    "pred_top-1": {
      "pred": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__, __path__) \n",
      "pred_parsed": "from.config.imports import import_submodules\nfrom.config.import_submodules\nimport_submodules(locals(), __name__, __path__)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__) \n",
      "pred_parsed": "from.config.imports import import_submodules\nfrom.config.import_submodules\nimport_submodules(locals(), __name__)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__) \n \n",
      "pred_parsed": "from.config.imports import import_submodules\nfrom.config.import_submodules\nimport_submodules(locals(), __name__)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__, __path__) \n \n",
      "pred_parsed": "from.config.imports import import_submodules\nfrom.config.import_submodules\nimport_submodules(locals(), __name__, __path__)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "from.config.imports import import_submodules \n from.config.import_submodules \n \n import_submodules(locals(), __name__) \n",
      "pred_parsed": "from.config.imports import import_submodules\nfrom.config.import_submodules\n\nimport_submodules(locals(), __name__)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "grnet/synnefo",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/grnet-synnefo",
    "commit": "2004262b6fefba2c2fcb9e6672227c2aade49476",
    "filename": "commissioning/hlapi/api.py",
    "source_code": "    # internal API\n    @method_accepts(basestring, basestring, basestring, basestring,\n                    int, int, int, int, int)\n    @returns(basestring)\n    def __create_attribute_of_node_for_resource(self,",
    "target_code": "    # internal API\n    <DED>@method_accepts(str, str, str, str,\n                    int, int, int, int, int)\n    @returns(str)\n    def __create_attribute_of_node_for_resource(self,\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `basestring` is used but not defined in the current scope.",
    "warning_line": 94,
    "pred_top-1": {
      "pred": "# internal API \n <DED> @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring, \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n",
      "pred_parsed": "    # internal API\n    @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring,\n    int, int, int, int, int)\n    @returns(method_accepts(method_accepts(method_accepts(basestring)))\n    def __create_attribute_of_node_for_resource(self,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "# internal API \n <DED> @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring, \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(basestring)) \n def __create_attribute_of_node_for_resource(self, \n",
      "pred_parsed": "    # internal API\n    @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring,\n    int, int, int, int, int)\n    @returns(method_accepts(method_accepts(basestring))\n    def __create_attribute_of_node_for_resource(self,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "# internal API \n <DED> @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring), \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n",
      "pred_parsed": "    # internal API\n    @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring),\n    int, int, int, int, int)\n    @returns(method_accepts(method_accepts(method_accepts(basestring)))\n    def __create_attribute_of_node_for_resource(self,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "# internal API \n <DED> @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring), \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n",
      "pred_parsed": "    # internal API\n    @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring),\n    int, int, int, int, int)\n    @returns(method_accepts(method_accepts(method_accepts(method_accepts(basestring)))\n    def __create_attribute_of_node_for_resource(self,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "# internal API \n <DED> @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring), \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(method_accepts(basestring), basestring)) \n def __create_attribute_of_node_for_resource(self, \n",
      "pred_parsed": "    # internal API\n    @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring),\n    int, int, int, int, int)\n    @returns(method_accepts(method_accepts(method_accepts(method_accepts(basestring), basestring))\n    def __create_attribute_of_node_for_resource(self,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "fbchat-dev/fbchat",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/fbchat-dev-fbchat",
    "commit": "deda3b433d5759311fb8232f1d9b6db23a9d4372",
    "filename": "fbchat/_group.py",
    "source_code": "        data = {\"set_mode\": int(require_admin_approval), \"thread_fbid\": thread_id}\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)",
    "target_code": "\n        data = {\"set_mode\": int(require_admin_approval), \"thread_fbid\": self.id}\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `thread_id` is used but not defined in the current scope.",
    "warning_line": 122,
    "pred_top-1": {
      "pred": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": int(thread_id) } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "pred_parsed": "        data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": int(thread_id) }\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": dpr } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "pred_parsed": "        data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": dpr }\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": id } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "pred_parsed": "        data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": id }\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": bool } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "pred_parsed": "        data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": bool }\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n data = { \"set_mode\": int(require_admin_approval) } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "pred_parsed": "        data = { \"set_mode\": int(require_admin_approval) }\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "dropbox/nsot",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dropbox-nsot",
    "commit": "84ba48d6c55286bc18194247072cfd956dfec69f",
    "filename": "setup.py",
    "source_code": "execfile('nsot/version.py')",
    "target_code": "\nfrom nsot.version import __version__\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `execfile` is used but not defined in the current scope.",
    "warning_line": 17,
    "pred_top-1": {
      "pred": "\n execfile('nsot/version.py') \n \n",
      "pred_parsed": "execfile('nsot/version.py')\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n execpath('nsot/version.py') \n \n",
      "pred_parsed": "execpath('nsot/version.py')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n executil('nsot/version.py') \n \n",
      "pred_parsed": "executil('nsot/version.py')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n execfile('nsot/version.py', []) \n \n",
      "pred_parsed": "execfile('nsot/version.py', [])\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n 'nsot/version.py': \n \n",
      "pred_parsed": "'nsot/version.py':\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "tensorflow/tfx",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-tfx",
    "commit": "3d7bb6a0ae0aa0ed6269c2e1f4d2bb3e8bee2a93",
    "filename": "tfx/orchestration/kubeflow/base_component.py",
    "source_code": "  def __new__(cls,\n              output_dir: Text,\n              log_root: Text,\n              beam_pipeline_args: Optional[Text] = None):\n    cls.exec_properties = {",
    "target_code": "  def __new__(cls,\n              output_dir,\n              log_root,\n              beam_pipeline_args = None):\n    <IND>cls.exec_properties = {\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `Text` is used but not defined in the current scope.",
    "warning_line": 40,
    "pred_top-1": {
      "pred": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args: Optional[Text] = None): \n <IND> cls.exec_properties = { \n",
      "pred_parsed": "  def __new__(cls,\n  output_dir,\n  log_root,\n  beam_pipeline_args: Optional[Text] = None):\n      cls.exec_properties = {\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args = None): \n <IND> cls.exec_properties = { \n",
      "pred_parsed": "  def __new__(cls,\n  output_dir,\n  log_root,\n  beam_pipeline_args = None):\n      cls.exec_properties = {\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args, \n beam_pipeline_args = None): \n <IND> cls.exec_properties = { \n",
      "pred_parsed": "  def __new__(cls,\n  output_dir,\n  log_root,\n  beam_pipeline_args,\n  beam_pipeline_args = None):\n      cls.exec_properties = {\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args, \n beam_pipeline_args: Optional[Text] = None): \n <IND> cls.exec_properties = { \n",
      "pred_parsed": "  def __new__(cls,\n  output_dir,\n  log_root,\n  beam_pipeline_args,\n  beam_pipeline_args: Optional[Text] = None):\n      cls.exec_properties = {\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args, \n beam_pipeline_args, \n ): \n <IND> cls.exec_properties = { \n",
      "pred_parsed": "  def __new__(cls,\n  output_dir,\n  log_root,\n  beam_pipeline_args,\n  beam_pipeline_args,\n  ):\n      cls.exec_properties = {\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "python-mario/mario",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mario-mario",
    "commit": "7e9dc5cb9351a2f07d2b0bfcdf3a2fc2e972f962",
    "filename": "src/mario/traversals.py",
    "source_code": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Set[int] = set()",
    "target_code": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: t.Set[int] = set()\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `Set` is used but not defined in the current scope.",
    "warning_line": 223,
    "pred_top-1": {
      "pred": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Optional[Set[int]] = set() \n \n",
      "pred_parsed": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Optional[Set[int]] = set()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Optional[Set] = set() \n \n",
      "pred_parsed": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Optional[Set] = set()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Int = set() \n \n",
      "pred_parsed": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Int = set()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Row[int] = set() \n \n",
      "pred_parsed": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Row[int] = set()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Trio[int] = set() \n \n",
      "pred_parsed": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Trio[int] = set()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "PrefectHQ/prefect",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/PrefectHQ-prefect",
    "commit": "7738c57aea2ca1f4847e2106fbf6d6f3279aaa6c",
    "filename": "src/prefect/client/client.py",
    "source_code": "        if res.createProject.error:\n            raise ClientError(result.createProject.error)",
    "target_code": "        if res.createProject.error:\n            <IND>raise ClientError(res.createProject.error)\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `result` is used but not defined in the current scope.",
    "warning_line": 389,
    "pred_top-1": {
      "pred": "if res.createProject.error: \n <IND> raise ClientError('Unable to create project', result.createProject.error) \n \n",
      "pred_parsed": "        if res.createProject.error:\n            raise ClientError('Unable to create project', result.createProject.error)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "if res.createProject.error: \n <IND> raise ClientError('Unable to create Project', result.createProject.error) \n \n",
      "pred_parsed": "        if res.createProject.error:\n            raise ClientError('Unable to create Project', result.createProject.error)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "if res.createProject.error: \n <IND> raise ClientError('Unable to create project') \n \n",
      "pred_parsed": "        if res.createProject.error:\n            raise ClientError('Unable to create project')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "if res.createProject.error: \n <IND> raise ClientError(\"Unable to create project due to a failure\") \n \n",
      "pred_parsed": "        if res.createProject.error:\n            raise ClientError(\"Unable to create project due to a failure\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "if res.createProject.error: \n <IND> raise ClientError('Unable to create project', result.createProject.error') \n \n",
      "pred_parsed": "        if res.createProject.error:\n            raise ClientError('Unable to create project', result.createProject.error')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "usnistgov/fipy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/usnistgov-fipy",
    "commit": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "filename": "examples/cahnHilliard/tanh1D.py",
    "source_code": "    raw_input('finished')",
    "target_code": "\n    input('finished')\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `raw_input` is used but not defined in the current scope.",
    "warning_line": 160,
    "pred_top-1": {
      "pred": "\n input('finished') \n \n",
      "pred_parsed": "    input('finished')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n input('finished') \n \n \n",
      "pred_parsed": "    input('finished')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n input('finished') \n \n <DED> \n",
      "pred_parsed": "    input('finished')\n    \n\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n input('finished') \n \n \n \n",
      "pred_parsed": "    input('finished')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n input('finished') \n \n <IND> \n",
      "pred_parsed": "    input('finished')\n    \n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "tableau/TabPy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/tableau-TabPy",
    "commit": "38fde421c5a8e1e5b8a28e22aff6f2acb8f25aa4",
    "filename": "tabpy/tabpy_server/handlers/base_handler.py",
    "source_code": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \"{method}\" are configured '\n            f'for API \"{api_version}\"',\n        )",
    "target_code": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \"{method}\" are configured ',\n        )\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `api_version` is used but not defined in the current scope.",
    "warning_line": 315,
    "pred_top-1": {
      "pred": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { api_version } \"', \n ) \n",
      "pred_parsed": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \" { method } \" are configured'\n            f'for API \" { api_version } \"',\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { version } \"', \n ) \n",
      "pred_parsed": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \" { method } \" are configured'\n            f'for API \" { version } \"',\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { sys.api_version } \"', \n ) \n",
      "pred_parsed": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \" { method } \" are configured'\n            f'for API \" { sys.api_version } \"',\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { f', \n ) \n",
      "pred_parsed": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \" { method } \" are configured'\n            f'for API \" { f',\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { python_version } \"', \n ) \n",
      "pred_parsed": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \" { method } \" are configured'\n            f'for API \" { python_version } \"',\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "usnistgov/fipy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/usnistgov-fipy",
    "commit": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "filename": "examples/levelSet/advection/mesh1D.py",
    "source_code": "    exec(fipy.tests.doctestPlus._getScript())\n    raw_input(\"finished\")",
    "target_code": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `raw_input` is used but not defined in the current scope.",
    "warning_line": 81,
    "pred_top-1": {
      "pred": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n \n",
      "pred_parsed": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n",
      "pred_parsed": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n \n \n",
      "pred_parsed": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n <IND>",
      "pred_parsed": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n <DED> \n",
      "pred_parsed": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "wrye-bash/wrye-bash",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/wrye-bash-wrye-bash",
    "commit": "65bac9cf90d11d24003971cbe457a93e7138c211",
    "filename": "Mopy/bash/basher/frames.py",
    "source_code": "_BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT,_UPDATE = xrange(8)",
    "target_code": "<DED><DED>_BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT,_UPDATE = range(8)\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `xrange` is used but not defined in the current scope.",
    "warning_line": 296,
    "exception": "'pred_top-1'"
  },
  {
    "repo": "usnistgov/fipy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/usnistgov-fipy",
    "commit": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "filename": "examples/elphf/phase.py",
    "source_code": "    raw_input(\"finished\")",
    "target_code": "\n    input(\"finished\")\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `raw_input` is used but not defined in the current scope.",
    "warning_line": 181,
    "pred_top-1": {
      "pred": "\n input(\"finished\") \n \n",
      "pred_parsed": "    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n input(\"finished\") \n",
      "pred_parsed": "    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n input(\"finished\") \n \n \n",
      "pred_parsed": "    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n input(\"finished\") \n <DED> \n",
      "pred_parsed": "    input(\"finished\")\n\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n input(\"finished\") \n <IND> \n",
      "pred_parsed": "    input(\"finished\")\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "wrye-bash/wrye-bash",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/wrye-bash-wrye-bash",
    "commit": "65bac9cf90d11d24003971cbe457a93e7138c211",
    "filename": "Mopy/bash/game/oblivion/records.py",
    "source_code": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n                   (u'skills', [0 for _x in xrange(21)]), u'health',\n                   u'unused2', (u'attributes', [0 for _y in xrange(8)])),\n        MelFid(b'HNAM', 'hair'),",
    "target_code": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n                   (u'skills', [0 for _x in range(21)]), u'health',\n                   u'unused2', (u'attributes', [0 for _y in range(8)])),\n        MelFid(b'HNAM', 'hair'),\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `xrange` is used but not defined in the current scope.",
    "warning_line": 1390,
    "pred_top-1": {
      "pred": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(8)])), \n MelFid(b'HNAM', 'hair'), \n",
      "pred_parsed": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n        (u'skills', [0 for _y in range(21)]), u'health',\n        u'unused2', (u'attributes', [0 for _y in range(8)])),\n        MelFid(b'HNAM', 'hair'),\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(21)])), \n MelFid(b'HNAM', 'hair'), \n",
      "pred_parsed": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n        (u'skills', [0 for _y in range(21)]), u'health',\n        u'unused2', (u'attributes', [0 for _y in range(21)])),\n        MelFid(b'HNAM', 'hair'),\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _x in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(21)])), \n MelFid(b'HNAM', 'hair'), \n",
      "pred_parsed": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n        (u'skills', [0 for _x in range(21)]), u'health',\n        u'unused2', (u'attributes', [0 for _y in range(21)])),\n        MelFid(b'HNAM', 'hair'),\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _x in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(8)])), \n MelFid(b'HNAM', 'hair'), \n",
      "pred_parsed": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n        (u'skills', [0 for _x in range(21)]), u'health',\n        u'unused2', (u'attributes', [0 for _y in range(8)])),\n        MelFid(b'HNAM', 'hair'),\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range((8)]))), \n MelFid(b'HNAM', 'hair'), \n",
      "pred_parsed": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n        (u'skills', [0 for _y in range(21)]), u'health',\n        u'unused2', (u'attributes', [0 for _y in range((8)]))),\n        MelFid(b'HNAM', 'hair'),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "usnistgov/fipy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/usnistgov-fipy",
    "commit": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "filename": "examples/diffusion/electrostatics.py",
    "source_code": "    raw_input(\"finished\")",
    "target_code": "\n    input(\"finished\")\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `raw_input` is used but not defined in the current scope.",
    "warning_line": 181,
    "pred_top-1": {
      "pred": "\n input(\"finished\") \n \n",
      "pred_parsed": "    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n input(\"finished\") \n",
      "pred_parsed": "    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n input(\"finished\") \n \n \n",
      "pred_parsed": "    input(\"finished\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n input(\"finished\") \n <DED> \n",
      "pred_parsed": "    input(\"finished\")\n\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n input(\"finished\") \n <IND> \n",
      "pred_parsed": "    input(\"finished\")\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "daveleroy/sublime_debugger",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/daveleroy-sublime_debugger",
    "commit": "d410a39c5313babd215d70bc996303648cf639fe",
    "filename": "modules/debugger/debugger_interface.py",
    "source_code": "    else:\n\t\t\t\t\traise Error(True, \"Debugger must be run inside a sublime project\")",
    "target_code": "    <DED>else:\n\t\t\t\t\t<IND>raise core.Error(\"Debugger must be run inside a sublime project\")\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `Error` is used but not defined in the current scope.",
    "warning_line": 169,
    "exception": "'pred_top-1'"
  },
  {
    "repo": "python/mypy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy",
    "commit": "5938c9212918aadbf26300ab52c6fe7173a35da7",
    "filename": "mypy/parsetype.py",
    "source_code": "        type = self.parse_type()\n        return StarType(type, line)",
    "target_code": "        type = self.parse_type()\n        return StarType(type, star.line)\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `line` is used but not defined in the current scope.",
    "warning_line": 153,
    "pred_top-1": {
      "pred": "type = self.parse_type() \n return StarType(type, str(line)) \n \n",
      "pred_parsed": "        type = self.parse_type()\n        return StarType(type, str(line))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "type = self.parse_type() \n return StarType(type, str) \n \n",
      "pred_parsed": "        type = self.parse_type()\n        return StarType(type, str)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "type = self.parse_type() \n return StarType(type, str(type), line) \n \n",
      "pred_parsed": "        type = self.parse_type()\n        return StarType(type, str(type), line)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "type = self.parse_type() \n return StarType(type) \n \n",
      "pred_parsed": "        type = self.parse_type()\n        return StarType(type)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "type = self.parse_type() \n return StarType(type, 'line') \n \n",
      "pred_parsed": "        type = self.parse_type()\n        return StarType(type, 'line')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "NervanaSystems/ngraph-python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/NervanaSystems-ngraph-python",
    "commit": "1898ddba881de3a0b4a8132205b936609ac69a44",
    "filename": "examples/dist_hetr.py",
    "source_code": "    if args.visualize:\n        hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))",
    "target_code": "    <IND>if args.visualize:\n        <IND>hetr.register_graph_pass(ng.transformers.passes.nviz.VizPass(show_all_metadata=True))\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `ng` is used but not defined in the current scope.",
    "warning_line": 83,
    "pred_top-1": {
      "pred": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "pred_parsed": "    if args.visualize:\n        hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> if args.visualize: \n <IND> if args.visualize: \n <IND> hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "pred_parsed": "    if args.visualize:\n        if args.visualize:\n            hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(t.ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "pred_parsed": "    if args.visualize:\n        hetr.register_graph_pass(t.ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(str(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "pred_parsed": "    if args.visualize:\n        hetr.register_graph_pass(str(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(v=ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "pred_parsed": "    if args.visualize:\n        hetr.register_graph_pass(v=ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "openstack/ironic",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/openstack-ironic",
    "commit": "6aec2c18ba7abf06f24ad5c9431c6395eac41f18",
    "filename": "ironic/api/controllers/v1/chassis.py",
    "source_code": "    @wsme_pecan.wsexpose(ChassisCollection, unicode, int, unicode, unicode)\n    def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'):",
    "target_code": "\n    <DED>@wsme_pecan.wsexpose(ChassisCollection, wtypes.text,\n                         int, wtypes.text, wtypes.text)\n    def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'):\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `unicode` is used but not defined in the current scope.",
    "warning_line": 139,
    "pred_top-1": {
      "pred": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int, unicode, int) \n def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'): \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(ChassisCollection, int, unicode, int)\n    def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'):\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int) \n def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'): \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int)\n    def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int, unicode: int) \n def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'): \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int, unicode: int)\n    def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, unicode: int) \n def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'): \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(ChassisCollection, int: int, unicode: int)\n    def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int, unicode: int) \n def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'): \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int, unicode: int)\n    def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "usnistgov/fipy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/usnistgov-fipy",
    "commit": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "filename": "examples/levelSet/distanceFunction/interior.py",
    "source_code": "    viewer.plot()\n    raw_input('finished')",
    "target_code": "    viewer.plot()\n    input('finished')\n\n\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `raw_input` is used but not defined in the current scope.",
    "warning_line": 68,
    "pred_top-1": {
      "pred": "viewer.plot() \n input('finished') \n \n",
      "pred_parsed": "    viewer.plot()\n    input('finished')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "viewer.plot() \n input('finished') \n \n \n",
      "pred_parsed": "    viewer.plot()\n    input('finished')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "viewer.plot() \n input('finished') \n \n \n \n",
      "pred_parsed": "    viewer.plot()\n    input('finished')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "viewer.plot() \n input('finished') \n \n <IND> \n",
      "pred_parsed": "    viewer.plot()\n    input('finished')\n    \n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "viewer.plot() \n input('finished') \n \n <DED> \n",
      "pred_parsed": "    viewer.plot()\n    input('finished')\n    \n\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "jonrau1/ElectricEye",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/jonrau1-ElectricEye",
    "commit": "d1aef27493d0202aebb0a0ec85cf1de9afb9f625",
    "filename": "eeauditor/auditors/aws/Shodan_Auditor.py",
    "source_code": "                            \"Severity\": {\"Label\": \"INFORMATIONAL\"},\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution \"\n                            + cfId\n                            + \" has not been indexed by Shodan.\",",
    "target_code": "                            \"Severity\": {\"Label\": \"INFORMATIONAL\"},\n                            \"Title\": \"[Shodan.GlobalAccelerator.1] Accelerators should be monitored for being indexed by Shodan\",\n                            \"Description\": \"Accelerator \"\n                            + gaxName\n                            + \" has not been indexed by Shodan.\",\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `cfId` is used but not defined in the current scope.",
    "warning_line": 1280,
    "pred_top-1": {
      "pred": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + \" has not been indexed by Shodan.\", \n",
      "pred_parsed": "                            \"Severity\": { \"Label\": \"INFORMATIONAL\" },\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution\"\n                            + \" has not been indexed by Shodan.\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + cfId \n + \" has not been indexed by Shodan.\", \n",
      "pred_parsed": "                            \"Severity\": { \"Label\": \"INFORMATIONAL\" },\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution\"\n                            + cfId\n                            + \" has not been indexed by Shodan.\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\", \n + \" has not been indexed by Shodan.\", \n",
      "pred_parsed": "                            \"Severity\": { \"Label\": \"INFORMATIONAL\" },\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution\",\n                            + \" has not been indexed by Shodan.\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should not be indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + \" has not been indexed by Shodan.\", \n",
      "pred_parsed": "                            \"Severity\": { \"Label\": \"INFORMATIONAL\" },\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should not be indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution\"\n                            + \" has not been indexed by Shodan.\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + cfId <DED> \n + \" has not been indexed by Shodan.\", \n",
      "pred_parsed": "                            \"Severity\": { \"Label\": \"INFORMATIONAL\" },\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution\"\n                        + cfId\n                        + \" has not been indexed by Shodan.\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "openstack/ironic",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/openstack-ironic",
    "commit": "6aec2c18ba7abf06f24ad5c9431c6395eac41f18",
    "filename": "ironic/api/controllers/v1/port.py",
    "source_code": "    @wsme_pecan.wsexpose(PortCollection, unicode, unicode, int,\n                         unicode, unicode)\n    def get_all(self, node_id=None, marker=None, limit=None,",
    "target_code": "\n    <DED><DED>@wsme_pecan.wsexpose(PortCollection, wtypes.text, wtypes.text, int,\n                         wtypes.text, wtypes.text)\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
    "warning_type": "Unbound name [10]",
    "warning_message": " Name `unicode` is used but not defined in the current scope.",
    "warning_line": 169,
    "pred_top-1": {
      "pred": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, int, \n unicode, int) \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(PortCollection, unicode, int,\n    unicode, int)\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, unicode, int, \n unicode, int) \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(PortCollection, unicode, unicode, int,\n    unicode, int)\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(unicode), int, \n unicode, wsme_pecan.wsexpose(PortCollection, unicode)) \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(unicode), int,\n    unicode, wsme_pecan.wsexpose(PortCollection, unicode))\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(unicode), int, \n unicode, wsme_pecan.wsexpose(PortCollection, unicode, int, \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(unicode), int,\n    unicode, wsme_pecan.wsexpose(PortCollection, unicode, int,\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(Unicode, wsme_pecan.wsexpose(PortCollection), int, \n unicode, wsme_pecan.wsexpose(PortCollection), \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "pred_parsed": "    @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(Unicode, wsme_pecan.wsexpose(PortCollection), int,\n    unicode, wsme_pecan.wsexpose(PortCollection),\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "Knio/pynmea2",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Knio-pynmea2",
    "commit": "b52decfa23d8482b072e42507692533666c4151e",
    "filename": "pynmea2/types/talker.py",
    "source_code": "    fields = (\n        (\"Timestamp (UTC)\", \"timestamp\"),\n        (\"Date (DD/MM/YY\", \"date\"),",
    "target_code": "    fields = (\n        (\"Timestamp (UTC)\", \"timestamp\", timestamp),\n        (\"Date (DD/MM/YY\", \"date\"),\n",
    "warning_type": "Inconsistent override [15]",
    "warning_message": " `fields` overrides attribute defined in `pynmea2.nmea.NMEASentence` inconsistently. Type `typing.Tuple[typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str]]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
    "warning_line": 387,
    "pred_top-1": {
      "pred": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n",
      "pred_parsed": "    fields = (\n    (\"Timestamp (UTC)\", \"timestamp\"),\n    (\"Date (DD/MM/YY\", \"date\"),\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"Date (DD/MM/YY\", \"date\"), \n",
      "pred_parsed": "    fields = (\n    (\"Timestamp (UTC)\", \"timestamp\"),\n    (\"Date (DD/MM/YY\", \"date\"),\n    \"Date (DD/MM/YY\", \"date\"),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"date\"), \n",
      "pred_parsed": "    fields = (\n    (\"Timestamp (UTC)\", \"timestamp\"),\n    (\"Date (DD/MM/YY\", \"date\"),\n    \"date\"),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"date\"), \n",
      "pred_parsed": "    fields = (\n    (\"Timestamp (UTC)\", \"timestamp\"),\n    (\"Date (DD/MM/YY\", \"date\"),\n    \"date\"),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"Date (DD/MM/YY\", \"date\"), \n \"Date (DD/MM/YY\", \"date\"), \n",
      "pred_parsed": "    fields = (\n    (\"Timestamp (UTC)\", \"timestamp\"),\n    (\"Date (DD/MM/YY\", \"date\"),\n    \"Date (DD/MM/YY\", \"date\"),\n    \"Date (DD/MM/YY\", \"date\"),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "talkiq/gcloud-aio",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "auth/gcloud/aio/auth/session.py",
    "source_code": "        def close(self) -> None:\n            if self._session:",
    "target_code": "\n        <DED>async def close(self) -> None:\n            <IND>if self._session:\n",
    "warning_type": "Inconsistent override [15]",
    "warning_message": " `auth.gcloud.aio.auth.session.SyncSession.close` overrides method defined in `BaseSession` inconsistently. Returned type `None` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, None]`.",
    "warning_line": 206,
    "pred_top-1": {
      "pred": "\n <DED> def close(self) -> BaseSession: \n <IND> if self._session: \n",
      "pred_parsed": "        def close(self) -> BaseSession:\n            if self._session:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> def close(self) -> SyncSession: \n <IND> if self._session: \n",
      "pred_parsed": "        def close(self) -> SyncSession:\n            if self._session:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def close(self) -> BasicSession: \n <IND> if self._session: \n",
      "pred_parsed": "        def close(self) -> BasicSession:\n            if self._session:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def close(self) -> SyncSession(None): \n <IND> if self._session: \n",
      "pred_parsed": "        def close(self) -> SyncSession(None):\n            if self._session:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> def close(self) -> BaseSession(None): \n <IND> if self._session: \n",
      "pred_parsed": "        def close(self) -> BaseSession(None):\n            if self._session:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "aiokitchen/aiomisc",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/aiokitchen-aiomisc",
    "commit": "83c3493c88e439a1616850842664c156ef219e93",
    "filename": "aiomisc/thread_pool.py",
    "source_code": "class IteratorWrapperSeparate(IteratorWrapper):\n    @threaded_separate\n    def _run(self) -> None:\n        return self._in_thread()",
    "target_code": "<DED>class IteratorWrapperSeparate(IteratorWrapper):\n    <IND>async def _run(self) -> Any:\n        <IND>return await run_in_new_thread(self._in_thread)\n\n",
    "warning_type": "Inconsistent override [15]",
    "warning_message": " `aiomisc.thread_pool.IteratorWrapperSeparate._run` overrides method defined in `IteratorWrapper` inconsistently. Returned type `typing.Awaitable[typing.Any]` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, typing.Any]`.",
    "warning_line": 334,
    "pred_top-1": {
      "pred": "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n",
      "pred_parsed": "class IteratorWrapperSeparate(IteratorWrapper):\n    @threaded_separate\n    def _run(self) -> None:\n        return self._in_thread()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n",
      "pred_parsed": "class IteratorWrapperSeparate(IteratorWrapper):\n    @threaded_separate\n    def _run(self) -> None:\n        return self._in_thread()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n",
      "pred_parsed": "class IteratorWrapperSeparate(IteratorWrapper):\n    @threaded_separate\n    def _run(self) -> None:\n        return self._in_thread()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> str: \n <IND> return self._in_thread() \n \n",
      "pred_parsed": "class IteratorWrapperSeparate(IteratorWrapper):\n    @threaded_separate\n    def _run(self) -> str:\n        return self._in_thread()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> '': \n <IND> return self._in_thread() \n \n",
      "pred_parsed": "class IteratorWrapperSeparate(IteratorWrapper):\n    @threaded_separate\n    def _run(self) -> '':\n        return self._in_thread()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "ethereum/trinity",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ethereum-trinity",
    "commit": "ad61361109f7df88eb807a543191d491e76eed0c",
    "filename": "trinity/protocol/eth/monitors.py",
    "source_code": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    subscription_msg_types = {commands.NewBlock}",
    "target_code": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    <IND>subscription_msg_types = frozenset({commands.NewBlock})\n",
    "warning_type": "Inconsistent override [15]",
    "warning_message": " `subscription_msg_types` overrides attribute defined in `p2p.peer.PeerSubscriber` inconsistently. Type `typing.Set[typing.Type[commands.NewBlock]]` is not a subtype of the overridden attribute `typing.Set[typing.Type[p2p.protocol.Command]]`.",
    "warning_line": 6,
    "pred_top-1": {
      "pred": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n",
      "pred_parsed": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    subscription_msg_types = set( { commands.NewBlock } )\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n",
      "pred_parsed": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    subscription_msg_types = set( { commands.NewBlock } )\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } \n",
      "pred_parsed": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    subscription_msg_types = set( { commands.NewBlock }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } \n ) \n",
      "pred_parsed": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    subscription_msg_types = set( { commands.NewBlock }\n    )\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n \n",
      "pred_parsed": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    subscription_msg_types = set( { commands.NewBlock } )\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "irmen/Tale",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/irmen-Tale",
    "commit": "0a78d4a821d7da405bf5335ba3741757f0b593fe",
    "filename": "tale/cmds/normal.py",
    "source_code": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=None) -> int:\n    \"\"\"Takes stuff and returns the number of items taken\"\"\"",
    "target_code": "\n<DED><DED><DED>def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=\"\") -> int:\n    <IND>\"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " where_str is declared to have type `str` but is used as type `None`.",
    "warning_line": 450,
    "pred_top-1": {
      "pred": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "pred_parsed": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int:\n    \"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str]=None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "pred_parsed": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str]=None) -> int:\n    \"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str]= { } ) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "pred_parsed": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str]= { } ) -> int:\n    \"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <IND> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "pred_parsed": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int:\n    \"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=\"\") -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "pred_parsed": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=\"\") -> int:\n    \"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "awslabs/aws-lambda-powertools-python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/awslabs-aws-lambda-powertools-python",
    "commit": "29497d47d63b2e795c2a9d81eaca3985dfe8f071",
    "filename": "aws_lambda_powertools/utilities/validation/validator.py",
    "source_code": "    event: Dict,\n    schema: Dict = None,\n    formats: Optional[Dict] = None,",
    "target_code": "    event: Dict,\n    schema: Dict,\n    formats: Optional[Dict] = None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " schema is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "warning_line": 136,
    "pred_top-1": {
      "pred": "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n",
      "pred_parsed": "    event: Dict,\n    schema: Optional[Dict] = None,\n    formats: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "event: Dict, <DED> schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n",
      "pred_parsed": "    event: Dict,  schema: Optional[Dict] = None,\n    formats: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "event: Dict, <IND> schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n",
      "pred_parsed": "    event: Dict,  schema: Optional[Dict] = None,\n    formats: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, <IND>",
      "pred_parsed": "    event: Dict,\n    schema: Optional[Dict] = None,\n        formats: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, <DED>",
      "pred_parsed": "    event: Dict,\n    schema: Optional[Dict] = None,\nformats: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242",
    "filename": "raiden/transfer/channel.py",
    "source_code": "        locksroot = EMPTY_MERKLE_ROOT\n        nonce = 0\n        transferred_amount: TokenAmount = 0\n        locked_amount: TokenAmount = 0",
    "target_code": "        <IND>locksroot = EMPTY_MERKLE_ROOT\n        nonce = Nonce(0)\n        transferred_amount = TokenAmount(0)\n        locked_amount = TokenAmount(0)\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " locked_amount is declared to have type `TokenAmount` but is used as type `int`.",
    "warning_line": 923,
    "pred_top-1": {
      "pred": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = 0 \n locked_amount = 0 \n \n",
      "pred_parsed": "        locksroot = EMPTY_MERKLE_ROOT\n        nonce = 0\n        transferred_amount = 0\n        locked_amount = 0\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = TokenAmount() \n locked_amount = TokenAmount() \n \n",
      "pred_parsed": "        locksroot = EMPTY_MERKLE_ROOT\n        nonce = 0\n        transferred_amount = TokenAmount()\n        locked_amount = TokenAmount()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = TokenAmount0 \n locked_amount = TokenAmount0 \n \n",
      "pred_parsed": "        locksroot = EMPTY_MERKLE_ROOT\n        nonce = 0\n        transferred_amount = TokenAmount0\n        locked_amount = TokenAmount0\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = TokenAmount(0) \n locked_amount = TokenAmount(0) \n \n",
      "pred_parsed": "        locksroot = EMPTY_MERKLE_ROOT\n        nonce = 0\n        transferred_amount = TokenAmount(0)\n        locked_amount = TokenAmount(0)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = None \n transferred_amount = None \n locked_amount = None \n \n",
      "pred_parsed": "        locksroot = EMPTY_MERKLE_ROOT\n        nonce = None\n        transferred_amount = None\n        locked_amount = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "tensorflow/tfx",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-tfx",
    "commit": "3d7bb6a0ae0aa0ed6269c2e1f4d2bb3e8bee2a93",
    "filename": "tfx/components/schema_gen/component.py",
    "source_code": "  def __init__(self,\n               stats: channel.Channel,\n               name: Text = None,\n               outputs: Dict[Text, channel.Channel] = None):",
    "target_code": "  def __init__(self,\n               stats,\n               name = None,\n               outputs = None):\n    <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " name is declared to have type `str` but is used as type `None`.",
    "warning_line": 41,
    "pred_top-1": {
      "pred": "def __init__(self, \n stats: channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>",
      "pred_parsed": "  def __init__(self,\n  stats: channel.Channel,\n  name: Optional[Text] = None,\n  outputs: Optional[Dict[Text, channel.Channel]] = None):\n      \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "def __init__(self, \n stats: Channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>",
      "pred_parsed": "  def __init__(self,\n  stats: Channel.Channel,\n  name: Optional[Text] = None,\n  outputs: Optional[Dict[Text, channel.Channel]] = None):\n      \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "def __init__(self, \n stats: Optional[channel.Channel], \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>",
      "pred_parsed": "  def __init__(self,\n  stats: Optional[channel.Channel],\n  name: Optional[Text] = None,\n  outputs: Optional[Dict[Text, channel.Channel]] = None):\n      \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "def __init__(self, \n stats: channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None) -> None: \n <IND>",
      "pred_parsed": "  def __init__(self,\n  stats: channel.Channel,\n  name: Optional[Text] = None,\n  outputs: Optional[Dict[Text, channel.Channel]] = None) -> None:\n      \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "def __init__(self, \n stats: channel.Channel, \n name: str, \n outputs: Dict[Text, channel.Channel] = None): \n <IND>",
      "pred_parsed": "  def __init__(self,\n  stats: channel.Channel,\n  name: str,\n  outputs: Dict[Text, channel.Channel] = None):\n      \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "common-workflow-language/cwltool",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/common-workflow-language-cwltool",
    "commit": "6abb39915cf4fd279e8ef0fba8a9e7906cdf1878",
    "filename": "cwltool/job.py",
    "source_code": "        env_copy = {}\n        key = None  # type: Union[Text, bytes]\n        for key in env:\n            key = key.encode(\"utf-8\")\n            env_copy[key] = env[key]",
    "target_code": "        <DED>env_copy = {}\n        key = None  # type: Any\n        for key in env:\n            <IND>env_copy[key] = env[key]\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " key is declared to have type `Union[bytes, str]` but is used as type `None`.",
    "warning_line": 467,
    "pred_top-1": {
      "pred": "<DED> env_copy = { } \n key: Union[Text, bytes] \n for key in env: \n <IND> key = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "pred_parsed": "        env_copy = { }\n        key: Union[Text, bytes]\n        for key in env:\n            key = key.encode(\"utf-8\")\n            env_copy[key] = env[key]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> env_copy = { } \n key_encoded = None # type: Union[Text, bytes] \n for key in env: \n <IND> key_encoded = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "pred_parsed": "        env_copy = { }\n        key_encoded = None # type: Union[Text, bytes]\n        for key in env:\n            key_encoded = key.encode(\"utf-8\")\n            env_copy[key] = env[key]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> env_copy = { } \n key: Union[bytes, bytes] \n for key in env: \n <IND> key = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "pred_parsed": "        env_copy = { }\n        key: Union[bytes, bytes]\n        for key in env:\n            key = key.encode(\"utf-8\")\n            env_copy[key] = env[key]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> env_copy = { } \n key_bytes = Union[bytes, bytes] \n for key in env: \n <IND> key_bytes = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "pred_parsed": "        env_copy = { }\n        key_bytes = Union[bytes, bytes]\n        for key in env:\n            key_bytes = key.encode(\"utf-8\")\n            env_copy[key] = env[key]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> env_copy = { } \n key: Union[Text, bytes] \n for key in env: \n <IND> key_encoded = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "pred_parsed": "        env_copy = { }\n        key: Union[Text, bytes]\n        for key in env:\n            key_encoded = key.encode(\"utf-8\")\n            env_copy[key] = env[key]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "open-telemetry/opentelemetry-python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/open-telemetry-opentelemetry-python",
    "commit": "cfecca122c202f1dcc9361f6ab2b286c0ec17226",
    "filename": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
    "source_code": "    def end(self, end_time: int = None) -> None:",
    "target_code": "\n    def end(self, end_time: typing.Optional[int] = None) -> None:\n        <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " end_time is declared to have type `int` but is used as type `None`.",
    "warning_line": 148,
    "pred_top-1": {
      "pred": "\n def end(self, end_time: Optional[int] = None) -> None: \n <IND>",
      "pred_parsed": "    def end(self, end_time: Optional[int] = None) -> None:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n def end(self, end_time: typing.Optional[int] = None) -> None: \n <IND>",
      "pred_parsed": "    def end(self, end_time: typing.Optional[int] = None) -> None:\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n def end(self, end_time: Optional[int] = None) -> None: \n <DED>",
      "pred_parsed": "    def end(self, end_time: Optional[int] = None) -> None:\n\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n def end(self, end_time: typing.Optional[int] = None) -> None: \n <DED>",
      "pred_parsed": "    def end(self, end_time: typing.Optional[int] = None) -> None:\n\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n def end(self, end_time: Optional[int] = None) -> None: \n \n",
      "pred_parsed": "    def end(self, end_time: Optional[int] = None) -> None:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "torproject/stem",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/torproject-stem",
    "commit": "076f89dfb4fd4a156ae32fde8c78c531385162e8",
    "filename": "stem/descriptor/router_status_entry.py",
    "source_code": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = None, end_position: int = None, section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry.RouterStatusEntry']:",
    "target_code": "\ndef _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: Optional[int] = None, end_position: Optional[int] = None, section_end_keywords: Tuple[str, ...] = (), extra_args: Sequence[Any] = ()) -> Iterator['stem.descriptor.router_status_entry.RouterStatusEntry']:\n  <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " start_position is declared to have type `int` but is used as type `None`.",
    "warning_line": 49,
    "pred_top-1": {
      "pred": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = '', end_position: int = '', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "pred_parsed": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = '', end_position: int = '', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = '0', end_position: int = '0', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "pred_parsed": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = '0', end_position: int = '0', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = 0 \n end_position: int = 0 \n section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "pred_parsed": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = 0\nend_position: int = 0\nsection_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = -1, end_position: int = -1, section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "pred_parsed": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = -1, end_position: int = -1, section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int, end_position: int = '', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status",
      "pred_parsed": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int, end_position: int = '', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "awslabs/aws-lambda-powertools-python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/awslabs-aws-lambda-powertools-python",
    "commit": "5b87bb195fb154d2a112364a5d1d5c9513898e55",
    "filename": "aws_lambda_powertools/logging/logger.py",
    "source_code": "def set_package_logger(\n    level: Union[str, int] = logging.DEBUG, stream: IO[str] = None, formatter: logging.Formatter = None\n):",
    "target_code": "<DED><DED>def set_package_logger(\n    level: Union[str, int] = logging.DEBUG,\n    stream: Optional[IO[str]] = None,\n    formatter: Optional[logging.Formatter] = None,\n):\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " stream is declared to have type `IO[str]` but is used as type `None`.",
    "warning_line": 424,
    "pred_top-1": {
      "pred": "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "pred_parsed": "def set_package_logger(\nlevel: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None\n):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: IO[str] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "pred_parsed": "def set_package_logger(\nlevel: Union[str, int] = logging.DEBUG, stream: IO[str] = None, formatter: Optional[logging.Formatter] = None\n):\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "pred_parsed": "def set_package_logger(\nlevel: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None\n):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<IND> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "pred_parsed": "def set_package_logger(\nlevel: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None\n):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: IO[str] = 0 \n ): \n",
      "pred_parsed": "def set_package_logger(\nlevel: Union[str, int] = logging.DEBUG, stream: IO[str] = 0\n):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "ehForwarderBot/efb-telegram-master",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ehForwarderBot-efb-telegram-master",
    "commit": "437a9d58539e033a25a46e7c415a69ce29d99348",
    "filename": "efb_telegram_master/commands.py",
    "source_code": "    def extra_usage(self, bot, update, groupdict: Dict[str, str] = None):\n        if int(groupdict['id']) >= len(self.modules_list):",
    "target_code": "\n    <DED>def extra_usage(self, bot, update, groupdict: Dict[str, str]):\n        <IND>if int(groupdict['id']) >= len(self.modules_list):\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " groupdict is declared to have type `Dict[str, str]` but is used as type `None`.",
    "warning_line": 162,
    "pred_top-1": {
      "pred": "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "pred_parsed": "    def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None:\n        if int(groupdict['id']) >= len(self.modules_list):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None): \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "pred_parsed": "    def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None):\n        if int(groupdict['id']) >= len(self.modules_list):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <IND> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "pred_parsed": "    def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None:\n        if int(groupdict['id']) >= len(self.modules_list):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def extra_usage(self, bot, update, groupdict: Dict[str, str]): \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "pred_parsed": "    def extra_usage(self, bot, update, groupdict: Dict[str, str]):\n        if int(groupdict['id']) >= len(self.modules_list):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> bool: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "pred_parsed": "    def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> bool:\n        if int(groupdict['id']) >= len(self.modules_list):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "python/mypy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy",
    "commit": "c6c201c391fba5a2322561e1126ce4c7395b0bd7",
    "filename": "test-data/stdlib-samples/3.2/subprocess.py",
    "source_code": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n            # This method is called (indirectly) by __del__, so it cannot",
    "target_code": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], int] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], int] = os.WEXITSTATUS) -> None:\n            # This method is called (indirectly) by __del__, so it cannot\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " _WEXITSTATUS is declared to have type `typing.Callable[[int], bool]` but is used as type `typing.Callable(os.WEXITSTATUS)[[Named(status, int)], int]`.",
    "warning_line": 1408,
    "pred_top-1": {
      "pred": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n",
      "pred_parsed": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED, \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n",
      "pred_parsed": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n # This method is called (indirectly)",
      "pred_parsed": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n                # This method is called (indirectly)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED, \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n # This method is called (indirectly)",
      "pred_parsed": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n                # This method is called (indirectly)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED, \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n # This method is called",
      "pred_parsed": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n                # This method is called\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "vaaaaanquish/cloudia",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/vaaaaanquish-cloudia",
    "commit": "795b15cc64c7687cb2c221ee0e40e2121e4baf8a",
    "filename": "cloudia/word_data.py",
    "source_code": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        c = c.most_common()\n        _max_count = c[0][1]\n        weight = {k: v / _max_count for k, v in c}\n        weight = {k: weight[k] for k in list(weight.keys())}",
    "target_code": "    <DED>def convert_weight(self, c: Counter) -> Dict[str, float]:\n        <IND>most_common = c.most_common()\n        _max_count = most_common[0][1]\n        weight = {k: v / _max_count for k, v in most_common}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " c is declared to have type `Counter[typing.Any]` but is used as type `List[Tuple[typing.Any, int]]`.",
    "warning_line": 29,
    "pred_top-1": {
      "pred": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "pred_parsed": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        c.most_common()\n        _max_count = c[0][1]\n        weight = { k: v / _max_count for k, v in c }\n        weight = { k: weight[k] for k in list(weight.keys()) }\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c = c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "pred_parsed": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        c = c.most_common()\n        _max_count = c[0][1]\n        weight = { k: v / _max_count for k, v in c }\n        weight = { k: weight[k] for k in list(weight.keys()) }\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> return c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "pred_parsed": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        return c.most_common()\n        _max_count = c[0][1]\n        weight = { k: v / _max_count for k, v in c }\n        weight = { k: weight[k] for k in list(weight.keys()) }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common() \n _max_count = c.most_common() \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "pred_parsed": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        c.most_common()\n        _max_count = c.most_common()\n        weight = { k: v / _max_count for k, v in c }\n        weight = { k: weight[k] for k in list(weight.keys()) }\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common = c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "pred_parsed": "    def convert_weight(self, c: Counter) -> Dict[str, float]:\n        c.most_common = c.most_common()\n        _max_count = c[0][1]\n        weight = { k: v / _max_count for k, v in c }\n        weight = { k: weight[k] for k in list(weight.keys()) }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "AlexandreDecan/sismic",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/AlexandreDecan-sismic",
    "commit": "ffb6ef590d7d7e0679ff8a753d6836805fb76122",
    "filename": "sismic/interpreter.py",
    "source_code": "    def __init__(self, statechart: model.Statechart, *,\n                 evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator,\n                 initial_context: Mapping=None,",
    "target_code": "    def __init__(self, statechart: model.Statechart, *,\n                 evaluator_klass: Callable[['Interpreter'], Evaluator]=PythonEvaluator,\n                 initial_context: Mapping=None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " evaluator_klass is declared to have type `typing.Callable[[Interpreter, Mapping[typing.Any, typing.Any]], sismic.code.evaluator.Evaluator]` but is used as type `typing.Type[sismic.code.python.PythonEvaluator]`.",
    "warning_line": 29,
    "pred_top-1": {
      "pred": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator, \n initial_context: Mapping=None, \n",
      "pred_parsed": "    def __init__(self, statechart: model.Statechart, *,\n    evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator,\n    initial_context: Mapping=None,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=Evaluator, \n initial_context: Mapping=None, \n",
      "pred_parsed": "    def __init__(self, statechart: model.Statechart, *,\n    evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=Evaluator,\n    initial_context: Mapping=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Optional[Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator, \n initial_context: Mapping=None, \n",
      "pred_parsed": "    def __init__(self, statechart: model.Statechart, *,\n    evaluator_klass: Optional[Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator,\n    initial_context: Mapping=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: PythonEvaluator, \n initial_context: Mapping=None, \n",
      "pred_parsed": "    def __init__(self, statechart: model.Statechart, *,\n    evaluator_klass: PythonEvaluator,\n    initial_context: Mapping=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Optional[PythonEvaluator] = PythonEvaluator, \n initial_context: Mapping=None, \n",
      "pred_parsed": "    def __init__(self, statechart: model.Statechart, *,\n    evaluator_klass: Optional[PythonEvaluator] = PythonEvaluator,\n    initial_context: Mapping=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "karlch/vimiv-qt",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/karlch-vimiv-qt",
    "commit": "4ce84989a3b7460ee03fb4d41a08b5d9a2d4ccc0",
    "filename": "vimiv/config/configcommands.py",
    "source_code": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command = \" \".join(command)\n    api.keybindings.bind(keybinding, command, modeobj)",
    "target_code": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    api.keybindings.bind(keybinding, \" \".join(command), modeobj)\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " command is declared to have type `List[str]` but is used as type `str`.",
    "warning_line": 67,
    "pred_top-1": {
      "pred": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command = \" \".join(command) \n api.keybindings.bind(keybinding, command, modeobj) \n \n",
      "pred_parsed": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command = \" \".join(command)\n    api.keybindings.bind(keybinding, command, modeobj)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command_name = \" \".join(command) \n api.keybindings.bind(keybinding, command_name, modeobj) \n \n",
      "pred_parsed": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command_name = \" \".join(command)\n    api.keybindings.bind(keybinding, command_name, modeobj)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command_ = \" \".join(command) \n api.keybindings.bind(keybinding, command_, modeobj) \n \n",
      "pred_parsed": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command_ = \" \".join(command)\n    api.keybindings.bind(keybinding, command_, modeobj)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command__ = \" \".join(command) \n api.keybindings.bind(keybinding, command__, modeobj) \n \n",
      "pred_parsed": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command__ = \" \".join(command)\n    api.keybindings.bind(keybinding, command__, modeobj)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command = \" \".join(command) \n keybindings.bind(keybinding, command, modeobj) \n \n",
      "pred_parsed": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command = \" \".join(command)\n    keybindings.bind(keybinding, command, modeobj)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "pygae/galgebra",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/pygae-galgebra",
    "commit": "ceacd273cdb095122678af6b1239f2b7b18cd9f4",
    "filename": "galgebra/printer.py",
    "source_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord",
    "target_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord_list = op_ord.split(',')\n    _parser.validate_op_order(op_ord_list)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord_list\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " op_ord is declared to have type `str` but is used as type `typing.List[str]`.",
    "warning_line": 1204,
    "pred_top-1": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord.split(',') \n _parser.validate_op_order(op_ord.split(',')) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord.split(',')\n    _parser.validate_op_order(op_ord.split(','))\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord_split = op_ord.split(',') \n _parser.validate_op_order(op_ord_split) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord_split = op_ord.split(',')\n    _parser.validate_op_order(op_ord_split)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "openlawlibrary/pygls",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/openlawlibrary-pygls",
    "commit": "866698899d9d082b1929d0e3a80564f01f8f905b",
    "filename": "pygls/types/language_features/completion.py",
    "source_code": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False):\n        self.snippetSupport = snippet_support",
    "target_code": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = None):\n        <IND>self.snippetSupport = snippet_support\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " tag_support is declared to have type `Optional[CompletionTagSupportClientCapabilities]` but is used as type `bool`.",
    "warning_line": 65,
    "pred_top-1": {
      "pred": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False): \n <IND> self.snippetSupport = snippet_support \n",
      "pred_parsed": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False):\n                     self.snippetSupport = snippet_support\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False) -> None: \n <IND> self.snippetSupport = snippet_support \n",
      "pred_parsed": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False) -> None:\n                     self.snippetSupport = snippet_support\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False): \n <DED> self.snippetSupport = snippet_support \n",
      "pred_parsed": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False):\n             self.snippetSupport = snippet_support\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False) \n <IND> self.snippetSupport = snippet_support \n",
      "pred_parsed": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False)\n                     self.snippetSupport = snippet_support\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "preselected_support: Optional[bool] = False, \n tag_support: bool = False): \n <IND> self.snippetSupport = snippet_support \n",
      "pred_parsed": "                 preselected_support: Optional[bool] = False,\n                 tag_support: bool = False):\n                     self.snippetSupport = snippet_support\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "algoo/preview-generator",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/algoo-preview-generator",
    "commit": "09895c027a8c7c20318d2820caf0c40083f32ce8",
    "filename": "preview_generator/preview/builder/cad__vtk.py",
    "source_code": "        if not mimetype:\n            mimetype, _ = mimetypes_storage.guess_type(file_path, strict=False)\n        reader = self._get_vtk_reader(mimetype)",
    "target_code": "        if not mimetype:\n            <IND>guessed_mimetype, _ = mimetypes_storage.guess_type(file_path, strict=False)\n            # INFO - G.M - 2019-11-22 - guessed_mimetype can be None\n            mimetype = guessed_mimetype or \"\"\n        <DED>reader = self._get_vtk_reader(mimetype)\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " mimetype is declared to have type `str` but is used as type `typing.Optional[str]`.",
    "warning_line": 100,
    "pred_top-1": {
      "pred": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=False) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "pred_parsed": "        if not mimetype:\n            mimetype, _ = mimetypes_storage.guess_type(file_path, str=False)\n        reader = self._get_vtk_reader(mimetype)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str(str)) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "pred_parsed": "        if not mimetype:\n            mimetype, _ = mimetypes_storage.guess_type(file_path, str(str))\n        reader = self._get_vtk_reader(mimetype)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "if not mimetype: \n <IND> mimetype = mimetypes_storage.guess_type(file_path, str(str)) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "pred_parsed": "        if not mimetype:\n            mimetype = mimetypes_storage.guess_type(file_path, str(str))\n        reader = self._get_vtk_reader(mimetype)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=false) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "pred_parsed": "        if not mimetype:\n            mimetype, _ = mimetypes_storage.guess_type(file_path, str=false)\n        reader = self._get_vtk_reader(mimetype)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=False) \n <IND> reader = self._get_vtk_reader(mimetype) \n",
      "pred_parsed": "        if not mimetype:\n            mimetype, _ = mimetypes_storage.guess_type(file_path, str=False)\n                reader = self._get_vtk_reader(mimetype)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "jesopo/bitbot",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot",
    "commit": "577fae7ceabfd2a43b798e02a67c518c23ed33bd",
    "filename": "src/utils/irc/protocol.py",
    "source_code": "def message(target: str, message: str, tags: dict=None\n        ) -> 'utils.irc.IRCParsedLine':\n    return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\ndef notice(target: str, message: str, tags: dict=None\n        ) -> 'utils.irc.IRCParsedLine':",
    "target_code": "\n<DED>def message(target: str, message: str, tags: typing.Dict[str, str]={}\n        ) -> 'utils.irc.IRCParsedLine':\n    <IND>return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\n<DED>def notice(target: str, message: str, tags: typing.Dict[str, str]={}\n        ) -> 'utils.irc.IRCParsedLine':\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "warning_line": 36,
    "pred_top-1": {
      "pred": "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine",
      "pred_parsed": "def message(target: str, message: str, tags: typing.Dict[str, str]= { }\n) -> 'utils.irc.IRCParsedLine':\n    return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\ndef notice(target: str, message: str, tags: typing.Dict[str, str]= { }\n) -> 'utils.irc.IRCParsedLine\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.",
      "pred_parsed": "def message(target: str, message: str, tags: typing.Dict[str, str]= { }\n) -> 'utils.irc.IRCParsedLine':\n    return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\ndef notice(target: str, message: str, tags: typing.Dict[str, str]= { }\n) -> 'utils.irc.\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def message(target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Optional[typing.Dict[str]= { \n ) -> 'utils.irc.",
      "pred_parsed": "def message(target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { }\n) -> 'utils.irc.IRCParsedLine':\n    return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\ndef notice(target: str, message: str, tags: typing.Optional[typing.Dict[str]= {\n) -> 'utils.irc.\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <IND> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine",
      "pred_parsed": "def message(target: str, message: str, tags: typing.Dict[str, str]= { }\n) -> 'utils.irc.IRCParsedLine':\n    return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\n        def notice(target: str, message: str, tags: typing.Dict[str, str]= { }\n        ) -> 'utils.irc.IRCParsedLine\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> def message(target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Optional[typing.Dict[str]= { \n ) -> 'utils.ir",
      "pred_parsed": "def message(target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { }\n) -> 'utils.irc.IRCParsedLine':\n    return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\ndef notice(target: str, message: str, tags: typing.Optional[typing.Dict[str]= {\n) -> 'utils.ir\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "googleapis/python-bigquery",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/googleapis-python-bigquery",
    "commit": "66b3dd9f9aec3fda9610a3ceec8d8a477f2ab3b9",
    "filename": "google/cloud/bigquery/job/query.py",
    "source_code": "    def statement_timeout_ms(self, value: Union[int, None]):\n        if value is not None:\n            value = str(value)\n        self._properties[\"statementTimeoutMs\"] = value",
    "target_code": "    def statement_timeout_ms(self, value: Union[int, None]):\n        <IND>new_value = None if value is None else str(value)\n        self._properties[\"statementTimeoutMs\"] = new_value\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " value is declared to have type `Optional[int]` but is used as type `str`.",
    "warning_line": 197,
    "pred_top-1": {
      "pred": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = str(value) \n \n",
      "pred_parsed": "    def statement_timeout_ms(self, value: Union[int, None]):\n        if value is None else str(value)\n        self._properties[\"statementTimeoutMs\"] = str(value)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = value \n \n",
      "pred_parsed": "    def statement_timeout_ms(self, value: Union[int, None]):\n        if value is None else str(value)\n        self._properties[\"statementTimeoutMs\"] = value\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = str \n \n",
      "pred_parsed": "    def statement_timeout_ms(self, value: Union[int, None]):\n        if value is None else str(value)\n        self._properties[\"statementTimeoutMs\"] = str\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n <DED> self._properties[\"statementTimeoutMs\"] = str(value) \n \n",
      "pred_parsed": "    def statement_timeout_ms(self, value: Union[int, None]):\n        if value is None else str(value)\n    self._properties[\"statementTimeoutMs\"] = str(value)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n <DED> self._properties[\"statementTimeoutMs\"] = value \n \n",
      "pred_parsed": "    def statement_timeout_ms(self, value: Union[int, None]):\n        if value is None else str(value)\n    self._properties[\"statementTimeoutMs\"] = value\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "theislab/squidpy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/theislab-squidpy",
    "commit": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "filename": "squidpy/im/crop.py",
    "source_code": "    y: int,\n    channel_id: str = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?",
    "target_code": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " channel_id is declared to have type `str` but is used as type `None`.",
    "warning_line": 80,
    "pred_top-1": {
      "pred": "y: int, \n channel_id: Optional[str] = None, \n xs: Optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "pred_parsed": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: Optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified?\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "y: int, \n channel_id: Optional[str] = None, \n xs: int = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "pred_parsed": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: int = 100, # TODO: are these defaults reasonable or should no defaults be specified?\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "y: int, \n channel_id: Optional[str] = None, \n xs: optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "pred_parsed": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified?\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "y: int, \n channel_id: Optional[str] = None, \n xs: int = 100, \n # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "pred_parsed": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: int = 100,\n    # TODO: are these defaults reasonable or should no defaults be specified?\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "y: int, \n channel_id: str, \n xs: int = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "pred_parsed": "    y: int,\n    channel_id: str,\n    xs: int = 100, # TODO: are these defaults reasonable or should no defaults be specified?\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "mlflow/mlflow",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/mlflow-mlflow",
    "commit": "d1a2647a4d265f290261ab91db44125422ee57ab",
    "filename": "mlflow/models/model.py",
    "source_code": "        flavors=None,\n        signature: ModelSignature = None,\n        saved_input_example_info: Dict[str, Any] = None,",
    "target_code": "        flavors=None,\n        signature=None,  # ModelSignature\n        saved_input_example_info: Dict[str, Any] = None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " signature is declared to have type `ModelSignature` but is used as type `None`.",
    "warning_line": 34,
    "pred_top-1": {
      "pred": "flavors=None, \n signature: Optional[ModelSignature] = None, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n",
      "pred_parsed": "        flavors=None,\n        signature: Optional[ModelSignature] = None,\n        saved_input_example_info: Optional[Dict[str, Any]] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "flavors=None, \n signature: ModelSignature, \n saved_input_example_info: Dict[str, Any] = None, \n",
      "pred_parsed": "        flavors=None,\n        signature: ModelSignature,\n        saved_input_example_info: Dict[str, Any] = None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "flavors=None, \n signature: Optional[ModelSignature] = None, \n saved_input_example_info: Dict[str, Any] = None, \n",
      "pred_parsed": "        flavors=None,\n        signature: Optional[ModelSignature] = None,\n        saved_input_example_info: Dict[str, Any] = None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "flavors=None, \n signatures: Optional[ModelSignature] = None, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n",
      "pred_parsed": "        flavors=None,\n        signatures: Optional[ModelSignature] = None,\n        saved_input_example_info: Optional[Dict[str, Any]] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "flavors=None, \n signature: ModelSignature, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n",
      "pred_parsed": "        flavors=None,\n        signature: ModelSignature,\n        saved_input_example_info: Optional[Dict[str, Any]] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "persephone-tools/persephone",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/persephone-tools-persephone",
    "commit": "e0567f8f99719ca7091b55a5258ee9d844d742cf",
    "filename": "persephone/corpus.py",
    "source_code": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: LabelSegmenter = None,\n                  speakers: List[str] = None, lazy: bool = True,",
    "target_code": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: Optional[LabelSegmenter] = None,\n                  speakers: List[str] = None, lazy: bool = True,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " label_segmenter is declared to have type `LabelSegmenter` but is used as type `None`.",
    "warning_line": 238,
    "pred_top-1": {
      "pred": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: Optional[LabelSegmenter] = None, \n speakers: Optional[List[str]] = None, lazy: bool = True, \n",
      "pred_parsed": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: Optional[LabelSegmenter] = None,\n                  speakers: Optional[List[str]] = None, lazy: bool = True,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: LabelSegmenter, \n speakers: List[str] = None, lazy: bool = True, \n",
      "pred_parsed": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: LabelSegmenter,\n                  speakers: List[str] = None, lazy: bool = True,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: LabelSegmenter = \"\", \n speakers: List[str] = None, lazy: bool = True, \n",
      "pred_parsed": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: LabelSegmenter = \"\",\n                  speakers: List[str] = None, lazy: bool = True,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter=LabelSegmenter, \n speakers: List[str] = None, lazy: bool = True, \n",
      "pred_parsed": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter=LabelSegmenter,\n                  speakers: List[str] = None, lazy: bool = True,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: Optional[LabelSegmenter] = None, \n speakers: Optional[List[str]] = None, lazy: bool = True, <IND>",
      "pred_parsed": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: Optional[LabelSegmenter] = None,\n                      speakers: Optional[List[str]] = None, lazy: bool = True,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "osmocom/pysim",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/osmocom-pysim",
    "commit": "1e45657e0f177388379f37e8557ac1cfdbac32a5",
    "filename": "pySim/filesystem.py",
    "source_code": "    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n                 parent:Optional[CardDF]=None, rec_len:int=None, size={1,None}):",
    "target_code": "\n    def __init__(self, fid:str, rec_len:int, sfid:str=None, name:str=None, desc:str=None,\n                 parent:Optional[CardDF]=None, size={1,None}):\n        <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " rec_len is declared to have type `int` but is used as type `None`.",
    "warning_line": 687,
    "pred_top-1": {
      "pred": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent: Optional[CardDF]=None, rec_len: Optional[int]=None, size= { 1,None } ): \n <IND>",
      "pred_parsed": "    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n    parent: Optional[CardDF]=None, rec_len: Optional[int]=None, size= { 1,None } ):\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent:Optional[CardDF]=None, rec_len:int=None, size= { 1,None } ): \n <IND>",
      "pred_parsed": "    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n    parent:Optional[CardDF]=None, rec_len:int=None, size= { 1,None } ):\n        \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent=None, rec_len=None, size= { 1,None } ): \n <IND>",
      "pred_parsed": "    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n    parent=None, rec_len=None, size= { 1,None } ):\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent=Optional[CardDF]=None, rec_len:int=None, size= { 1,None } ): \n <IND>",
      "pred_parsed": "    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n    parent=Optional[CardDF]=None, rec_len:int=None, size= { 1,None } ):\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent=None, rec_len:int=None, size= { 1,None } ): \n <IND>",
      "pred_parsed": "    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n    parent=None, rec_len:int=None, size= { 1,None } ):\n        \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "rytilahti/python-miio",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/rytilahti-python-miio",
    "commit": "6453bfee512150e3f062670e890533fcd67067ea",
    "filename": "miio/gateway/devices/subdevice.py",
    "source_code": "        self,\n        gw: \"Gateway\" = None,\n        dev_info: SubDeviceInfo = None,\n        model_info: Optional[Dict] = None,",
    "target_code": "        self,\n        gw: \"Gateway\",\n        dev_info: SubDeviceInfo,\n        model_info: Optional[Dict] = None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " dev_info is declared to have type `SubDeviceInfo` but is used as type `None`.",
    "warning_line": 35,
    "pred_top-1": {
      "pred": "self, \n gw: Optional[\"Gateway\"] = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "pred_parsed": "        self,\n        gw: Optional[\"Gateway\"] = None,\n        dev_info: Optional[SubDeviceInfo] = None,\n        model_info: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "self, \n gw: \"Gateway\", \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "pred_parsed": "        self,\n        gw: \"Gateway\",\n        dev_info: Optional[SubDeviceInfo] = None,\n        model_info: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "self, \n gw: \"Gateway\" = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "pred_parsed": "        self,\n        gw: \"Gateway\" = None,\n        dev_info: Optional[SubDeviceInfo] = None,\n        model_info: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "self, \n gw: Optional[\"Gateway\") = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "pred_parsed": "        self,\n        gw: Optional[\"Gateway\") = None,\n        dev_info: Optional[SubDeviceInfo] = None,\n        model_info: Optional[Dict] = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "self, \n gw: \"Gateway\", \n dev_info: SubDeviceInfo, \n model_info: Optional[Dict] = None, \n",
      "pred_parsed": "        self,\n        gw: \"Gateway\",\n        dev_info: SubDeviceInfo,\n        model_info: Optional[Dict] = None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "gateio/gateapi-python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/gateio-gateapi-python",
    "commit": "42ffacad340a2a27583abe48b1f68cf043bbdd3d",
    "filename": "gate_api/models/spot_price_put_order.py",
    "source_code": "        amount=None,\n        account=None,\n        time_in_force=None,\n        local_vars_configuration=None,",
    "target_code": "        amount=None,\n        account='normal',\n        time_in_force='gtc',\n        local_vars_configuration=None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " account is declared to have type `str` but is used as type `None`.",
    "warning_line": 59,
    "pred_top-1": {
      "pred": "amount=None, \n account_in_force=None, \n local_vars_configuration=None, \n",
      "pred_parsed": "        amount=None,\n        account_in_force=None,\n        local_vars_configuration=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "amount=None, \n time_in_force=None, \n local_vars_configuration=None, \n",
      "pred_parsed": "        amount=None,\n        time_in_force=None,\n        local_vars_configuration=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "amount=None, \n account_id=None, \n time_in_force=None, \n local_vars_configuration=None, \n",
      "pred_parsed": "        amount=None,\n        account_id=None,\n        time_in_force=None,\n        local_vars_configuration=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "amount=None, \n account=str(None), \n time_in_force=None, \n local_vars_configuration=None, \n",
      "pred_parsed": "        amount=None,\n        account=str(None),\n        time_in_force=None,\n        local_vars_configuration=None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "amount=None, \n account=str, \n time_in_force=None, \n local_vars_configuration=None, \n",
      "pred_parsed": "        amount=None,\n        account=str,\n        time_in_force=None,\n        local_vars_configuration=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "theacodes/nox",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/theacodes-nox",
    "commit": "4ea20511bb6362bd4dd7a35e7943e9c1f67b2d62",
    "filename": "nox/virtualenv.py",
    "source_code": "    def __init__(self, bin_paths: None = None, env: Mapping[str, str] = None) -> None:\n        self._bin_paths = bin_paths",
    "target_code": "\n    def __init__(\n        self, bin_paths: None = None, env: Optional[Mapping[str, str]] = None\n    ) -> None:\n        <IND>self._bin_paths = bin_paths\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " env is declared to have type `Mapping[str, str]` but is used as type `None`.",
    "warning_line": 56,
    "pred_top-1": {
      "pred": "\n def __init__(self, bin_paths: Optional[None] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "pred_parsed": "    def __init__(self, bin_paths: Optional[None] = None, env: Optional[Mapping[str, str]] = None) -> None:\n        self._bin_paths = bin_paths\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "pred_parsed": "    def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None:\n        self._bin_paths = bin_paths\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "pred_parsed": "    def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None:\n        self._bin_paths = bin_paths\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "pred_parsed": "    def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None:\n        self._bin_paths = bin_paths\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n def __init__(self, bin_paths: None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "pred_parsed": "    def __init__(self, bin_paths: None, env: Optional[Mapping[str, str]] = None) -> None:\n        self._bin_paths = bin_paths\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "hikari-py/hikari",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari",
    "commit": "3891970b5751f1ca98710447199236a3867a9703",
    "filename": "hikari/net/gateway.py",
    "source_code": "        initial_presence=None,\n        intents: type_hints.NotRequired[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,",
    "target_code": "        initial_presence=None,\n        intents: type_hints.Nullable[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=250,\n        proxy_auth=None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " intents is declared to have type `typing.Union[GatewayIntent, hikari.internal_utilities.unspecified.Unspecified]` but is used as type `None`.",
    "warning_line": 210,
    "pred_top-1": {
      "pred": "initial_presence=None, \n intents: typing.Optional[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "pred_parsed": "        initial_presence=None,\n        intents: typing.Optional[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "initial_presence=None, \n intents: typing.Optional[type_hints.NotRequired[GatewayIntent]] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "pred_parsed": "        initial_presence=None,\n        intents: typing.Optional[type_hints.NotRequired[GatewayIntent]] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "initial_presence=None, \n intents: type_hints.NotRequired[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "pred_parsed": "        initial_presence=None,\n        intents: type_hints.NotRequired[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "initial_presence=None, \n intents=type_hints.NotRequired[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "pred_parsed": "        initial_presence=None,\n        intents=type_hints.NotRequired[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "initial_presence=None, \n intents: typing.Optional[Type_hints.NotRequired[GatewayIntent]] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "pred_parsed": "        initial_presence=None,\n        intents: typing.Optional[Type_hints.NotRequired[GatewayIntent]] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "PyFilesystem/pyfilesystem2",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2",
    "commit": "ed8af089c52b3100f3c07f1ca9cc73ad0160b14f",
    "filename": "fs/move.py",
    "source_code": "def move_fs(src_fs, dst_fs, workers=0):\n    # type: (Union[Text, FS], Union[Text, FS]) -> None",
    "target_code": "<DED>def move_fs(src_fs, dst_fs, workers=0):\n    # type: (Union[Text, FS], Union[Text, FS], int) -> None\n    <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " workers is declared to have type `Union[FS, str]` but is used as type `int`.",
    "warning_line": 18,
    "pred_top-1": {
      "pred": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (FS, FS) -> None \n <IND>",
      "pred_parsed": "def move_fs(src_fs, dst_fs, workers=0):\n# type: (FS, FS) -> None\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (Union[Text, FS], Union[Text, FS]) -> None \n <IND>",
      "pred_parsed": "def move_fs(src_fs, dst_fs, workers=0):\n# type: (Union[Text, FS], Union[Text, FS]) -> None\n    \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> def move_fs(src_fs, dst_fs, union=0): \n # type: (Union[Text, FS], Union[Text, FS]) -> None \n <IND>",
      "pred_parsed": "def move_fs(src_fs, dst_fs, union=0):\n# type: (Union[Text, FS], Union[Text, FS]) -> None\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (Union[FS], Union[FS]) -> None \n <IND>",
      "pred_parsed": "def move_fs(src_fs, dst_fs, workers=0):\n# type: (Union[FS], Union[FS]) -> None\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (FS, FS) -> None \n \n",
      "pred_parsed": "def move_fs(src_fs, dst_fs, workers=0):\n# type: (FS, FS) -> None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "deepmipt/DeepPavlov",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/deepmipt-DeepPavlov",
    "commit": "0f32759c67ea961737a6538fd37426f564bae925",
    "filename": "deeppavlov/utils/ms_bot_framework/server.py",
    "source_code": "                                https: bool = False,\n                                ssl_key: str = None,\n                                ssl_cert: str = None):",
    "target_code": "                                https: bool = False,\n                                ssl_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None) -> None:\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " ssl_key is declared to have type `str` but is used as type `None`.",
    "warning_line": 68,
    "pred_top-1": {
      "pred": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n \n",
      "pred_parsed": "                                https: bool = False,\n                                ssl_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None) -> None: \n \n",
      "pred_parsed": "                                https: bool = False,\n                                ssl_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None) -> None:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n <IND>",
      "pred_parsed": "                                https: bool = False,\n                                ssl_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None):\n                                    \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "https: bool = False, \n str_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n \n",
      "pred_parsed": "                                https: bool = False,\n                                str_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n <DED>",
      "pred_parsed": "                                https: bool = False,\n                                ssl_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None):\n                            \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "fa631411cdd181edf375f603d1ecec3d025f1c82",
    "filename": "raiden/transfer/mediated_transfer/events.py",
    "source_code": "# global queue\nCHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0",
    "target_code": "# global queue\nCHANNEL_IDENTIFIER_GLOBAL_QUEUE = typing.ChannelID(0)\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " CHANNEL_IDENTIFIER_GLOBAL_QUEUE is declared to have type `typing.ChannelID` but is used as type `int`.",
    "warning_line": 14,
    "pred_top-1": {
      "pred": "# global queue \n CHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0 \n \n",
      "pred_parsed": "# global queue\nCHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "# global queue \n CHANNEL_IDENTIFIER_CHANNEL_INTERNAL_QUEUE: typing.Int = 0 \n \n",
      "pred_parsed": "# global queue\nCHANNEL_IDENTIFIER_CHANNEL_INTERNAL_QUEUE: typing.Int = 0\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "# global queue \n CHANNEL_IDENTIFIER_CHANNEL_QUEUE: typing.ChannelID = 0 \n \n",
      "pred_parsed": "# global queue\nCHANNEL_IDENTIFIER_CHANNEL_QUEUE: typing.ChannelID = 0\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "# global queue \n CHANNEL_IDENTIFIER_INTERNAL_QUEUE: typing.Int = 0 \n \n",
      "pred_parsed": "# global queue\nCHANNEL_IDENTIFIER_INTERNAL_QUEUE: typing.Int = 0\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "# global queue \n CHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0, \n \n",
      "pred_parsed": "# global queue\nCHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "ClearcodeHQ/pytest-postgresql",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ClearcodeHQ-pytest-postgresql",
    "commit": "0a12849075a281010183becd1bbcce3b537a476f",
    "filename": "src/pytest_postgresql/janitor.py",
    "source_code": "        _loader: Callable = None\n        if isinstance(load, str):\n            if \"/\" in load:\n                _loader = partial(loader, load)\n            else:",
    "target_code": "\n        if isinstance(load, str):\n            <IND>if \"/\" in load:\n                <IND>_loader: Callable = partial(loader, load)\n            <DED>else:\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " _loader is declared to have type `typing.Callable[..., typing.Any]` but is used as type `None`.",
    "warning_line": 113,
    "pred_top-1": {
      "pred": "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n",
      "pred_parsed": "        _loader: Callable = []\n        if isinstance(load, str):\n            if \"/\" in load:\n                _loader = partial(loader, load)\n            else:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n _loader: Callable = None \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n",
      "pred_parsed": "        _loader: Callable = None\n        if isinstance(load, str):\n            if \"/\" in load:\n                _loader = partial(loader, load)\n            else:\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <IND> else: \n",
      "pred_parsed": "        _loader: Callable = []\n        if isinstance(load, str):\n            if \"/\" in load:\n                _loader = partial(loader, load)\n                    else:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n \n else: \n",
      "pred_parsed": "        _loader: Callable = []\n        if isinstance(load, str):\n            if \"/\" in load:\n                _loader = partial(loader, load)\n                \n                else:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n _loader: Callable = '' \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n",
      "pred_parsed": "        _loader: Callable = ''\n        if isinstance(load, str):\n            if \"/\" in load:\n                _loader = partial(loader, load)\n            else:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "unitaryfund/mitiq",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/unitaryfund-mitiq",
    "commit": "bac97a396e5570f4884b62ba9094466a3bb881cc",
    "filename": "mitiq/zne/scaling.py",
    "source_code": "    scale_factor: float,\n    fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Tuple[Any] = (),\n    **kwargs,",
    "target_code": "    scale_factor: float,\n    fold_method: Callable[..., Circuit],\n    fold_method_args: Optional[Tuple[Any]] = None,\n    **kwargs,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " fold_method_args is declared to have type `Tuple[typing.Any]` but is used as type `Tuple[]`.",
    "warning_line": 789,
    "pred_top-1": {
      "pred": "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any] = (), \n **kwargs, \n",
      "pred_parsed": "    scale_factor: float,\n    fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Tuple[Any] = (),\n    **kwargs,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Optional[Tuple[Any]] = (), \n **kwargs, \n",
      "pred_parsed": "    scale_factor: float,\n    fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Optional[Tuple[Any]] = (),\n    **kwargs,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "scale_factor: float, \n fold_method: Optional[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Optional[Tuple[Any]] = (), \n **kwargs, \n",
      "pred_parsed": "    scale_factor: float,\n    fold_method: Optional[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Optional[Tuple[Any]] = (),\n    **kwargs,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any, Any] = (), \n **kwargs, \n",
      "pred_parsed": "    scale_factor: float,\n    fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Tuple[Any, Any] = (),\n    **kwargs,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "scale_factor: float, \n fold_method: Tuple[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any] = (), \n **kwargs, \n",
      "pred_parsed": "    scale_factor: float,\n    fold_method: Tuple[[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Tuple[Any] = (),\n    **kwargs,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "datatheorem/strongarm",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "source_code": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]\n        return categories",
    "target_code": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if isinstance(c, ObjcCategory)]\n        return categories\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " categories is declared to have type `List[ObjcCategory]` but is used as type `List[ObjcClass]`.",
    "warning_line": 89,
    "pred_top-1": {
      "pred": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory] \n return categories \n",
      "pred_parsed": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]\n        return categories\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "all_classes = self.objc_classes() \n categories: List[List[ObjcCategory]] = [c for c in all_classes if type(c) == ObjcCategory] \n return categories \n",
      "pred_parsed": "        all_classes = self.objc_classes()\n        categories: List[List[ObjcCategory]] = [c for c in all_classes if type(c) == ObjcCategory]\n        return categories\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if ObjcCategory] \n return categories \n",
      "pred_parsed": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if ObjcCategory]\n        return categories\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if objcCategory] \n return categories \n",
      "pred_parsed": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if objcCategory]\n        return categories\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if c == ObjcCategory] \n return categories \n",
      "pred_parsed": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if c == ObjcCategory]\n        return categories\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "volatilityfoundation/volatility3",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/volatilityfoundation-volatility3",
    "commit": "7a52ac9debc6e0463a52ecc1c5cacc5dbb40a0d1",
    "filename": "volatility/framework/renderers/__init__.py",
    "source_code": "               accumulator: _T,\n               sort_key: interfaces.renderers.ColumnSortKey = None) -> _T:\n        \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"",
    "target_code": "               accumulator: _T,\n               sort_key: typing.Optional[interfaces.renderers.ColumnSortKey] = None) -> _T:\n        <IND>\"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " sort_key is declared to have type `interfaces.renderers.ColumnSortKey` but is used as type `None`.",
    "warning_line": 293,
    "pred_top-1": {
      "pred": "accumulator: _T, \n sort_key: Optional[interfaces.renderers.ColumnSortKey] = None) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "pred_parsed": "               accumulator: _T,\n               sort_key: Optional[interfaces.renderers.ColumnSortKey] = None) -> _T:\n                   \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = ()) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "pred_parsed": "               accumulator: _T,\n               sort_key: interfaces.renderers.ColumnSortKey = ()) -> _T:\n                   \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = \"\") -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "pred_parsed": "               accumulator: _T,\n               sort_key: interfaces.renderers.ColumnSortKey = \"\") -> _T:\n                   \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = []) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "pred_parsed": "               accumulator: _T,\n               sort_key: interfaces.renderers.ColumnSortKey = []) -> _T:\n                   \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = \"\") -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "pred_parsed": "               accumulator: _T,\n               sort_key: interfaces.renderers.ColumnSortKey = \"\") -> _T:\n                   \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "atlassian-labs/peerd",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/atlassian-labs-peerd",
    "commit": "fc06a7e476bbcd5a177b171811af38b4ad171964",
    "filename": "peerd/aws.py",
    "source_code": "    tags = [{'Key': key, 'Value': value} for (key, value) in tags.items()]",
    "target_code": "\n    tags_aws = [{'Key': key, 'Value': value} for (key, value) in tags.items()]\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `typing.List[typing.Dict[str, typing.Any]]`.",
    "warning_line": 143,
    "pred_top-1": {
      "pred": "\n tags = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n",
      "pred_parsed": "    tags = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()]\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n tags = [ { 'Key': key, 'Value': value } for (key, value) in tags[str]] \n \n",
      "pred_parsed": "    tags = [ { 'Key': key, 'Value': value } for (key, value) in tags[str]]\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n labels = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n",
      "pred_parsed": "    labels = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n tag = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n",
      "pred_parsed": "    tag = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n tags = [ { 'Key': key, 'Value': value } for (key, value in tags.items()] \n \n",
      "pred_parsed": "    tags = [ { 'Key': key, 'Value': value } for (key, value in tags.items()]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "libp2p/py-libp2p",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/libp2p-py-libp2p",
    "commit": "b2f496d081db5176636449d585dbbdba7f71061d",
    "filename": "libp2p/pubsub/gossipsub.py",
    "source_code": "            # Don't create a new selection_pool if we are not subbing anything\n            selection_pool: List[Any] = pool",
    "target_code": "            # Don't create a new selection_pool if we are not subbing anything\n            <IND>selection_pool = list(pool)\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " selection_pool is declared to have type `List[typing.Any]` but is used as type `Sequence[typing.Any]`.",
    "warning_line": 456,
    "pred_top-1": {
      "pred": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Any] = pool \n \n",
      "pred_parsed": "            # Don't create a new selection_pool if we are not subbing anything\n            selection_pool: List[Any] = pool\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: Optional[List[Any]] = pool \n \n",
      "pred_parsed": "            # Don't create a new selection_pool if we are not subbing anything\n            selection_pool: Optional[List[Any]] = pool\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Sequence[Any]] = pool \n \n",
      "pred_parsed": "            # Don't create a new selection_pool if we are not subbing anything\n            selection_pool: List[Sequence[Any]] = pool\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "# Don't create new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Any] = pool \n \n",
      "pred_parsed": "            # Don't create new selection_pool if we are not subbing anything\n            selection_pool: List[Any] = pool\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: Sequence[Any] = pool \n \n",
      "pred_parsed": "            # Don't create a new selection_pool if we are not subbing anything\n            selection_pool: Sequence[Any] = pool\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "talkiq/gcloud-aio",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/talkiq-gcloud-aio",
    "commit": "82af90a9877490b01daff1af609a39a2525d2db2",
    "filename": "storage/gcloud/aio/storage/storage.py",
    "source_code": "    async def _download(self, bucket: str, object_name: str, *,\n                        params: dict = None, timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:",
    "target_code": "    <DED>async def _download(self, bucket: str, object_name: str, *,\n                        params: Optional[Dict[str, str]] = None,\n                        timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "warning_line": 293,
    "pred_top-1": {
      "pred": "<DED> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "pred_parsed": "    async def _download(self, bucket: str, object_name: str, *,\n    params: Optional[Dict[str, str]] = None, timeout: int = 10,\n    session: Optional[Session] = None) -> bytes:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> async def _download(self, bucket: str, object_name: str, *, <DED> params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "pred_parsed": "    async def _download(self, bucket: str, object_name: str, *,  params: Optional[Dict[str, str]] = None, timeout: int = 10,\n    session: Optional[Session] = None) -> bytes:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<IND> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "pred_parsed": "    async def _download(self, bucket: str, object_name: str, *,\n    params: Optional[Dict[str, str]] = None, timeout: int = 10,\n    session: Optional[Session] = None) -> bytes:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<DED> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[dict] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "pred_parsed": "    async def _download(self, bucket: str, object_name: str, *,\n    params: Optional[dict] = None, timeout: int = 10,\n    session: Optional[Session] = None) -> bytes:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> async def _download(self, bucket: str, object_name: str, *, <IND> params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "pred_parsed": "    async def _download(self, bucket: str, object_name: str, *,  params: Optional[Dict[str, str]] = None, timeout: int = 10,\n    session: Optional[Session] = None) -> bytes:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "Ultimaker/Cura",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Ultimaker-Cura",
    "commit": "f2b50c748c1aea35e61de119fb3a08a28afdb295",
    "filename": "plugins/FirmwareUpdateChecker/FirmwareUpdateCheckerJob.py",
    "source_code": "    def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None):\n        super().__init__()",
    "target_code": "\n    def __init__(self, container, silent, lookups: FirmwareUpdateCheckerLookup, callback) -> None:\n        <IND>super().__init__()\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " lookups is declared to have type `FirmwareUpdateCheckerLookup` but is used as type `None`.",
    "warning_line": 27,
    "pred_top-1": {
      "pred": "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None): \n <IND> super().__init__() \n",
      "pred_parsed": "    def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None):\n        super().__init__()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n def __init__(self, container=None, silent=False, lookups=FirmwareUpdateCheckerLookup=None, callback=None): \n <IND> super().__init__() \n",
      "pred_parsed": "    def __init__(self, container=None, silent=False, lookups=FirmwareUpdateCheckerLookup=None, callback=None):\n        super().__init__()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n def __init__(self, container=None, silent=False, lookups=FirmwareUpdateCheckerLookup, callback=None): \n <IND> super().__init__() \n",
      "pred_parsed": "    def __init__(self, container=None, silent=False, lookups=FirmwareUpdateCheckerLookup, callback=None):\n        super().__init__()\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None): \n <DED> super().__init__() \n",
      "pred_parsed": "    def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None):\nsuper().__init__()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None) -> None: \n <IND> super().__init__() \n",
      "pred_parsed": "    def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None) -> None:\n        super().__init__()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "datatheorem/strongarm",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/objc_runtime_data_parser.py",
    "source_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = None) -> None:\n        super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)",
    "target_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n        <IND>super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " protocols is declared to have type `List[ObjcProtocol]` but is used as type `None`.",
    "warning_line": 42,
    "pred_top-1": {
      "pred": "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "pred_parsed": "                 selectors: List['ObjcSelector'],\n                 protocols: Optional[List['ObjcProtocol']] = None) -> None:\n                     super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "selectors: List['ObjcSelector'], \n protocols: List['ObjcProtocol'] = []) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "pred_parsed": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n                     super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "selectors: List['ObjcSelector'], \n protocols: List['ObjcProtocol'] = ()) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "pred_parsed": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = ()) -> None:\n                     super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <DED> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "pred_parsed": "                 selectors: List['ObjcSelector'],\n                 protocols: Optional[List['ObjcProtocol']] = None) -> None:\n             super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocol) \n",
      "pred_parsed": "                 selectors: List['ObjcSelector'],\n                 protocols: Optional[List['ObjcProtocol']] = None) -> None:\n                     super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocol)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "apache/airflow",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/apache-airflow",
    "commit": "c6dbb3f8856be75ff2619476ab3ca587a52e033a",
    "filename": "airflow/providers/google/cloud/hooks/bigquery.py",
    "source_code": "            # Turn schema_field_updates into a dict keyed on field names\n            schema_fields_updates = {field[\"name\"]: field for field in deepcopy(schema_fields_updates)}",
    "target_code": "            # Turn schema_field_updates into a dict keyed on field names\n            <IND>schema_fields_updates_dict = {field[\"name\"]: field for field in deepcopy(schema_fields_updates)}\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " schema_fields_updates is declared to have type `List[Dict[str, typing.Any]]` but is used as type `Dict[typing.Any, Dict[str, typing.Any]]`.",
    "warning_line": 1422,
    "pred_top-1": {
      "pred": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n",
      "pred_parsed": "            # Turn schema_field_updates into a dict keyed on field names\n            schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) }\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "# Turn schema_field_updates into dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n",
      "pred_parsed": "            # Turn schema_field_updates into dict keyed on field names\n            schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) }\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates_number = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n",
      "pred_parsed": "            # Turn schema_field_updates into a dict keyed on field names\n            schema_fields_updates_number = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) }\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = [] \n field for field in deepcopy(schema_fields_updates)] \n \n",
      "pred_parsed": "            # Turn schema_field_updates into a dict keyed on field names\n            schema_fields_updates = []\n            field for field in deepcopy(schema_fields_updates)]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field in deepcopy(schema_fields_updates) } \n \n",
      "pred_parsed": "            # Turn schema_field_updates into a dict keyed on field names\n            schema_fields_updates = { field[\"name\"]: field in deepcopy(schema_fields_updates) }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "samschott/maestral",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/samschott-maestral",
    "commit": "da644e1218754c2c247d16544d76b292d48f381c",
    "filename": "maestral/utils/autostart.py",
    "source_code": "        start_cmd = shlex.split(start_cmd)\n        arguments = [f'\\t\\t<string>{arg}</string>' for arg in start_cmd]",
    "target_code": "\n        start_cmd_list = shlex.split(start_cmd)\n        arguments = [f'\\t\\t<string>{arg}</string>' for arg in start_cmd_list]\n\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " start_cmd is declared to have type `str` but is used as type `typing.List[str]`.",
    "warning_line": 185,
    "pred_top-1": {
      "pred": "\n start_cmd = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "pred_parsed": "        start_cmd = shlex.split(start_cmd)\n        arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd]\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n start_cmd = str(split(start_cmd)) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "pred_parsed": "        start_cmd = str(split(start_cmd))\n        arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n start_cmd_split = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "pred_parsed": "        start_cmd_split = shlex.split(start_cmd)\n        arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n start_cmd_str = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "pred_parsed": "        start_cmd_str = shlex.split(start_cmd)\n        arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n start_cmd=split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "pred_parsed": "        start_cmd=split(start_cmd)\n        arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "jesopo/bitbot",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot",
    "commit": "577fae7ceabfd2a43b798e02a67c518c23ed33bd",
    "filename": "src/utils/irc/protocol.py",
    "source_code": "def batch_start(identifier: str, batch_type: str, tags: dict=None):\n    return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],",
    "target_code": "\n<DED>def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]={}\n        ) -> 'utils.irc.IRCParsedLine':\n    <IND>return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "warning_line": 84,
    "pred_top-1": {
      "pred": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "pred_parsed": "def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ):\n    return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "pred_parsed": "def batch_start(identifier: str, batch_type: str, tags: typing.Optional[typing.Dict[str, str]]= { } ):\n    return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ) -> utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "pred_parsed": "def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ) -> utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Optional[typing.Dict[str, str]]= { } ) -> utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "pred_parsed": "def batch_start(identifier: str, batch_type: str, tags: typing.Optional[typing.Dict[str, str]]= { } ) -> utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> def batch_start(identifier: str, batch_type: str, \n tags: typing.Dict[str, str]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "pred_parsed": "def batch_start(identifier: str, batch_type: str,\ntags: typing.Dict[str, str]= { } ):\n    return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "volatilityfoundation/volatility3",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/volatilityfoundation-volatility3",
    "commit": "7a52ac9debc6e0463a52ecc1c5cacc5dbb40a0d1",
    "filename": "volatility/framework/interfaces/context.py",
    "source_code": "    def object(self,\n               symbol_name: str = None,\n               type_name: str = None,\n               offset: int = None,",
    "target_code": "    def object(self,\n               symbol_name: str,\n               type_name: str,\n               offset: int = None,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " symbol_name is declared to have type `str` but is used as type `None`.",
    "warning_line": 107,
    "pred_top-1": {
      "pred": "def object(self, \n symbol_name: Optional[str] = None, \n type_name: Optional[str] = None, \n offset: int = None, \n",
      "pred_parsed": "    def object(self,\n    symbol_name: Optional[str] = None,\n    type_name: Optional[str] = None,\n    offset: int = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "def object(self, \n symbol_name: str, \n type_name: str, \n offset: int = None, \n",
      "pred_parsed": "    def object(self,\n    symbol_name: str,\n    type_name: str,\n    offset: int = None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "def object(self, \n symbol_name: str, \n type_name: Optional[str] = None, \n offset: int = None, \n",
      "pred_parsed": "    def object(self,\n    symbol_name: str,\n    type_name: Optional[str] = None,\n    offset: int = None,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "def object(self, \n symbol_name: typing.Optional[str] = None, \n type_name: typing.Optional[str] = None, \n offset: int = None, \n",
      "pred_parsed": "    def object(self,\n    symbol_name: typing.Optional[str] = None,\n    type_name: typing.Optional[str] = None,\n    offset: int = None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "def object(self, \n symbol_name: str = '', \n type_name: str = '', \n offset: int = None, \n",
      "pred_parsed": "    def object(self,\n    symbol_name: str = '',\n    type_name: str = '',\n    offset: int = None,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "flairNLP/flair",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/flairNLP-flair",
    "commit": "700f11ccd1f1c429daeab8512f42dad30a01401f",
    "filename": "flair/datasets/text_text.py",
    "source_code": "        test: FlairDataset = DataPairDataset(\n            test_file,",
    "target_code": "\n        test = DataPairDataset(\n            test_file,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " test is declared to have type `FlairDataset` but is used as type `typing.Optional[DataPairDataset]`.",
    "warning_line": 269,
    "pred_top-1": {
      "pred": "\n test: DataPairDataset = DataPairDataset( \n test_file, \n",
      "pred_parsed": "        test: DataPairDataset = DataPairDataset(\n        test_file,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n test: DataPairDataset( \n test_file, \n",
      "pred_parsed": "        test: DataPairDataset(\n        test_file,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n test = DataPairDataset( \n test_file, \n",
      "pred_parsed": "        test = DataPairDataset(\n        test_file,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n test: Optional[FlairDataset] = DataPairDataset( \n test_file, \n",
      "pred_parsed": "        test: Optional[FlairDataset] = DataPairDataset(\n        test_file,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n test_file = DataPairDataset( \n test_file, \n",
      "pred_parsed": "        test_file = DataPairDataset(\n        test_file,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "ReactiveX/RxPY",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ReactiveX-RxPY",
    "commit": "cd3d5a5b833a0df3ecd91116c0243ebaa762578c",
    "filename": "rx/core/observable/observable.py",
    "source_code": "    def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None:",
    "target_code": "\n    def __init__(self, subscribe: Optional[Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None:\n        <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " subscribe is declared to have type `typing.Callable[[typing.Observer[typing.Any], Optional[typing.Scheduler]], typing.Disposable]` but is used as type `None`.",
    "warning_line": 18,
    "pred_top-1": {
      "pred": "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None: \n <IND>",
      "pred_parsed": "    def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None:\n        \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler], typing.Disposable]] = None) -> None: \n <IND>",
      "pred_parsed": "    def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler], typing.Disposable]] = None) -> None:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n def __init__(self, subscribe: Optional[Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None: \n <IND>",
      "pred_parsed": "    def __init__(self, subscribe: Optional[Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None:\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]) -> None: \n <IND>",
      "pred_parsed": "    def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]) -> None:\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n def __init__(self, subscribe: Callable[[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None: \n <IND>",
      "pred_parsed": "    def __init__(self, subscribe: Callable[[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "ManimCommunity/manim",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ManimCommunity-manim",
    "commit": "a4c1c4f15a752d7c40a09516c1950f1ea7386948",
    "filename": "manim/mobject/mobject.py",
    "source_code": "    def add_background_rectangle(\n        self, color: Colors = BLACK, opacity: float = 0.75, **kwargs\n    ):",
    "target_code": "    <DED>def add_background_rectangle(\n        self, color: Optional[Colors] = None, opacity: float = 0.75, **kwargs\n    ):\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " color is declared to have type `Colors` but is used as type `str`.",
    "warning_line": 1635,
    "pred_top-1": {
      "pred": "<DED> def add_background_rectangle( \n self, color: Colors[str] = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "pred_parsed": "    def add_background_rectangle(\n    self, color: Colors[str] = BLACK, opacity: float = 0.75, **kwargs\n    ):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> def add_background_rectangle( \n self, color: Colors[0] = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "pred_parsed": "    def add_background_rectangle(\n    self, color: Colors[0] = BLACK, opacity: float = 0.75, **kwargs\n    ):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> def add_background_rectangle( \n self, color: Colors = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "pred_parsed": "    def add_background_rectangle(\n    self, color: Colors = BLACK, opacity: float = 0.75, **kwargs\n    ):\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> def add_background_rectangle( \n self, color: Colors.color = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "pred_parsed": "    def add_background_rectangle(\n    self, color: Colors.color = BLACK, opacity: float = 0.75, **kwargs\n    ):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> def add_background_rectangle( \n self, color: Colors = 'Black', opacity: float = 0.75, **kwargs \n ): \n",
      "pred_parsed": "    def add_background_rectangle(\n    self, color: Colors = 'Black', opacity: float = 0.75, **kwargs\n    ):\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "common-workflow-language/cwltool",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/common-workflow-language-cwltool",
    "commit": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c",
    "filename": "cwltool/provenance.py",
    "source_code": "    def add_tagfile(self, path, timestamp=None):\n        # type: (Text, datetime.datetime) -> None\n        \"\"\"Add tag files to our research object.\"\"\"",
    "target_code": "    <DED>def add_tagfile(self, path, timestamp=None):\n        # type: (Text, Optional[datetime.datetime]) -> None\n        <IND>\"\"\"Add tag files to our research object.\"\"\"\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " timestamp is declared to have type `datetime.datetime` but is used as type `None`.",
    "warning_line": 1064,
    "pred_top-1": {
      "pred": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, Datetime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "pred_parsed": "    def add_tagfile(self, path, timestamp=None):\n    # type: (Text, Datetime.datetime) -> None\n        \"\"\"Add tag files to our research object.\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, datetime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "pred_parsed": "    def add_tagfile(self, path, timestamp=None):\n    # type: (Text, datetime.datetime) -> None\n        \"\"\"Add tag files to our research object.\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, DateTime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "pred_parsed": "    def add_tagfile(self, path, timestamp=None):\n    # type: (Text, DateTime.datetime) -> None\n        \"\"\"Add tag files to our research object.\"\"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "pred_parsed": "    def add_tagfile(self, path, timestamp=None):\n    # type: (Text) -> None\n        \"\"\"Add tag files to our research object.\"\"\"\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, 'datetime.datetime') -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "pred_parsed": "    def add_tagfile(self, path, timestamp=None):\n    # type: (Text, 'datetime.datetime') -> None\n        \"\"\"Add tag files to our research object.\"\"\"\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "gitpython-developers/GitPython",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/gitpython-developers-GitPython",
    "commit": "2e2fe186d09272c3cb6c96467fff362deb90994f",
    "filename": "git/repo/base.py",
    "source_code": "    @classmethod\n    def init(cls, path: PathLike = None, mkdir: bool = True, odbt: Type[GitCmdObjectDB] = GitCmdObjectDB,\n             expand_vars: bool = True, **kwargs: Any) -> 'Repo':",
    "target_code": "    <DED>@classmethod\n    def init(cls, path: Union[PathLike, None] = None, mkdir: bool = True, odbt: Type[GitCmdObjectDB] = GitCmdObjectDB,\n             expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " path is declared to have type `Union[os.PathLike[typing.Any], str]` but is used as type `None`.",
    "warning_line": 979,
    "pred_top-1": {
      "pred": "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[str, str] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "pred_parsed": "    @classmethod\n    def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[str, str] = GitCmdObjectDB,\n    expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> @classmethod \n def init(cls, path: Union[PathLike, None] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "pred_parsed": "    @classmethod\n    def init(cls, path: Union[PathLike, None] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB,\n    expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> @classmethod \n def init(cls, path: Union[PathLike, None], None] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "pred_parsed": "    @classmethod\n    def init(cls, path: Union[PathLike, None], None] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB,\n    expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "pred_parsed": "    @classmethod\n    def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: GitCmdObjectDB,\n    expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "pred_parsed": "    @classmethod\n    def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB,\n    expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "joerick/pyinstrument",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/joerick-pyinstrument",
    "commit": "12b65ffb01e65c5fbcfb08abee26da56c745c919",
    "filename": "pyinstrument/profiler.py",
    "source_code": "    def start(self, caller_frame: types.FrameType = None):",
    "target_code": "\n    <DED>def start(self, caller_frame: types.FrameType | None = None):\n        <IND>",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " caller_frame is declared to have type `types.FrameType` but is used as type `None`.",
    "warning_line": 101,
    "pred_top-1": {
      "pred": "\n <DED> def start(self, caller_frame: options.FrameType = None): \n <IND>",
      "pred_parsed": "    def start(self, caller_frame: options.FrameType = None):\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> def start(self, caller_frame: typing.Optional[types.FrameType] = None): \n <IND>",
      "pred_parsed": "    def start(self, caller_frame: typing.Optional[types.FrameType] = None):\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def start(self, caller_frame: types.FrameType): \n <IND>",
      "pred_parsed": "    def start(self, caller_frame: types.FrameType):\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n <DED> def start(self, caller_frame: calls.FrameType): \n <IND>",
      "pred_parsed": "    def start(self, caller_frame: calls.FrameType):\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> def start(self, caller_frame: types.FrameType = \"\"): \n <IND>",
      "pred_parsed": "    def start(self, caller_frame: types.FrameType = \"\"):\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "kubeflow/pipelines",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/kubeflow-pipelines",
    "commit": "c01315a89da6a0eee4a12d3bb1c095c28931aee3",
    "filename": "sdk/python/kfp/dsl/_metadata.py",
    "source_code": "      description: str = '',\n      param_type: TypeMeta = None,\n      default = None):",
    "target_code": "      description: str = '',\n      param_type = None,\n      default = None):\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " param_type is declared to have type `TypeMeta` but is used as type `None`.",
    "warning_line": 82,
    "pred_top-1": {
      "pred": "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): \n",
      "pred_parsed": "      description: str = '',\n      param_type: Optional[TypeMeta] = None,\n      default = None):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "description: str = '', \n param_type: TypeMeta, \n default = None): \n",
      "pred_parsed": "      description: str = '',\n      param_type: TypeMeta,\n      default = None):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): <IND>",
      "pred_parsed": "      description: str = '',\n      param_type: Optional[TypeMeta] = None,\n          default = None):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "description: str = '', \n param_type: Optional[typeMeta] = None, \n default = None): \n",
      "pred_parsed": "      description: str = '',\n      param_type: Optional[typeMeta] = None,\n      default = None):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): <DED>",
      "pred_parsed": "      description: str = '',\n      param_type: Optional[TypeMeta] = None,\n  default = None):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "fa631411cdd181edf375f603d1ecec3d025f1c82",
    "filename": "raiden/network/proxies/token_network.py",
    "source_code": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID = None,\n    ) -> bool:",
    "target_code": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID,\n    ) -> bool:\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " channel_identifier is declared to have type `typing.ChannelID` but is used as type `None`.",
    "warning_line": 471,
    "pred_top-1": {
      "pred": "participant2: typing.Address, \n channel_identifier: typing.Optional[typing.ChannelID] = None, \n ) -> bool: \n",
      "pred_parsed": "            participant2: typing.Address,\n            channel_identifier: typing.Optional[typing.ChannelID] = None,\n            ) -> bool:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "participant2: typing.Address, \n channel_identifier: typing.ChannelID, \n ) -> bool: \n",
      "pred_parsed": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID,\n            ) -> bool:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "participant2: typing.Address, \n channel_identifier: typing.ChannelID = None, \n ) -> bool: \n",
      "pred_parsed": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID = None,\n            ) -> bool:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "participant2: typing.Address, \n channel_identifier: typing.Optional[typing.ChannelID] = None, \n ) -> bool: <IND>",
      "pred_parsed": "            participant2: typing.Address,\n            channel_identifier: typing.Optional[typing.ChannelID] = None,\n                ) -> bool:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "participant2: typing.Address, \n channel_identifier: typing.ChannelID = \"\", \n ) -> bool: \n",
      "pred_parsed": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID = \"\",\n            ) -> bool:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "mosquito/aiormq",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/mosquito-aiormq",
    "commit": "91909de532777c494df33a4843410b1981ca8794",
    "filename": "aiormq/abc.py",
    "source_code": "        self,\n        delivery_tag: int = None,\n        multiple: bool = False,",
    "target_code": "        self,\n        delivery_tag: int,\n        multiple: bool = False,\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " delivery_tag is declared to have type `int` but is used as type `None`.",
    "warning_line": 123,
    "pred_top-1": {
      "pred": "self, \n delivery_tag: Optional[int] = None, \n multiple: bool = False, \n",
      "pred_parsed": "        self,\n        delivery_tag: Optional[int] = None,\n        multiple: bool = False,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "self, \n delivery_tag: int, \n multiple: bool = False, \n",
      "pred_parsed": "        self,\n        delivery_tag: int,\n        multiple: bool = False,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "self, \n delivery_tag: bool = False, \n multiple: bool = False, \n",
      "pred_parsed": "        self,\n        delivery_tag: bool = False,\n        multiple: bool = False,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "self, \n delivery_tag: typing.Optional[int] = None, \n multiple: bool = False, \n",
      "pred_parsed": "        self,\n        delivery_tag: typing.Optional[int] = None,\n        multiple: bool = False,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "self, \n delivery_tag: Optional[Int] = None, \n multiple: bool = False, \n",
      "pred_parsed": "        self,\n        delivery_tag: Optional[Int] = None,\n        multiple: bool = False,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "jesopo/bitbot",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/jesopo-bitbot",
    "commit": "577fae7ceabfd2a43b798e02a67c518c23ed33bd",
    "filename": "src/utils/irc/__init__.py",
    "source_code": "        self.lines.append(line)\n    def message(self, target: str, message: str, tags: dict=None):\n        self._add_line(utils.irc.protocol.message(target, message, tags))\n    def notice(self, target: str, message: str, tags: dict=None):\n        self._add_line(utils.irc.protocol.notice(target, message, tags))",
    "target_code": "        self.lines.append(line)\n    <DED>def message(self, target: str, message: str, tags: dict={}):\n        <IND>self._add_line(utils.irc.protocol.message(target, message, tags))\n    <DED>def notice(self, target: str, message: str, tags: dict={}):\n        <IND>self._add_line(utils.irc.protocol.notice(target, message, tags))\n",
    "warning_type": "Incompatible variable type [9]",
    "warning_message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
    "warning_line": 334,
    "pred_top-1": {
      "pred": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=[str]) \n",
      "pred_parsed": "        self.lines.append(line)\n    def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ):\n        self._add_line(utils.irc.protocol.message(target, message, tags))\n    def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=[str])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.",
      "pred_parsed": "        self.lines.append(line)\n    def message(self, target: str, message: str, tags: typing.Dict[str, str]= { } ):\n        self._add_line(utils.irc.protocol.message(target, message, tags))\n    def notice(self, target: str, message: str, tags: typing.Dict[str, str]= { } ):\n        self._add_line(utils.\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.irc.",
      "pred_parsed": "        self.lines.append(line)\n    def message(self, target: str, message: str, tags: typing.Dict[str, str]= { } ):\n        self._add_line(utils.irc.protocol.message(target, message, tags))\n    def notice(self, target: str, message: str, tags: typing.Dict[str, str]= { } ):\n        self._add_line(utils.irc.\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=true) \n \n",
      "pred_parsed": "        self.lines.append(line)\n    def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ):\n        self._add_line(utils.irc.protocol.message(target, message, tags))\n    def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=true)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=true) \n self._add_line(utils.",
      "pred_parsed": "        self.lines.append(line)\n    def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ):\n        self._add_line(utils.irc.protocol.message(target, message, tags))\n    def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=true)\n    self._add_line(utils.\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "xonsh/xonsh",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/xonsh-xonsh",
    "commit": "4dc08232e615a75a524fbf96f17402a7a5b353a5",
    "filename": "xonsh/xontribs_meta.py",
    "source_code": "    if spec and spec.has_location and spec.origin:\n        return ast.get_docstring(ast.parse(Path(spec.origin).read_text()))\n    return \"\"",
    "target_code": "    if spec and spec.has_location and spec.origin:\n        <IND>return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) or \"\"\n    <DED>return \"\"\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `str` but got `tp.Optional[str]`.",
    "warning_line": 61,
    "pred_top-1": {
      "pred": "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <DED> return \"\" \n",
      "pred_parsed": "    if spec and spec.has_location and spec.origin:\n        return ast.get_docstring(ast.parse(Path(spec.origin).read_text()))\n    return \"\"\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "if spec and spec.has_location and spec.origin: \n <IND> return str(ast.get_docstring(ast.parse(Path(spec.origin).read_text()))) \n <DED> return \"\" \n",
      "pred_parsed": "    if spec and spec.has_location and spec.origin:\n        return str(ast.get_docstring(ast.parse(Path(spec.origin).read_text())))\n    return \"\"\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <IND> return \"\" \n",
      "pred_parsed": "    if spec and spec.has_location and spec.origin:\n        return ast.get_docstring(ast.parse(Path(spec.origin).read_text()))\n            return \"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <DED> return '' \n",
      "pred_parsed": "    if spec and spec.has_location and spec.origin:\n        return ast.get_docstring(ast.parse(Path(spec.origin).read_text()))\n    return ''\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "if spec and spec.has_location and spec.origin: \n <IND> return str(ast.get_docstring(ast.parse(Path(spec.origin).read_text()))) \n <IND> return \"\" \n",
      "pred_parsed": "    if spec and spec.has_location and spec.origin:\n        return str(ast.get_docstring(ast.parse(Path(spec.origin).read_text())))\n            return \"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "347822a32090ea30c59fe4dc437e17795bd69c22",
    "filename": "raiden/transfer/channel.py",
    "source_code": "def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount:\n    return sum(\n        unlock.lock.amount\n        for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    )",
    "target_code": "<DED>def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount:\n    <IND>return TokenAmount(sum(\n        unlock.lock.amount\n        for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    ))\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `TokenAmount` but got `typing.Union[PaymentWithFeeAmount, int]`.",
    "warning_line": 837,
    "pred_top-1": {
      "pred": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount: \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "pred_parsed": "def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount:\n    return sum(\n    unlock.lock.amount\n    for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount: \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "pred_parsed": "def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount:\n    return sum(\n    unlock.lock.amount\n    for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    )\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount(TokenAmount): \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "pred_parsed": "def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount(TokenAmount):\n    return sum(\n    unlock.lock.amount\n    for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount: \n <IND> return sum( <DED> unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "pred_parsed": "def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount:\nreturn sum(  unlock.lock.amount\nfor unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount: \n <IND> return sum( <DED> unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "pred_parsed": "def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount:\nreturn sum(  unlock.lock.amount\nfor unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "ConsenSys/mythril",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ConsenSys-mythril",
    "commit": "c3c10f5128d700c131a8de8e5b3f7af8a8fb559d",
    "filename": "mythril/laser/smt/bitvec.py",
    "source_code": "def ULT(a: BitVec, b: BitVec) -> Bool:\n    annotations = a.annotations + b.annotations\n    Bool(z3.ULT(a, b), annotations)",
    "target_code": "<DED>def ULT(a: BitVec, b: BitVec) -> Bool:\n    <IND>\"\"\" Create an unsigned less than expression \"\"\"\n    annotations = a.annotations + b.annotations\n    return Bool(z3.ULT(a, b), annotations)\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Bool` but got implicit return value of `None`.",
    "warning_line": 83,
    "pred_top-1": {
      "pred": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> return annotations = a.annotations + b.annotations \n Bool(z3.ULT(a, b), annotations) \n \n",
      "pred_parsed": "def ULT(a: BitVec, b: BitVec) -> Bool:\n    return annotations = a.annotations + b.annotations\n    Bool(z3.ULT(a, b), annotations)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> assert a.annotations + b.annotations is not None \n annotations = a.annotations + b.annotations \n return Bool(z3.ULT(a, b), annotations) \n \n",
      "pred_parsed": "def ULT(a: BitVec, b: BitVec) -> Bool:\n    assert a.annotations + b.annotations is not None\n    annotations = a.annotations + b.annotations\n    return Bool(z3.ULT(a, b), annotations)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> annotations = a.annotations + b.annotations \n return Bool(z3.ULT(a, b), annotations) \n \n",
      "pred_parsed": "def ULT(a: BitVec, b: BitVec) -> Bool:\n    annotations = a.annotations + b.annotations\n    return Bool(z3.ULT(a, b), annotations)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> assert a.annotations + b.annotations is not None \n annotations = a.annotations + b.annotations \n Bool(z3.ULT(a, b), annotations) \n \n",
      "pred_parsed": "def ULT(a: BitVec, b: BitVec) -> Bool:\n    assert a.annotations + b.annotations is not None\n    annotations = a.annotations + b.annotations\n    Bool(z3.ULT(a, b), annotations)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> return annotations = a.annotations + b.annotations \n \n",
      "pred_parsed": "def ULT(a: BitVec, b: BitVec) -> Bool:\n    return annotations = a.annotations + b.annotations\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "edgedb/edgedb",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/edgedb-edgedb",
    "commit": "e7b95b8a233ef94da244ffd74c4abfbe6d7548bb",
    "filename": "edb/pgsql/compiler/expr.py",
    "source_code": "    if ctx.singleton_mode:\n        return _compile_set_in_singleton_mode(ir_set, ctx=ctx)",
    "target_code": "    <IND>if ctx.singleton_mode:\n        <IND>_compile_set_in_singleton_mode(ir_set, ctx=ctx)\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `None` but got `pgast.Base`.",
    "warning_line": 80,
    "pred_top-1": {
      "pred": "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n",
      "pred_parsed": "    if ctx.singleton_mode:\n        return _compile_set_in_singleton_mode(ir_set, ctx=ctx)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n",
      "pred_parsed": "    if ctx.singleton_mode:\n        return _compile_set_in_singleton_mode(ir_set, ctx=ctx)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=pgast.Base(ctx=ctx)) \n \n",
      "pred_parsed": "    if ctx.singleton_mode:\n        return _compile_set_in_singleton_mode(ir_set, ctx=pgast.Base(ctx=ctx))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n",
      "pred_parsed": "    if ctx.singleton_mode:\n        return _compile_set_in_singleton_mode(ir_set, ctx=ctx)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=pgast.Base(ctx)) \n \n",
      "pred_parsed": "    if ctx.singleton_mode:\n        return _compile_set_in_singleton_mode(ir_set, ctx=pgast.Base(ctx))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "oppia/oppia",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/oppia-oppia",
    "commit": "72937725a323b0cc1ccec150c81b041abeacb575",
    "filename": "utils.py",
    "source_code": "    return base64.urlsafe_b64encode(os.urandom(length))[:length]",
    "target_code": "\n    return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8')\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `str` but got `bytes`.",
    "warning_line": 619,
    "pred_top-1": {
      "pred": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length] \n \n",
      "pred_parsed": "    return base64.urlsafe_b64encode(os.urandom(length))[:length]\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8') \n \n",
      "pred_parsed": "    return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n os.urandom = base64.urlsafe_b64encode(os.urandom(length))[:length] \n return str(base64.urlsafe_b64encode(os.urandom(length))[:length]) \n \n",
      "pred_parsed": "    os.urandom = base64.urlsafe_b64encode(os.urandom(length))[:length]\n    return str(base64.urlsafe_b64encode(os.urandom(length))[:length])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8').decode('utf-8') \n \n",
      "pred_parsed": "    return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8').decode('utf-8')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length].decode(\"utf-8\") \n \n",
      "pred_parsed": "    return base64.urlsafe_b64encode(os.urandom(length))[:length].decode(\"utf-8\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "mosquito/aiormq",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/mosquito-aiormq",
    "commit": "91909de532777c494df33a4843410b1981ca8794",
    "filename": "aiormq/connection.py",
    "source_code": "    def exchange_exchange_bindings(self) -> bool:\n        return self.server_capabilities.get(\"exchange_exchange_bindings\")",
    "target_code": "    def exchange_exchange_bindings(self) -> bool:\n        <IND>return bool(self.server_capabilities.get(\"exchange_exchange_bindings\"))\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `bool` but got `typing.Union[None, bool, int, str]`.",
    "warning_line": 521,
    "pred_top-1": {
      "pred": "def exchange_exchange_bindings(self) -> typing.Union[\"exchange_exchange_bindings\"]: \n <IND> return bool(self.server_capabilities.get(\"exchange_exchange_bindings\")) \n \n",
      "pred_parsed": "    def exchange_exchange_bindings(self) -> typing.Union[\"exchange_exchange_bindings\"]:\n        return bool(self.server_capabilities.get(\"exchange_exchange_bindings\"))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]: \n <IND> return bool(self.server_capabilities.get(\"exchange_exchange_bindings\")) \n \n",
      "pred_parsed": "    def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]:\n        return bool(self.server_capabilities.get(\"exchange_exchange_bindings\"))\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]: \n <IND> return self.server_capabilities.get(\"exchange_exchange_bindings\") \n \n",
      "pred_parsed": "    def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]:\n        return self.server_capabilities.get(\"exchange_exchange_bindings\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "def exchange_exchange_bindings(self) -> bool: \n <IND> return typing.Union[\"exchange_exchange_bindings\"] \n \n",
      "pred_parsed": "    def exchange_exchange_bindings(self) -> bool:\n        return typing.Union[\"exchange_exchange_bindings\"]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]: \n <IND> return self.server_capabilities.get(\"exchange_exchange_bindings\"); \n \n",
      "pred_parsed": "    def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]:\n        return self.server_capabilities.get(\"exchange_exchange_bindings\");\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "procrastinate-org/procrastinate",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/procrastinate-org-procrastinate",
    "commit": "2f87ff44527a91cc7d58f608a42f7be767815727",
    "filename": "procrastinate/jobs.py",
    "source_code": "        self._log_after_defer_job(job=job)\n        return job.id",
    "target_code": "        self._log_after_defer_job(job=job)\n        assert job.id  # for mypy\n        return job.id\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `int` but got `Optional[int]`.",
    "warning_line": 156,
    "pred_top-1": {
      "pred": "self._log_after_defer_job(job=job) \n assert isinstance(job.id) \n return assert isinstance(job.id) \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert isinstance(job.id)\n        return assert isinstance(job.id)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.id \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert job.id is not None\n        return assert job.id\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "self._log_after_defer_job(job=job) \n return (Optional[job.id]) \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        return (Optional[job.id])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return job.id \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert job.id is not None\n        return job.id\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.isinstance(job.id) \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert job.id is not None\n        return assert job.isinstance(job.id)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "activeloopai/Hub",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/activeloopai-Hub",
    "commit": "25751187f23963c3bba63e0b8419e61af4757203",
    "filename": "hub/core/meta/tensor_meta.py",
    "source_code": "    htype_overwrite.update({\"compression\": compression})\n    return _set_compression",
    "target_code": "    <IND>htype_overwrite.update({\"compression\": compression})\n    return htype_overwrite\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `typing.Dict[typing.Any, typing.Any]` but got `typing.Callable(_set_compression)[[Named(htype_overwrite, typing.Dict[typing.Any, typing.Any]), Named(compression, str)], typing.Dict[typing.Any, typing.Any]]`.",
    "warning_line": 145,
    "pred_top-1": {
      "pred": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n return _set_compression \n \n",
      "pred_parsed": "    htype_overwrite.update( { \"compression\": compression } )\n    return _set_compression\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n return [] \n \n",
      "pred_parsed": "    htype_overwrite.update( { \"compression\": compression } )\n    return []\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n assert isinstance(str, htype_overwrite) \n return _set_compression \n \n",
      "pred_parsed": "    htype_overwrite.update( { \"compression\": compression } )\n    assert isinstance(str, htype_overwrite)\n    return _set_compression\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n assert isinstance(str, str) \n return _set_compression \n \n",
      "pred_parsed": "    htype_overwrite.update( { \"compression\": compression } )\n    assert isinstance(str, str)\n    return _set_compression\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n assert isinstance(htype_overwrite, dict) \n return _set_compression \n \n",
      "pred_parsed": "    htype_overwrite.update( { \"compression\": compression } )\n    assert isinstance(htype_overwrite, dict)\n    return _set_compression\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "huggingface/datasets",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/huggingface-datasets",
    "commit": "49e517a3d21392291d771872204594f43cd09532",
    "filename": "src/datasets/dataset_dict.py",
    "source_code": "        self._check_values_type()\n        for dataset in self.values():\n            dataset.cleanup_cache_files()",
    "target_code": "        self._check_values_type()\n        return {k: dataset.cleanup_cache_files() for k, dataset in self.items()}\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Dict[str, int]` but got implicit return value of `None`.",
    "warning_line": 111,
    "pred_top-1": {
      "pred": "self._check_values_type() \n for dataset in self.values(): \n <IND> dataset.cleanup_cache_files() \n \n",
      "pred_parsed": "        self._check_values_type()\n        for dataset in self.values():\n            dataset.cleanup_cache_files()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "self._check_values_type() \n for dataset in self.values(): \n <IND> return dataset.cleanup_cache_files() \n \n",
      "pred_parsed": "        self._check_values_type()\n        for dataset in self.values():\n            return dataset.cleanup_cache_files()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "self._check_values_type() \n for dataset in self.values(): \n <IND> assert dataset.cleanup_cache_files() \n \n",
      "pred_parsed": "        self._check_values_type()\n        for dataset in self.values():\n            assert dataset.cleanup_cache_files()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "self._check_values_type() \n for dataset in self.values(): \n <IND> assert dataset is not None \n dataset.cleanup_cache_files() \n \n",
      "pred_parsed": "        self._check_values_type()\n        for dataset in self.values():\n            assert dataset is not None\n            dataset.cleanup_cache_files()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "self._check_values_type() \n for dataset in self.values(): \n <IND> dataset.cleanup_cache_files() \n <DED>",
      "pred_parsed": "        self._check_values_type()\n        for dataset in self.values():\n            dataset.cleanup_cache_files()\n        \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "Qiskit/qiskit-terra",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Qiskit-qiskit-terra",
    "commit": "1687c30fd63344f1ea50cb7b1774e26928678b23",
    "filename": "qiskit/pulse/instructions/acquire.py",
    "source_code": "        \"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self._mem_slot",
    "target_code": "        <IND>\"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self.operands[2]\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `MemorySlot` but got `Optional[MemorySlot]`.",
    "warning_line": 112,
    "pred_top-1": {
      "pred": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self._mem_slot \n \n",
      "pred_parsed": "        \"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self._mem_slot\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n assert self.mem_slot is not None \n return self._mem_slot \n \n",
      "pred_parsed": "        \"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        assert self.mem_slot is not None\n        return self._mem_slot\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n assert self._mem_slot is not None \n return self._mem_slot \n \n",
      "pred_parsed": "        \"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        assert self._mem_slot is not None\n        return self._mem_slot\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self.mem_slot \n \n",
      "pred_parsed": "        \"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self.mem_slot\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self._mem_slot \n <DED>",
      "pred_parsed": "        \"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self._mem_slot\n    \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "lykoss/lykos",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos",
    "commit": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "filename": "src/context.py",
    "source_code": "            modes.append(\"\")\n        return tuple(modes[:4])",
    "target_code": "            <IND>modes.append(\"\")\n        <DED>rA, rB, rC, rD = modes[:4]\n        return (rA, rB, rC, rD)\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Tuple[str, str, str, str]` but got `typing.Tuple[typing.Any, ...]`.",
    "warning_line": 321,
    "pred_top-1": {
      "pred": "<IND> modes.append(\"\") \n <DED> return tuple(modes[:4]) \n \n",
      "pred_parsed": "            modes.append(\"\")\n        return tuple(modes[:4])\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> modes.append(\"\") \n <DED> if not tuple: \n <IND> return tuple(modes[:4]) \n \n",
      "pred_parsed": "            modes.append(\"\")\n        if not tuple:\n            return tuple(modes[:4])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> modes.append(\"\") \n <DED> if isinstance(modes[:4]): \n <IND> return tuple(modes[:4]) \n \n",
      "pred_parsed": "            modes.append(\"\")\n        if isinstance(modes[:4]):\n            return tuple(modes[:4])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> modes.append(\"\") \n <DED> str = tuple(modes[:4]) \n \n",
      "pred_parsed": "            modes.append(\"\")\n        str = tuple(modes[:4])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> modes.append(\"\") \n <DED> return tuple([modes[:4]],...]) \n \n",
      "pred_parsed": "            modes.append(\"\")\n        return tuple([modes[:4]],...])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "dagster-io/dagster",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dagster-io-dagster",
    "commit": "b57b91ea7666da41a3dbc610116aed500c647d84",
    "filename": "python_modules/dagster/dagster/core/execution/plan/objects.py",
    "source_code": "            return self.error.message.strip() + \":\\n\\n\" + user_code_error.to_string()\n        elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            return self.error.to_string()\n        else:\n            check.failed(f\"Unexpected error setting: {self.error_source}\")",
    "target_code": "            return self.error.message.strip() + \":\\n\\n\" + user_code_error.to_string()\n        <DED>else:\n            <IND>return self.error.to_string()\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `str` but got implicit return value of `None`.",
    "warning_line": 107,
    "pred_top-1": {
      "pred": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return false \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "pred_parsed": "            return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string()\n        elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            return false\n        else:\n            check.failed(f\"Unexpected error setting: { self.error_source } \")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return self.error.to_string() \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "pred_parsed": "            return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string()\n        elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            return self.error.to_string()\n        else:\n            check.failed(f\"Unexpected error setting: { self.error_source } \")\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return False \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "pred_parsed": "            return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string()\n        elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            return False\n        else:\n            check.failed(f\"Unexpected error setting: { self.error_source } \")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return str(self.error.to_string()) \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "pred_parsed": "            return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string()\n        elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            return str(self.error.to_string())\n        else:\n            check.failed(f\"Unexpected error setting: { self.error_source } \")\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return None \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "pred_parsed": "            return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string()\n        elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            return None\n        else:\n            check.failed(f\"Unexpected error setting: { self.error_source } \")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "mozman/ezdxf",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/mozman-ezdxf",
    "commit": "73c745cf3749bb4ab38f8a428d9c14c1b9bcc668",
    "filename": "src/ezdxf/entities/underlay.py",
    "source_code": "    def get_underlay_def(self) -> 'UnderlayDefinition':\n        return self._underlay_def",
    "target_code": "\n    <DED>def get_underlay_def(self) -> Optional[\"UnderlayDefinition\"]:\n        <IND>return self._underlay_def\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `UnderlayDefinition` but got `Optional[UnderlayDefinition]`.",
    "warning_line": 147,
    "pred_top-1": {
      "pred": "\n <DED> def get_underlay_def(self) -> Optional['UnderlayDefinition']: \n <IND> return self._underlay_def \n",
      "pred_parsed": "    def get_underlay_def(self) -> Optional['UnderlayDefinition']:\n        return self._underlay_def\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n <DED> def get_underlay_def(self) -> Optional[UnderlayDefinition]: \n <IND> return self._underlay_def \n",
      "pred_parsed": "    def get_underlay_def(self) -> Optional[UnderlayDefinition]:\n        return self._underlay_def\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n <DED> def get_underlay_def(self) -> Optional[\"UnderlayDefinition\"]: \n <IND> return self._underlay_def \n",
      "pred_parsed": "    def get_underlay_def(self) -> Optional[\"UnderlayDefinition\"]:\n        return self._underlay_def\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n <IND> def get_underlay_def(self) -> Optional['UnderlayDefinition']: \n <IND> return self._underlay_def \n",
      "pred_parsed": "    def get_underlay_def(self) -> Optional['UnderlayDefinition']:\n        return self._underlay_def\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n <DED> def get_underlay_def(self) -> Optional[[UnderlayDefinition]]: \n <IND> return self._underlay_def \n",
      "pred_parsed": "    def get_underlay_def(self) -> Optional[[UnderlayDefinition]]:\n        return self._underlay_def\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "facebookresearch/Mephisto",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/facebookresearch-Mephisto",
    "commit": "4937db1184a2a8d9b30f0d20bef0bc0f098a5238",
    "filename": "mephisto/abstractions/providers/mturk/mturk_worker.py",
    "source_code": "            return None\n        return workers[0]",
    "target_code": "            <IND>return None\n        <DED>return cast(\"MTurkWorker\", workers[0])\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Optional[MTurkWorker]` but got `Worker`.",
    "warning_line": 71,
    "pred_top-1": {
      "pred": "<IND> return None \n <DED> return MTurkWorker(worker) \n \n",
      "pred_parsed": "            return None\n        return MTurkWorker(worker)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<IND> return None \n <DED> return Optional[MTurkWorker] \n \n",
      "pred_parsed": "            return None\n        return Optional[MTurkWorker]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> return None \n <DED> return MTurkWorker(workers[0]) \n \n",
      "pred_parsed": "            return None\n        return MTurkWorker(workers[0])\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<IND> return None \n <DED> return Workers[0] \n \n",
      "pred_parsed": "            return None\n        return Workers[0]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> return None \n <DED> return MTurkWorker(workers) \n \n",
      "pred_parsed": "            return None\n        return MTurkWorker(workers)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "347822a32090ea30c59fe4dc437e17795bd69c22",
    "filename": "raiden/transfer/channel.py",
    "source_code": "    return min(overflow_limit, distributable)",
    "target_code": "\n    return TokenAmount(min(overflow_limit, distributable))\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `TokenAmount` but got `int`.",
    "warning_line": 961,
    "pred_top-1": {
      "pred": "\n return min(tokenAmount, overflow_limit) \n \n",
      "pred_parsed": "    return min(tokenAmount, overflow_limit)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n return min(int(overflow_limit), distributable) \n \n",
      "pred_parsed": "    return min(int(overflow_limit), distributable)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n return min(overflow_limit, distributable) \n \n",
      "pred_parsed": "    return min(overflow_limit, distributable)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "\n return min(token_amount, overflow_limit) \n \n",
      "pred_parsed": "    return min(token_amount, overflow_limit)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n return min(overflow_limit, tokenAmount) \n \n",
      "pred_parsed": "    return min(overflow_limit, tokenAmount)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "ilcardella/TradingBot",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ilcardella-TradingBot",
    "commit": "d835f8b3955783b4b4ad5d4fbea44459b7fdd7fd",
    "filename": "tradingbot/Strategies/WeightedAvgPeak.py",
    "source_code": "            return float(Price) + float(ATR) * int(self.ce_multiplier)",
    "target_code": "            <IND>return float(Price) + float(ATR) * int(self.ce_multiplier)\n        <DED>raise ValueError(\"trade direction can't be NONE\")\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `float` but got implicit return value of `None`.",
    "warning_line": 373,
    "pred_top-1": {
      "pred": "<IND> return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n",
      "pred_parsed": "            return float(Price) + float(ATR) * int(self.ce_multiplier)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n",
      "pred_parsed": "            return float(Price) + float(ATR) * int(self.ce_multiplier)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n",
      "pred_parsed": "            return float(Price) + float(ATR) * int(self.ce_multiplier)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<IND> return Price + float(ATR) * int(self.ce_multiplier) \n \n",
      "pred_parsed": "            return Price + float(ATR) * int(self.ce_multiplier)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<IND> return price + float(ATR) * int(self.ce_multiplier) \n \n",
      "pred_parsed": "            return price + float(ATR) * int(self.ce_multiplier)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "procrastinate-org/procrastinate",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/procrastinate-org-procrastinate",
    "commit": "2f87ff44527a91cc7d58f608a42f7be767815727",
    "filename": "procrastinate/jobs.py",
    "source_code": "        self._log_after_defer_job(job=job)\n        return job.id",
    "target_code": "        self._log_after_defer_job(job=job)\n        assert job.id  # for mypy\n        return job.id\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `int` but got `Optional[int]`.",
    "warning_line": 164,
    "pred_top-1": {
      "pred": "self._log_after_defer_job(job=job) \n assert isinstance(job.id) \n return assert isinstance(job.id) \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert isinstance(job.id)\n        return assert isinstance(job.id)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.id \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert job.id is not None\n        return assert job.id\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "self._log_after_defer_job(job=job) \n return (Optional[job.id]) \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        return (Optional[job.id])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return job.id \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert job.id is not None\n        return job.id\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.isinstance(job.id) \n",
      "pred_parsed": "        self._log_after_defer_job(job=job)\n        assert job.id is not None\n        return assert job.isinstance(job.id)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "volatilityfoundation/volatility3",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/volatilityfoundation-volatility3",
    "commit": "0343c8f81e3aaf0cff5979dcbb686ad91a14bbb3",
    "filename": "volatility3/framework/automagic/pdbscan.py",
    "source_code": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n        return self._method_offset(context, vlayer, b\"\\\\SystemRoot\\\\system32\\\\nt\",",
    "target_code": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> Optional[ValidKernelType]:\n        <IND>return self._method_offset(context, vlayer, b\"\\\\SystemRoot\\\\system32\\\\nt\",\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Tuple[str, int, Dict[str, Union[None, bytes, int, str]]]` but got `Optional[Tuple[str, int, Dict[str, Union[None, bytes, int, str]]]]`.",
    "warning_line": 243,
    "pred_top-1": {
      "pred": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 } \\ nt\", \n",
      "pred_parsed": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n                                 return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 } \\ nt\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 \\ \\ nt\", \n",
      "pred_parsed": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n                                 return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 \\ \\ nt\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot } \\ system32 } \\ nt\", \n",
      "pred_parsed": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n                                 return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot } \\ system32 } \\ nt\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot } \\ system32 \\ \\ nt\", \n",
      "pred_parsed": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n                                 return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot } \\ system32 \\ \\ nt\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ } system32 } \\ nt\", \n",
      "pred_parsed": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n                                 return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ } system32 } \\ nt\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "althonos/pronto",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/althonos-pronto",
    "commit": "7cafbe2e6864d747faa1b9e2cea87064ab3ea327",
    "filename": "pronto/logic/lineage.py",
    "source_code": "    def __iter__(self) -> \"SuperclassesIterator\":\n        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)",
    "target_code": "\n    <IND>def __iter__(self) -> \"SuperpropertiesIterator\":\n        <IND>return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `SuperclassesIterator` but got `SuperpropertiesIterator`.",
    "warning_line": 197,
    "pred_top-1": {
      "pred": "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "pred_parsed": "    def __iter__(self) -> \"SuperclassesIterator\":\n        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <IND> def __iter__(self) -> SuperclassesIterator: \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "pred_parsed": "    def __iter__(self) -> SuperclassesIterator:\n        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n <IND> def __iter__(self) -> 'SuperclassesIterator': \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "pred_parsed": "    def __iter__(self) -> 'SuperclassesIterator':\n        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> assert self.entity is not None \n return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "pred_parsed": "    def __iter__(self) -> \"SuperclassesIterator\":\n        assert self.entity is not None\n        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n \n",
      "pred_parsed": "    def __iter__(self) -> \"SuperclassesIterator\":\n        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "Shougo/denite.nvim",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Shougo-denite.nvim",
    "commit": "2aa4f02d3e4bec82d879c237a87e88d78f243c1d",
    "filename": "rplugin/python3/denite/source/file/rec.py",
    "source_code": "        for exe in ['python3', 'python']:\n            if shutil.which(exe) is not None:\n                return shutil.which(exe)",
    "target_code": "        <DED>for exe in ['python3', 'python']:\n            <IND>which = shutil.which(exe)\n            if which is not None:\n                <IND>return which\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `str` but got `typing.Optional[str]`.",
    "warning_line": 130,
    "pred_top-1": {
      "pred": "<DED> for exe in ['python3', 'python']: \n <IND> if str == None: \n <IND> return shutil.which(exe) \n \n",
      "pred_parsed": "        for exe in ['python3', 'python']:\n            if str == None:\n                return shutil.which(exe)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> for exe in ['python3', 'python']: \n <IND> return shutil.which(exe) \n \n",
      "pred_parsed": "        for exe in ['python3', 'python']:\n            return shutil.which(exe)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> for exe in ['python3', 'python']: \n <IND> if shutil.which(exe) is not None and shutil.which(exe) is not None: \n <IND> return shutil.which(exe) \n \n",
      "pred_parsed": "        for exe in ['python3', 'python']:\n            if shutil.which(exe) is not None and shutil.which(exe) is not None:\n                return shutil.which(exe)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> for exe in ['python3', 'python']: \n <IND> if exe is None and shutil.which(exe) is not None: \n <IND> return exe \n \n",
      "pred_parsed": "        for exe in ['python3', 'python']:\n            if exe is None and shutil.which(exe) is not None:\n                return exe\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> for exe in ['python3', 'python']: \n <IND> if shutil.which(exe) is not None and shutil.which(exe) is None: \n <IND> return shutil.which(exe) \n \n",
      "pred_parsed": "        for exe in ['python3', 'python']:\n            if shutil.which(exe) is not None and shutil.which(exe) is None:\n                return shutil.which(exe)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "Ultimaker/Cura",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Ultimaker-Cura",
    "commit": "daa0826190ce7a606e54b944afeed8693f4997d9",
    "filename": "plugins/DigitalLibrary/src/DigitalFactoryApiClient.py",
    "source_code": "        return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None",
    "target_code": "\n        return self._projects_pagination_mgr is not None and self._projects_pagination_mgr.links is not None and self._projects_pagination_mgr.links.next_page is not None\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `bool` but got `Optional[bool]`.",
    "warning_line": 122,
    "pred_top-1": {
      "pred": "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None \n \n",
      "pred_parsed": "        return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is None \n \n",
      "pred_parsed": "        return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is None\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n return bool(self._projects_pagination_mgr and self._projects_pagination_mgr.links) and bool(self._projects_pagination_mgr.links.next_page) is not None \n \n",
      "pred_parsed": "        return bool(self._projects_pagination_mgr and self._projects_pagination_mgr.links) and bool(self._projects_pagination_mgr.links.next_page) is not None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and bool(self._projects_pagination_mgr.links.next_page) \n \n",
      "pred_parsed": "        return self._projects_pagination_mgr and self._projects_pagination_mgr.links and bool(self._projects_pagination_mgr.links.next_page)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n return bool(self._projects_pagination_mgr and self._projects_pagination_mgr.links) and bool(self._projects_pagination_mgr.links.next_page is not None) \n \n",
      "pred_parsed": "        return bool(self._projects_pagination_mgr and self._projects_pagination_mgr.links) and bool(self._projects_pagination_mgr.links.next_page is not None)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "bokeh/bokeh",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/bokeh-bokeh",
    "commit": "e739f4af7f6af260bea9317fed564ecf87b36172",
    "filename": "bokeh/embed/util.py",
    "source_code": "    pat = re.compile(f\"{dollars}|{braces}|{parens}\")\n    return pat.match(text)",
    "target_code": "\n    pat = re.compile(f\"{dollars}|{braces}|{parens}\", flags=re.S)\n    return pat.search(text) is not None\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `bool` but got `typing.Optional[typing.Match[str]]`.",
    "warning_line": 367,
    "pred_top-1": {
      "pred": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text) \n \n",
      "pred_parsed": "    pat = re.compile(f\" { dollars } | { braces } | { parens } \")\n    return pat.match(text)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return bool(pat.match(text)) \n \n",
      "pred_parsed": "    pat = re.compile(f\" { dollars } | { braces } | { parens } \")\n    return bool(pat.match(text))\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(Text) \n \n",
      "pred_parsed": "    pat = re.compile(f\" { dollars } | { braces } | { parens } \")\n    return pat.match(Text)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text) \n <DED>",
      "pred_parsed": "    pat = re.compile(f\" { dollars } | { braces } | { parens } \")\n    return pat.match(text)\n\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text, '') \n \n",
      "pred_parsed": "    pat = re.compile(f\" { dollars } | { braces } | { parens } \")\n    return pat.match(text, '')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242",
    "filename": "raiden/transfer/channel.py",
    "source_code": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce + 1\n\n    # 0 must not be used since in the netting contract it represents null.\n    return 1",
    "target_code": "    <IND>if end_state.balance_proof:\n        <IND>return Nonce(end_state.balance_proof.nonce + 1)\n\n    # 0 must not be used since in the netting contract it represents null.\n    <DED>return Nonce(1)\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Nonce` but got `int`.",
    "warning_line": 1029,
    "pred_top-1": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        \n        # 0 must not be used since in the netting contract it represents null\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        # 0 must not be used since in the netting contract it represents null\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        \n        # 0 must not be used since in the netting contract it represents null\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return Nonce(end_state.balance_proof.nonce) + 1 \n \n # 0 must not be used since in the netting contract it represents null. \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return Nonce(end_state.balance_proof.nonce) + 1\n        \n        # 0 must not be used since in the netting contract it represents null.\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <IND> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        \n        # 0 must not be used since in the netting contract it represents null\n            return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "hikari-py/hikari",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari",
    "commit": "0fb0289a935c56f29b6b0bd970dfbab0a59f5362",
    "filename": "hikari/impl/stateful_cache.py",
    "source_code": "    def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        return self._intents is None or self._intents & intents",
    "target_code": "    <DED><DED>def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        <IND>return self._intents is None or (self._intents & intents) == intents\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `bool` but got `typing.Union[bool, intents_.Intent]`.",
    "warning_line": 408,
    "pred_top-1": {
      "pred": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return bool(self._intents is None or self._intents & intents) \n \n",
      "pred_parsed": "    def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        return bool(self._intents is None or self._intents & intents)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return self._intents is None or self._intents & intents \n \n",
      "pred_parsed": "    def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        return self._intents is None or self._intents & intents\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> typing.Union[bool, intents_.Intent]: \n <IND> return self._intents is None or self._intents & intents \n \n",
      "pred_parsed": "    def _is_intent_enabled(self, intents: intents_.Intent, /) -> typing.Union[bool, intents_.Intent]:\n        return self._intents is None or self._intents & intents\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> typing.Union[bool, intents_.Intent]: \n <IND> return bool(self._intents is None or self._intents & intents) \n \n",
      "pred_parsed": "    def _is_intent_enabled(self, intents: intents_.Intent, /) -> typing.Union[bool, intents_.Intent]:\n        return bool(self._intents is None or self._intents & intents)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<IND> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return self._intents is None or self._intents & intents \n \n",
      "pred_parsed": "    def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        return self._intents is None or self._intents & intents\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "P403n1x87/austin-tui",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/P403n1x87-austin-tui",
    "commit": "5dece896966240dead23475718028c7f0545ef8c",
    "filename": "austin_tui/view/austin.py",
    "source_code": "            raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        self.callback(self.Event.QUIT)",
    "target_code": "            <IND>raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        <DED>self.callback(self.Event.QUIT, None)\n        return False\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `bool` but got implicit return value of `None`.",
    "warning_line": 70,
    "pred_top-1": {
      "pred": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUIT) \n \n",
      "pred_parsed": "            raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        assert self.Event.QUIT is not None\n        self.callback(self.Event.QUIT)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> self.callback(self.Event.QUIT) \n \n",
      "pred_parsed": "            raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        self.callback(self.Event.QUIT)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(quit) \n \n",
      "pred_parsed": "            raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        assert self.Event.QUIT is not None\n        self.callback(quit)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUEST) \n \n",
      "pred_parsed": "            raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        assert self.Event.QUIT is not None\n        self.callback(self.Event.QUEST)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUT) \n \n",
      "pred_parsed": "            raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        assert self.Event.QUIT is not None\n        self.callback(self.Event.QUT)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "SectorLabs/django-postgres-extra",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/SectorLabs-django-postgres-extra",
    "commit": "9a1ed82f7c65b5056795c21001fa69faf17d9813",
    "filename": "psqlextra/types.py",
    "source_code": "    @classmethod\n    def all(cls) -> List[\"PostgresPartitioningMethod\"]:\n        return [choice for choice in cls]",
    "target_code": "    <IND>@classmethod\n    def all(cls) -> List[\"StrEnum\"]:\n        <IND>return [choice for choice in cls]\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `List[PostgresPartitioningMethod]` but got `List[StrEnum]`.",
    "warning_line": 11,
    "pred_top-1": {
      "pred": "<IND> @classmethod \n def all(cls) -> List[StrEnum]: \n <IND> return [choice for choice in cls] \n",
      "pred_parsed": "    @classmethod\n    def all(cls) -> List[StrEnum]:\n        return [choice for choice in cls]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<IND> @classmethod \n def all(cls) -> str: \n <IND> return [choice for choice in cls] \n",
      "pred_parsed": "    @classmethod\n    def all(cls) -> str:\n        return [choice for choice in cls]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> @classmethod \n def all(cls) -> List[\"PostgresPartitioningMethod\"]: \n <IND> return [choice for choice in cls] \n",
      "pred_parsed": "    @classmethod\n    def all(cls) -> List[\"PostgresPartitioningMethod\"]:\n        return [choice for choice in cls]\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<IND> @classmethod \n def all(cls) -> List[StrEnum[\"PostgresPartitioningMethod\"]: \n <IND> return [choice for choice in cls] \n",
      "pred_parsed": "    @classmethod\n    def all(cls) -> List[StrEnum[\"PostgresPartitioningMethod\"]:\n        return [choice for choice in cls]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> @classmethod \n def all(cls) -> str: \n <IND> return str([choice for choice in cls]) \n",
      "pred_parsed": "    @classmethod\n    def all(cls) -> str:\n        return str([choice for choice in cls])\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242",
    "filename": "raiden/transfer/channel.py",
    "source_code": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce + 1\n\n    # 0 must not be used since in the netting contract it represents null.\n    return 1",
    "target_code": "    <IND>if end_state.balance_proof:\n        <IND>return Nonce(end_state.balance_proof.nonce + 1)\n\n    # 0 must not be used since in the netting contract it represents null.\n    <DED>return Nonce(1)\n\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `Nonce` but got `int`.",
    "warning_line": 1032,
    "pred_top-1": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        \n        # 0 must not be used since in the netting contract it represents null\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        # 0 must not be used since in the netting contract it represents null\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null. \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        \n        # 0 must not be used since in the netting contract it represents null.\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return nonce(end_state.balance_proof.nonce) + 1 \n # 0 must not be used since in the netting contract it represents null. \n <DED> return 1 \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return nonce(end_state.balance_proof.nonce) + 1\n        # 0 must not be used since in the netting contract it represents null.\n    return 1\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n \n",
      "pred_parsed": "    if end_state.balance_proof:\n        return end_state.balance_proof.nonce(int)\n        \n        # 0 must not be used since in the netting contract it represents null\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "hikari-py/hikari",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/hikari-py-hikari",
    "commit": "cf143052e1228280ed895c06da9177611d8ea088",
    "filename": "hikari/orm/models/roles.py",
    "source_code": "    @property\n    def guild(self) -> _guilds.Guild:\n        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)",
    "target_code": "    <DED>@property\n    def guild(self) -> typing.Union[_guilds.Guild, bases.UnknownObject[_guilds.Guild]]:\n        <IND>return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
    "warning_type": "Incompatible return type [7]",
    "warning_message": " Expected `_guilds.Guild` but got `typing.Union[bases.UnknownObject[_guilds.Guild], _guilds.Guild]`.",
    "warning_line": 133,
    "pred_top-1": {
      "pred": "<DED> @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "pred_parsed": "    @property\n    def guild(self) -> _guilds.Guild:\n        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> @property \n def guild(self) -> typing.Union[_guilds.Guild], _guilds.Guild]: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "pred_parsed": "    @property\n    def guild(self) -> typing.Union[_guilds.Guild], _guilds.Guild]:\n        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> @property \n def guild(self) -> typing.Union[_guilds.Guild, _guilds.Guild]: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "pred_parsed": "    @property\n    def guild(self) -> typing.Union[_guilds.Guild, _guilds.Guild]:\n        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<IND> @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "pred_parsed": "    @property\n    def guild(self) -> _guilds.Guild:\n        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "pred_parsed": "    @property\n    def guild(self) -> _guilds.Guild:\n        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "volatilityfoundation/volatility3",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/volatilityfoundation-volatility3",
    "commit": "8e420cbe62b70d8b9ee2a2cad26399e0df24018e",
    "filename": "volatility/cli/volshell/generic.py",
    "source_code": "        if treegrid is not None:\n            self.render_treegrid(self.generate_treegrid(plugin, **kwargs))",
    "target_code": "        if treegrid is not None:\n            <IND>self.render_treegrid(treegrid)\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `interfaces.renderers.TreeGrid` for 1st positional only parameter to call `Volshell.render_treegrid` but got `Optional[interfaces.renderers.TreeGrid]`.",
    "warning_line": 302,
    "pred_top-1": {
      "pred": "if treegrid is not None: \n <IND> self.render_treegrid(self.generate_treegrid(plugin, **kwargs)) \n \n",
      "pred_parsed": "        if treegrid is not None:\n            self.render_treegrid(self.generate_treegrid(plugin, **kwargs))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "if treegrid is not None: \n <IND> self.render_treegrid(plugin, **kwargs) \n \n",
      "pred_parsed": "        if treegrid is not None:\n            self.render_treegrid(plugin, **kwargs)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "if treegrid is not None: \n <IND> self.render_treegrid(self.generate_treegrid(plugin, kwargs)) \n \n",
      "pred_parsed": "        if treegrid is not None:\n            self.render_treegrid(self.generate_treegrid(plugin, kwargs))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "if treegrid is not None: \n <IND> self.render_treegrid(interfaces.renderers.TreeGrid) \n \n",
      "pred_parsed": "        if treegrid is not None:\n            self.render_treegrid(interfaces.renderers.TreeGrid)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "if treegrid is not None: \n <IND> self.render_treegrid(interfaces.renderers.TreeGrid(plugin, **kwargs)) \n \n",
      "pred_parsed": "        if treegrid is not None:\n            self.render_treegrid(interfaces.renderers.TreeGrid(plugin, **kwargs))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "spesmilo/electrum",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/spesmilo-electrum",
    "commit": "7b18c91b74bbebfe56ba547080ab29775e42feb2",
    "filename": "electrum/lnpeer.py",
    "source_code": "            current_commitment_signature=None,\n            current_htlc_signatures=[],\n        )",
    "target_code": "            current_commitment_signature=None,\n            current_htlc_signatures=b'',\n        )\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `bytes` for 16th parameter `current_htlc_signatures` to call `LocalConfig.__init__` but got `List[Variable[_T]]`.",
    "warning_line": 477,
    "pred_top-1": {
      "pred": "current_commitment_signature=None, \n current_htlc_signatures=bytes, \n ) \n",
      "pred_parsed": "            current_commitment_signature=None,\n            current_htlc_signatures=bytes,\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "current_commitment_signature=None, \n htlc_signatures=bytes, \n ) \n",
      "pred_parsed": "            current_commitment_signature=None,\n            htlc_signatures=bytes,\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "current_commitment_signature=None, \n current_htlc_signatures= Bytes, \n ) \n",
      "pred_parsed": "            current_commitment_signature=None,\n            current_htlc_signatures= Bytes,\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "current_commitment_signature=None, \n current_htlc_signatures= bytes, \n ) \n",
      "pred_parsed": "            current_commitment_signature=None,\n            current_htlc_signatures= bytes,\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "current_commitment_signature=None, \n current_htlc_signatures= Bytes([], \n ) \n",
      "pred_parsed": "            current_commitment_signature=None,\n            current_htlc_signatures= Bytes([],\n            )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "pygae/galgebra",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/pygae-galgebra",
    "commit": "ceacd273cdb095122678af6b1239f2b7b18cd9f4",
    "filename": "galgebra/printer.py",
    "source_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord",
    "target_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord_list = op_ord.split(',')\n    _parser.validate_op_order(op_ord_list)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord_list\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.List[str]` for 1st positional only parameter to call `_parser.validate_op_order` but got `str`.",
    "warning_line": 1205,
    "pred_top-1": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "global _eval_global_dict, _eval_parse_order \n assert op_ord is not None \n op_ord = op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    assert op_ord is not None\n    op_ord = op_ord.split(',')\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "global _eval_global_dict, _eval_parse_order \n assert op_ord is not None \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    assert op_ord is not None\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "global _eval_global_dict, _eval_parse_order \n assert op_ord is not None \n _eval_global_dict = gd \n assert op_ord is not None \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    assert op_ord is not None\n    _eval_global_dict = gd\n    assert op_ord is not None\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "global _eval_global_dict, _eval_parse_order \n op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "pred_parsed": "    global _eval_global_dict, _eval_parse_order\n    op_ord.split(',')\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "volatilityfoundation/volatility3",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/volatilityfoundation-volatility3",
    "commit": "623180ddbda404addc5d46b5e29f93ae233ae446",
    "filename": "volatility/framework/interfaces/configuration.py",
    "source_code": "        obj = self._construct_class(context, config_path, args)\n        if obj is not None:\n            context.symbol_space.append(obj)",
    "target_code": "        <DED><DED>obj = self._construct_class(context, config_path, args)\n        if obj is not None and isinstance(obj, interfaces.symbols.SymbolTableInterface):\n            <IND>context.symbol_space.append(obj)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `interfaces.symbols.BaseSymbolTableInterface` for 1st positional only parameter to call `interfaces.symbols.SymbolSpaceInterface.append` but got `interfaces.objects.ObjectInterface`.",
    "warning_line": 691,
    "pred_top-1": {
      "pred": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and obj is not None: \n <IND> context.symbol_space.append(obj) \n",
      "pred_parsed": "        obj = self._construct_class(context, config_path, args)\n        if obj is not None and obj is not None:\n            context.symbol_space.append(obj)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None: \n <IND> context.symbol_space.append(obj) \n",
      "pred_parsed": "        obj = self._construct_class(context, config_path, args)\n        if obj is not None:\n            context.symbol_space.append(obj)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and not None: \n <IND> context.symbol_space.append(obj) \n",
      "pred_parsed": "        obj = self._construct_class(context, config_path, args)\n        if obj is not None and not None:\n            context.symbol_space.append(obj)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and obj.symbol_space is not None: \n <IND> context.symbol_space.append(obj) \n",
      "pred_parsed": "        obj = self._construct_class(context, config_path, args)\n        if obj is not None and obj.symbol_space is not None:\n            context.symbol_space.append(obj)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None: \n <IND> context.symbol_space.append(obj.SymbolSpaceInterface) \n",
      "pred_parsed": "        obj = self._construct_class(context, config_path, args)\n        if obj is not None:\n            context.symbol_space.append(obj.SymbolSpaceInterface)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "dcs-liberation/dcs_liberation",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation",
    "commit": "db6b6602700abae7c8178c3a99211325a819c787",
    "filename": "gen/kneeboard.py",
    "source_code": "        self.rows.append([\n            waypoint.number,\n            waypoint.waypoint.pretty_name,",
    "target_code": "        <IND>self.rows.append([\n            str(waypoint.number),\n            waypoint.waypoint.pretty_name,\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `List[str]` for 1st positional only parameter to call `list.append` but got `List[typing.Union[int, str]]`.",
    "warning_line": 138,
    "pred_top-1": {
      "pred": "<IND> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n",
      "pred_parsed": "        self.rows.append([\n        waypoint.number,\n        waypoint.waypoint.pretty_name,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n",
      "pred_parsed": "        self.rows.append([\n        waypoint.number,\n        waypoint.waypoint.pretty_name,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<IND> self.rows.append([ \n waypoint.number, <DED> waypoint.waypoint.pretty_name, \n",
      "pred_parsed": "        self.rows.append([\n    waypoint.number,  waypoint.waypoint.pretty_name,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "\n self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n",
      "pred_parsed": "        self.rows.append([\n        waypoint.number,\n        waypoint.waypoint.pretty_name,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<IND> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n ]) \n",
      "pred_parsed": "        self.rows.append([\n        waypoint.number,\n        waypoint.waypoint.pretty_name,\n        ])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "morganstanley/treadmill",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/morganstanley-treadmill",
    "commit": "8a18047886aa6c95e65434706cf141743491ce21",
    "filename": "lib/python/treadmill/psmem.py",
    "source_code": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024",
    "target_code": "# Pagesize in K.\n_PAGESIZE = os.sysconf(os.sysconf_names['SC_PAGE_SIZE']) // 1024\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Union[int, str]` for 1st positional only parameter to call `os.sysconf` but got `bytes`.",
    "warning_line": 24,
    "pred_top-1": {
      "pred": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n \n",
      "pred_parsed": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n <DED>",
      "pred_parsed": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024\n\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE')/ 1024 \n \n",
      "pred_parsed": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE')/ 1024\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n <IND>",
      "pred_parsed": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024\n    \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE')/bytes \n \n",
      "pred_parsed": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE')/bytes\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "huggingface/transformers",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/huggingface-transformers",
    "commit": "7c6d63298f27b4a386f4603262a4603a2a6bf057",
    "filename": "src/transformers/hf_argparser.py",
    "source_code": "            if isinstance(field.type, type) and issubclass(field.type, Enum):\n                kwargs[\"choices\"] = list(field.type)\n                kwargs[\"type\"] = field.type\n                if field.default is not dataclasses.MISSING:",
    "target_code": "            <DED><DED>if isinstance(field.type, type) and issubclass(field.type, Enum):\n                <IND>kwargs[\"choices\"] = [x.value for x in field.type]\n                kwargs[\"type\"] = type(kwargs[\"choices\"][0])\n                if field.default is not dataclasses.MISSING:\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Iterable[Variable[_T]]` for 1st positional only parameter to call `list.__init__` but got `typing.Type[typing.Any]`.",
    "warning_line": 97,
    "pred_top-1": {
      "pred": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = field.type \n if field.default is not dataclasses.MISSING: \n",
      "pred_parsed": "            if isinstance(field.type, type) and issubclass(field.type, Enum):\n                kwargs[\"choices\"] = field.type\n                if field.default is not dataclasses.MISSING:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> <DED> if field.type isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = field.type \n if field.default is not dataclasses.MISSING: \n",
      "pred_parsed": "            if field.type isinstance(field.type, type) and issubclass(field.type, Enum):\n                kwargs[\"choices\"] = field.type\n                if field.default is not dataclasses.MISSING:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = [field.type] \n if field.default is not dataclasses.MISSING: \n",
      "pred_parsed": "            if isinstance(field.type, type) and issubclass(field.type, Enum):\n                kwargs[\"choices\"] = [field.type]\n                if field.default is not dataclasses.MISSING:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = [] \n if field.default is not dataclasses.MISSING: \n",
      "pred_parsed": "            if isinstance(field.type, type) and issubclass(field.type, Enum):\n                kwargs[\"choices\"] = []\n                if field.default is not dataclasses.MISSING:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = args[\"type\"] \n if field.default is not dataclasses.MISSING: \n",
      "pred_parsed": "            if isinstance(field.type, type) and issubclass(field.type, Enum):\n                kwargs[\"choices\"] = args[\"type\"]\n                if field.default is not dataclasses.MISSING:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "dcs-liberation/dcs_liberation",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation",
    "commit": "49aa79c612d8894f2728ed03a9df76f872458d63",
    "filename": "gen/aircraft.py",
    "source_code": "            friendly=flight.from_cp.captured,\n            departure_delay=flight.scheduled_in,\n            departure=departure_runway,",
    "target_code": "            friendly=flight.from_cp.captured,\n            # Set later.\n            departure_delay=timedelta(),\n            departure=departure_runway,\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `timedelta` for 6th parameter `departure_delay` to call `FlightData.__init__` but got `int`.",
    "warning_line": 671,
    "pred_top-1": {
      "pred": "friendly=flight.from_cp.captured, \n departure_delay=Timedelta(flight.scheduled_in), \n departure=departure_runway, \n",
      "pred_parsed": "            friendly=flight.from_cp.captured,\n            departure_delay=Timedelta(flight.scheduled_in),\n            departure=departure_runway,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "friendly=flight.from_cp.captured, \n departure_delay=timedelta(flight.scheduled_in), \n departure=departure_runway, \n",
      "pred_parsed": "            friendly=flight.from_cp.captured,\n            departure_delay=timedelta(flight.scheduled_in),\n            departure=departure_runway,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "friendly=flight.from_cp.captured, \n departure_delay=Timedelta(flight.scheduled_in), \n departure=timedelta(departure_runway), \n",
      "pred_parsed": "            friendly=flight.from_cp.captured,\n            departure_delay=Timedelta(flight.scheduled_in),\n            departure=timedelta(departure_runway),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "friendly=flight.from_cp.captured, \n departure_delay=timedelta(flight.scheduled_in), \n departure=timedelta(departure_runway), \n",
      "pred_parsed": "            friendly=flight.from_cp.captured,\n            departure_delay=timedelta(flight.scheduled_in),\n            departure=timedelta(departure_runway),\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "friendly=flight.from_cp.captured, \n departure_delay=int(flight.scheduled_in), \n departure=departure_runway, \n",
      "pred_parsed": "            friendly=flight.from_cp.captured,\n            departure_delay=int(flight.scheduled_in),\n            departure=departure_runway,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "aa66a4ee225f171c9f2f1d14c33a491507496b40",
    "filename": "raiden/storage/migrations/v18_to_v19.py",
    "source_code": "    snapshot = json.loads(raw_snapshot)\n    block_number = int(snapshot[\"block_number\"])\n    snapshot[\"block_hash\"] = cache.get(block_number)",
    "target_code": "    snapshot = json.loads(raw_snapshot)\n    block_number = BlockNumber(int(snapshot[\"block_number\"]))\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `BlockNumber` for 1st positional only parameter to call `BlockHashCache.get` but got `int`.",
    "warning_line": 127,
    "pred_top-1": {
      "pred": "snapshot = json.loads(raw_snapshot) \n block_number = BlockNumber(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "    snapshot = json.loads(raw_snapshot)\n    block_number = BlockNumber(snapshot[\"block_number\"])\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "snapshot = json.loads(raw_snapshot) \n block_number = block_number(int(snapshot[\"block_number\"])) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "    snapshot = json.loads(raw_snapshot)\n    block_number = block_number(int(snapshot[\"block_number\"]))\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "snapshot = json.loads(raw_snapshot) \n block_number = block_number(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "    snapshot = json.loads(raw_snapshot)\n    block_number = block_number(snapshot[\"block_number\"])\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "snapshot = json.loads(raw_snapshot) \n block_number = block_number_int(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "    snapshot = json.loads(raw_snapshot)\n    block_number = block_number_int(snapshot[\"block_number\"])\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "snapshot = json.loads(raw_snapshot) \n block_number = snapshot[\"block_number\"] \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "    snapshot = json.loads(raw_snapshot)\n    block_number = snapshot[\"block_number\"]\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "nathom/streamrip",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/nathom-streamrip",
    "commit": "fc8f4cee83a04b396e2f172f23d39e345caf36f0",
    "filename": "streamrip/bases.py",
    "source_code": "        if self.client.source == \"qobuz\":\n            if not self.__validate_qobuz_dl_info(dl_info):",
    "target_code": "        <DED>if self.client.source == \"qobuz\":\n            <IND>assert isinstance(dl_info, dict)  # for typing\n            if not self.__validate_qobuz_dl_info(dl_info):\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Dict[typing.Any, typing.Any]` for 1st positional only parameter to call `Track._Track__validate_qobuz_dl_info` but got `Union[typing.Dict[typing.Any, typing.Any], str]`.",
    "warning_line": 205,
    "pred_top-1": {
      "pred": "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n",
      "pred_parsed": "        if self.client.source == \"qobuz\":\n            if not self.__validate_qobuz_dl_info(dl_info):\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> if self.client.source == \"qobuz\": \n <IND> assert isinstance(dl_info, dict) \n if not self.__validate_qobuz_dl_info(dl_info): \n",
      "pred_parsed": "        if self.client.source == \"qobuz\":\n            assert isinstance(dl_info, dict)\n            if not self.__validate_qobuz_dl_info(dl_info):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> if self.client.source == \"qobuz\": \n <IND> assert self.client.source is not None \n if not self.__validate_qobuz_dl_info(dl_info): \n",
      "pred_parsed": "        if self.client.source == \"qobuz\":\n            assert self.client.source is not None\n            if not self.__validate_qobuz_dl_info(dl_info):\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n <IND> assert isinstance(dl_info, str) \n",
      "pred_parsed": "        if self.client.source == \"qobuz\":\n            if not self.__validate_qobuz_dl_info(dl_info):\n                assert isinstance(dl_info, str)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n <IND> assert isinstance(dl_info, dict) \n",
      "pred_parsed": "        if self.client.source == \"qobuz\":\n            if not self.__validate_qobuz_dl_info(dl_info):\n                assert isinstance(dl_info, dict)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "nabla-c0d3/sslyze",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/nabla-c0d3-sslyze",
    "commit": "a9d97c83dc6145535154e7eadd6e5deb33171b7a",
    "filename": "sslyze/plugins/certificate_info/cli_connector.py",
    "source_code": "            if certinfo_ca_file:\n                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))",
    "target_code": "            if certinfo_ca_file:\n                <IND>if not isinstance(certinfo_ca_file, str):\n                    <IND>raise TypeError(f\"Expected a str for certinfo_ca_file but received {certinfo_ca_file}\")\n                <DED>extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Union[os.PathLike[str], str]` for 1st positional only parameter to call `Path.__new__` but got `Union[bool, str]`.",
    "warning_line": 52,
    "pred_top-1": {
      "pred": "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n",
      "pred_parsed": "            if certinfo_ca_file:\n                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "if certinfo_ca_file: \n <IND> assert isinstance(certinfo_ca_file, str) \n extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n",
      "pred_parsed": "            if certinfo_ca_file:\n                assert isinstance(certinfo_ca_file, str)\n                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "if certinfo_ca_file: \n <IND> assert certinfo_ca_file is not None \n extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n",
      "pred_parsed": "            if certinfo_ca_file:\n                assert certinfo_ca_file is not None\n                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n if certinfo_ca_file is not None: \n <IND> return \n",
      "pred_parsed": "            if certinfo_ca_file:\n                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n                if certinfo_ca_file is not None:\n                    return\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n if certinfo_ca_file is not None: \n",
      "pred_parsed": "            if certinfo_ca_file:\n                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n                if certinfo_ca_file is not None:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "aa66a4ee225f171c9f2f1d14c33a491507496b40",
    "filename": "raiden/storage/migrations/v18_to_v19.py",
    "source_code": "            elif \"block_number\" in statechange_data:\n                block_number = int(statechange_data[\"block_number\"])\n                data[\"triggered_by_block_hash\"] = cache.get(block_number)",
    "target_code": "            <DED>elif \"block_number\" in statechange_data:\n                <IND>block_number = BlockNumber(int(statechange_data[\"block_number\"]))\n                data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `BlockNumber` for 1st positional only parameter to call `BlockHashCache.get` but got `int`.",
    "warning_line": 116,
    "pred_top-1": {
      "pred": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = int(statechange_data[\"block_number\"]) \n data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "            elif \"block_number\" in statechange_data:\n                block_number = int(statechange_data[\"block_number\"])\n                data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = statechange_data[\"block_number\"] \n data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "            elif \"block_number\" in statechange_data:\n                block_number = statechange_data[\"block_number\"]\n                data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number_type = int(statechange_data[\"block_number\"]) \n data[\"triggered_by_block_hash\"] = cache.get(block_number_type) \n",
      "pred_parsed": "            elif \"block_number\" in statechange_data:\n                block_number_type = int(statechange_data[\"block_number\"])\n                data[\"triggered_by_block_hash\"] = cache.get(block_number_type)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = statechange_data[\"block_number\"] <DED> data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "            elif \"block_number\" in statechange_data:\n            block_number = statechange_data[\"block_number\"]  data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = statechange_data[\"block_number\"] <IND> data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "pred_parsed": "            elif \"block_number\" in statechange_data:\n                    block_number = statechange_data[\"block_number\"]  data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "huggingface/transformers",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/huggingface-transformers",
    "commit": "1417978cd49181fd08837e7722c34dd5c8c113e3",
    "filename": "src/transformers/feature_extraction_sequence_utils.py",
    "source_code": "        elif return_attention_mask and \"attention_mask\" not in processed_features:\n            processed_features[\"attention_mask\"] = [1] * len(required_input)",
    "target_code": "        <DED><DED>elif return_attention_mask and \"attention_mask\" not in processed_features:\n            <IND>processed_features[\"attention_mask\"] = np.ones(len(required_input), dtype=np.int32)\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `List[float]` for 2nd positional only parameter to call `dict.__setitem__` but got `List[int]`.",
    "warning_line": 301,
    "pred_top-1": {
      "pred": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input) \n \n",
      "pred_parsed": "        elif return_attention_mask and \"attention_mask\" not in processed_features:\n            processed_features[\"attention_mask\"] = [1] * len(required_input)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [0] * len(required_input) \n \n",
      "pred_parsed": "        elif return_attention_mask and \"attention_mask\" not in processed_features:\n            processed_features[\"attention_mask\"] = [0] * len(required_input)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = len(required_input) \n \n",
      "pred_parsed": "        elif return_attention_mask and \"attention_mask\" not in processed_features:\n            processed_features[\"attention_mask\"] = len(required_input)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input) \n \n",
      "pred_parsed": "        elif return_attention_mask and \"attention_mask\" not in processed_features:\n            processed_features[\"attention_mask\"] = [1] * len(required_input)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input, float) \n \n",
      "pred_parsed": "        elif return_attention_mask and \"attention_mask\" not in processed_features:\n            processed_features[\"attention_mask\"] = [1] * len(required_input, float)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "karlicoss/promnesia",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/karlicoss-promnesia",
    "commit": "a88334bb03099d98e841be66c06b137cb9d2b063",
    "filename": "tests/indexer_test.py",
    "source_code": "    import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p) # type: ignore\n    foo = importlib.util.module_from_spec(spec)",
    "target_code": "    <DED>import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p); assert spec is not None\n    foo = importlib.util.module_from_spec(spec)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `importlib.machinery.ModuleSpec` for 1st positional only parameter to call `importlib.util.module_from_spec` but got `typing.Optional[importlib.machinery.ModuleSpec]`.",
    "warning_line": 65,
    "pred_top-1": {
      "pred": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) \n",
      "pred_parsed": "    import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p) # type: ignore\n    foo = importlib.util.module_from_spec(spec)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) \n foo = importlib.util.module_from_spec(spec) \n",
      "pred_parsed": "    import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p)\n    foo = importlib.util.module_from_spec(spec)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n if spec is None: \n <DED> foo = importlib.util.module_from_spec(spec) \n",
      "pred_parsed": "    import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p) # type: ignore\n    if spec is None:\nfoo = importlib.util.module_from_spec(spec)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) <IND>",
      "pred_parsed": "    import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p) # type: ignore\n        foo = importlib.util.module_from_spec(spec)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) <DED>",
      "pred_parsed": "    import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p) # type: ignore\nfoo = importlib.util.module_from_spec(spec)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "python/mypy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy",
    "commit": "994429cdad45d1d33891d9defcf5a9182a4881ce",
    "filename": "mypy/semanal.py",
    "source_code": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([None] + types,\n                             arg_kinds,",
    "target_code": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([cast(Type, None)] + types,\n                             arg_kinds,\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `List[Type]` for 1st positional only parameter to call `Callable.__init__` but got `List[None]`.",
    "warning_line": 1099,
    "pred_top-1": {
      "pred": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([Type] + types, \n arg_kinds, \n",
      "pred_parsed": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([Type] + types,\n        arg_kinds,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = List[Type]([] + types, \n arg_kinds, \n",
      "pred_parsed": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = List[Type]([] + types,\n        arg_kinds,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([types] + types, \n arg_kinds, \n",
      "pred_parsed": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([types] + types,\n        arg_kinds,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([classes] + types, \n arg_kinds, \n",
      "pred_parsed": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([classes] + types,\n        arg_kinds,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([] + types, \n arg_kinds, \n",
      "pred_parsed": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([] + types,\n        arg_kinds,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "Instagram/LibCST",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Instagram-LibCST",
    "commit": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "source_code": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        else:\n            return cst.Annotation(annotation=self._handle_NameOrAttribute(node))",
    "target_code": "            <IND>return cst.Annotation(annotation=self._handle_Subscript(node))\n        <DED>elif isinstance(node, NAME_OR_ATTRIBUTE):\n            <IND>return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n        <DED>else:\n            <IND>raise ValueError(f\"Unexpected annotation node: {node}\")\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Union[cst._nodes.expression.Attribute, cst._nodes.expression.Name]` for 1st positional only parameter to call `TypeCollector._handle_NameOrAttribute` but got `cst._nodes.expression.BaseExpression`.",
    "warning_line": 237,
    "pred_top-1": {
      "pred": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation(annotation=self._handle_NameOrAttribute(node)) \n \n",
      "pred_parsed": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        else:\n            return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation(annotation=NameOrAttribute(node)) \n \n",
      "pred_parsed": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        else:\n            return cst.Annotation(annotation=NameOrAttribute(node))\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<IND> return cst.Annotation((annotation=self._handle_Subscript(node))) \n <DED> else: \n <IND> return cst.Annotation((annotation=self._handle_NameOrAttribute(node))) \n \n",
      "pred_parsed": "            return cst.Annotation((annotation=self._handle_Subscript(node)))\n        else:\n            return cst.Annotation((annotation=self._handle_NameOrAttribute(node)))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation([annotation=self._handle_NameOrAttribute(node)]) \n \n",
      "pred_parsed": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        else:\n            return cst.Annotation([annotation=self._handle_NameOrAttribute(node)])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation((annotation=self._handle_NameOrAttribute(node))) \n \n",
      "pred_parsed": "            return cst.Annotation(annotation=self._handle_Subscript(node))\n        else:\n            return cst.Annotation((annotation=self._handle_NameOrAttribute(node)))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "chanzuckerberg/miniwdl",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/chanzuckerberg-miniwdl",
    "commit": "1b3f26c69b306c12226eaa02145072af0de12839",
    "filename": "WDL/Expr.py",
    "source_code": "                k.typecheck(kty)\n            if vty is None or vty == T.Array(T.Any()) or vty == T.Map(None):\n                vty = v.type",
    "target_code": "                <IND>k.typecheck(kty)\n            <DED>if vty is None or vty == T.Array(T.Any()) or vty == T.Map((T.Any(), T.Any())):\n                <IND>vty = v.type\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Tuple[T.Base, T.Base]` for 1st positional only parameter to call `T.Map.__init__` but got `None`.",
    "warning_line": 445,
    "pred_top-1": {
      "pred": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()): \n <IND> vty = v.type \n",
      "pred_parsed": "                k.typecheck(kty)\n            if vty is None or vty == T.Array(T.Any()):\n                vty = v.type\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Equal(0)): \n <IND> vty = v.type \n",
      "pred_parsed": "                k.typecheck(kty)\n            if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Equal(0)):\n                vty = v.type\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Any()): \n <IND> vty = v.type \n",
      "pred_parsed": "                k.typecheck(kty)\n            if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Any()):\n                vty = v.type\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> k.typecheck(kty) \n <DED> if vty == None: \n <IND> vty = v.type \n",
      "pred_parsed": "                k.typecheck(kty)\n            if vty == None:\n                vty = v.type\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Equal): \n <IND> vty = v.type \n",
      "pred_parsed": "                k.typecheck(kty)\n            if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Equal):\n                vty = v.type\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "raiden-network/raiden",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/raiden-network-raiden",
    "commit": "99fbd1b7b94ee98f764e021c04d967333467a6e6",
    "filename": "raiden/raiden_service.py",
    "source_code": "        to_address=from_transfer.target,\n        amount=from_transfer.lock.amount,\n        previous_address=transfer.sender,",
    "target_code": "        to_address=from_transfer.target,\n        amount=PaymentAmount(from_transfer.lock.amount),  # FIXME: mypy; deprecated through #3863\n        previous_address=transfer.sender,\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `PaymentAmount` for 5th parameter `amount` to call `routing.get_best_routes` but got `raiden.utils.typing.PaymentWithFeeAmount`.",
    "warning_line": 164,
    "pred_top-1": {
      "pred": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount, \n previous_address=transfer.sender, \n",
      "pred_parsed": "        to_address=from_transfer.target,\n        amount=from_transfer.lock.amount,\n        previous_address=transfer.sender,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount, \n previous_address=from_transfer.sender, \n",
      "pred_parsed": "        to_address=from_transfer.target,\n        amount=from_transfer.lock.amount,\n        previous_address=from_transfer.sender,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount \n previous_address=transfer.sender, \n",
      "pred_parsed": "        to_address=from_transfer.target,\n        amount=from_transfer.lock.amount\n        previous_address=transfer.sender,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount <DED> previous_address=transfer.sender, \n",
      "pred_parsed": "        to_address=from_transfer.target,\n    amount=from_transfer.lock.amount  previous_address=transfer.sender,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount <IND> previous_address=transfer.sender, \n",
      "pred_parsed": "        to_address=from_transfer.target,\n            amount=from_transfer.lock.amount  previous_address=transfer.sender,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "dcs-liberation/dcs_liberation",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation",
    "commit": "db6b6602700abae7c8178c3a99211325a819c787",
    "filename": "gen/kneeboard.py",
    "source_code": "              headers: Optional[List[str]] = None) -> None:\n        table = tabulate(cells, headers=headers, numalign=\"right\")",
    "target_code": "              headers: Optional[List[str]] = None) -> None:\n        <IND>if headers is None:\n            <IND>headers = []\n        <DED>table = tabulate(cells, headers=headers, numalign=\"right\")\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Union[Dict[str, str], typing.Sequence[str], str]` for 2nd parameter `headers` to call `tabulate` but got `Optional[List[str]]`.",
    "warning_line": 85,
    "pred_top-1": {
      "pred": "headers: Optional[List[str]] = None) -> None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "pred_parsed": "              headers: Optional[List[str]] = None) -> None:\n                  table = tabulate(cells, headers=headers, numalign=\"right\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "headers: Optional[List[str]] = None) -> None: \n <IND> list = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "pred_parsed": "              headers: Optional[List[str]] = None) -> None:\n                  list = tabulate(cells, headers=headers, numalign=\"right\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "headers: Optional[List[str]] = None) -> None: \n <IND> cell = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "pred_parsed": "              headers: Optional[List[str]] = None) -> None:\n                  cell = tabulate(cells, headers=headers, numalign=\"right\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "headers: List[str] = None) -> None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "pred_parsed": "              headers: List[str] = None) -> None:\n                  table = tabulate(cells, headers=headers, numalign=\"right\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "headers: Optional[List[str]] = None) -> None: \n <IND> if headers is None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "pred_parsed": "              headers: Optional[List[str]] = None) -> None:\n                  if headers is None:\n                      table = tabulate(cells, headers=headers, numalign=\"right\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "tribe29/checkmk",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/tribe29-checkmk",
    "commit": "ba8be4ea9b9232e49d0fdb248113f391e159f8ee",
    "filename": "cmk/base/plugins/agent_based/logwatch_ec.py",
    "source_code": "    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write(\n        ('\\n'.join(messages) + '\\n').encode(\"utf-8\"))\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))",
    "target_code": "\n    with open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\") as f:\n        <IND>f.write('\\n'.join(messages) + '\\n')\n    <DED>os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `str` for 1st positional only parameter to call `io.TextIOBase.write` but got `bytes`.",
    "warning_line": 419,
    "pred_top-1": {
      "pred": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n",
      "pred_parsed": "    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write(\n    (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\")\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\")).write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n",
      "pred_parsed": "    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\")).write(\n    (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\")\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]) \n",
      "pred_parsed": "    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write(\n    (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\")\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n'\\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n",
      "pred_parsed": "    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write(\n    '\\ n'.join(messages) +'\\ n').encode(\"utf-8\")\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\")).write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]) \n",
      "pred_parsed": "    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\")).write(\n    (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\")\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "PyCQA/astroid",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/PyCQA-astroid",
    "commit": "2c9c187b1c47adc4661246b922e3a41dc0756396",
    "filename": "astroid/builder.py",
    "source_code": "def build_namespace_package_module(name, path: str) -> nodes.Module:\n    return nodes.Module(name, doc=\"\", path=path, package=True)",
    "target_code": "\n<DED><DED><DED>def build_namespace_package_module(name: str, path: List[str]) -> nodes.Module:\n    <IND>return nodes.Module(name, doc=\"\", path=path, package=True)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Optional[List[str]]` for 3rd parameter `path` to call `nodes.scoped_nodes.Module.__init__` but got `str`.",
    "warning_line": 267,
    "pred_top-1": {
      "pred": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "pred_parsed": "def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module:\n    return nodes.Module(name, doc=\"\", path=path, package=True)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: List[str]) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "pred_parsed": "def build_namespace_package_module(name, path: List[str]) -> nodes.Module:\n    return nodes.Module(name, doc=\"\", path=path, package=True)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module: \n <IND> return nodes.Module(name, path=\"\", path=path, package=True) \n",
      "pred_parsed": "def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module:\n    return nodes.Module(name, path=\"\", path=path, package=True)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: str) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "pred_parsed": "def build_namespace_package_module(name, path: str) -> nodes.Module:\n    return nodes.Module(name, doc=\"\", path=path, package=True)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n <DED> <DED> <DED> def build_namespace_package_module(name, str) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "pred_parsed": "def build_namespace_package_module(name, str) -> nodes.Module:\n    return nodes.Module(name, doc=\"\", path=path, package=True)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "electrumsv/electrumsv",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/electrumsv-electrumsv",
    "commit": "9154a84d48a81ec19f6787cec6e9bf1a94a5e025",
    "filename": "electrumsv/tests/test_wallet_database_tables.py",
    "source_code": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n        DERIVATION_DATA1, None, 0, None)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n        DERIVATION_DATA2, None, 0, None)",
    "target_code": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n        DERIVATION_DATA1, None, KeyInstanceFlag.NONE, None)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n        DERIVATION_DATA2, None, KeyInstanceFlag.NONE, None)\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `KeyInstanceFlag` for 7th positional only parameter to call `KeyInstanceRow.__init__` but got `int`.",
    "warning_line": 280,
    "pred_top-1": {
      "pred": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, 0) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n",
      "pred_parsed": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n    DERIVATION_DATA2, None, 0)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n    DERIVATION_DATA2, None, 0)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, None) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, None) \n \n",
      "pred_parsed": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n    DERIVATION_DATA2, None, None)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n    DERIVATION_DATA2, None, None)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, None) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n",
      "pred_parsed": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n    DERIVATION_DATA2, None, None)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n    DERIVATION_DATA2, None, 0)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, KeyInstanceFlag.NONE) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, KeyInstanceFlag.NONE, None) \n",
      "pred_parsed": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n    DERIVATION_DATA2, None, KeyInstanceFlag.NONE)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n    DERIVATION_DATA2, None, KeyInstanceFlag.NONE, None)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA1, None, 0) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n",
      "pred_parsed": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n    DERIVATION_DATA1, None, 0)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n    DERIVATION_DATA2, None, 0)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "deepset-ai/haystack",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/deepset-ai-haystack",
    "commit": "9c409e00127fd21072b74779431277e8338dd71b",
    "filename": "haystack/basics/modeling/prediction_head.py",
    "source_code": "        if os.path.exists(pretrained_model_name_or_path)                and \"config.json\" in pretrained_model_name_or_path                and \"prediction_head\" in pretrained_model_name_or_path:\n            # a) FARM style\n            super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path)\n        else:",
    "target_code": "        if os.path.exists(pretrained_model_name_or_path)                and \"config.json\" in str(pretrained_model_name_or_path)                and \"prediction_head\" in str(pretrained_model_name_or_path):\n            # a) FARM style\n            <IND>super(QuestionAnsweringHead, cls).load(str(pretrained_model_name_or_path))\n        <DED>else:\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `str` for 1st positional only parameter to call `PredictionHead.load` but got `Union[Path, str]`.",
    "warning_line": 297,
    "exception": "'pred_top-1'"
  },
  {
    "repo": "obsei/obsei",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/obsei-obsei",
    "commit": "f668a90b1ac8cebbbd72d4f02184bba3fa0ecd3c",
    "filename": "obsei/source/reddit_scrapper.py",
    "source_code": "        last_index = since_id\n        state[config.url_id] = scrapper_stat",
    "target_code": "        last_index = since_id\n        if config.url_id:\n            <IND>state[config.url_id] = scrapper_stat\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `str` for 1st positional only parameter to call `dict.__setitem__` but got `Optional[str]`.",
    "warning_line": 69,
    "pred_top-1": {
      "pred": "last_index = since_id \n state[str] = scrapper_stat \n \n",
      "pred_parsed": "        last_index = since_id\n        state[str] = scrapper_stat\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "last_index = since_id \n state[str, config.url_id] = scrapper_stat \n \n",
      "pred_parsed": "        last_index = since_id\n        state[str, config.url_id] = scrapper_stat\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "last_index = since_id \n state[str_id] = scrapper_stat \n \n",
      "pred_parsed": "        last_index = since_id\n        state[str_id] = scrapper_stat\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "last_index = since_id \n state[str] = config.url_id \n \n",
      "pred_parsed": "        last_index = since_id\n        state[str] = config.url_id\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "last_index = since_id \n state[str] = dict.__setitem__(str) \n \n",
      "pred_parsed": "        last_index = since_id\n        state[str] = dict.__setitem__(str)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "bczsalba/pytermgui",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/bczsalba-pytermgui",
    "commit": "591f99dcc2b7c2d07dde9a3c6fb3a574354a2a37",
    "filename": "pytermgui/widgets/base.py",
    "source_code": "            if widget.handle_mouse(event, target):\n                self.select(i + widget.mouse_targets.index(target))",
    "target_code": "            if widget.handle_mouse(event, target):\n                <IND>assert isinstance(target, MouseTarget)\n                self.select(i + widget.mouse_targets.index(target))\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `MouseTarget` for 1st positional only parameter to call `list.index` but got `Optional[MouseTarget]`.",
    "warning_line": 956,
    "pred_top-1": {
      "pred": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target)) \n",
      "pred_parsed": "            if widget.handle_mouse(event, target):\n                self.select(i + widget.mouse_targets.index(target))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets[target]) \n",
      "pred_parsed": "            if widget.handle_mouse(event, target):\n                self.select(i + widget.mouse_targets[target])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(event, target)) \n",
      "pred_parsed": "            if widget.handle_mouse(event, target):\n                self.select(i + widget.mouse_targets.index(event, target))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target.target)) \n",
      "pred_parsed": "            if widget.handle_mouse(event, target):\n                self.select(i + widget.mouse_targets.index(target.target))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target.index)) \n",
      "pred_parsed": "            if widget.handle_mouse(event, target):\n                self.select(i + widget.mouse_targets.index(target.index))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "borglab/gtsfm",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/borglab-gtsfm",
    "commit": "26f76a40e21bd082123f275404efca964faa59b9",
    "filename": "gtsfm/averaging/rotation/cycle_consistency.py",
    "source_code": "        cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n            i2Ri1_dict, [i0, i1, i2], two_view_reports_dict\n        )",
    "target_code": "        <IND>cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n            i2Ri1_dict, (i0, i1, i2), two_view_reports_dict\n        )\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Tuple[int, int, int]` for 2nd positional only parameter to call `compute_cycle_error` but got `List[int]`.",
    "warning_line": 201,
    "pred_top-1": {
      "pred": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], two_view_reports_dict \n ) \n",
      "pred_parsed": "        cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n        i2Ri1_dict, [i0, i1, i2], two_view_reports_dict\n        )\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], list(two_view_reports_dict) \n ) \n",
      "pred_parsed": "        cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n        i2Ri1_dict, [i0, i1, i2], list(two_view_reports_dict)\n        )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2] \n ) \n",
      "pred_parsed": "        cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n        i2Ri1_dict, [i0, i1, i2]\n        )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, List[int, int], two_view_reports_dict \n ) \n",
      "pred_parsed": "        cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n        i2Ri1_dict, List[int, int], two_view_reports_dict\n        )\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], list[two_view_reports_dict] \n ) \n",
      "pred_parsed": "        cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n        i2Ri1_dict, [i0, i1, i2], list[two_view_reports_dict]\n        )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "edgedb/edgedb",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/edgedb-edgedb",
    "commit": "784f8eb8181cb7f0e01f16202f28f39af243612d",
    "filename": "edb/server/http_graphql_port/compiler.py",
    "source_code": "            ir,\n            pretty=debug.flags.edgeql_compile,\n            expected_cardinality_one=True,",
    "target_code": "            ir,\n            pretty=bool(debug.flags.edgeql_compile),\n            expected_cardinality_one=True,\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `bool` for 2nd parameter `pretty` to call `pg_compiler.compile_ir_to_sql` but got `debug.Flag`.",
    "warning_line": 112,
    "pred_top-1": {
      "pred": "ir, \n pretty=debug.flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "pred_parsed": "            ir,\n            pretty=debug.flags.edgeql_compile,\n            expected_cardinality_one=True,\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "ir, \n pretty=debug.Flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "pred_parsed": "            ir,\n            pretty=debug.Flags.edgeql_compile,\n            expected_cardinality_one=True,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "ir, \n pretty=bool=debug.flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "pred_parsed": "            ir,\n            pretty=bool=debug.flags.edgeql_compile,\n            expected_cardinality_one=True,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "ir, \n pretty=bool(debug.flags.edgeql_compile), \n expected_cardinality_one=True, \n",
      "pred_parsed": "            ir,\n            pretty=bool(debug.flags.edgeql_compile),\n            expected_cardinality_one=True,\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "ir, \n pretty=Debug.Flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "pred_parsed": "            ir,\n            pretty=Debug.Flags.edgeql_compile,\n            expected_cardinality_one=True,\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "amor71/LiuAlgoTrader",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/amor71-LiuAlgoTrader",
    "commit": "64ac5f544cd9fc7191ddc14a265e0f4ce1a89100",
    "filename": "liualgotrader/consumer.py",
    "source_code": "                    symbol=symbol,\n                    qty=str(-symbol_position),\n                    side=\"buy\",",
    "target_code": "                    symbol=symbol,\n                    qty=-symbol_position,\n                    side=\"buy\",\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `int` for 2nd parameter `qty` to call `Trader.submit_order` but got `str`.",
    "warning_line": 241,
    "pred_top-1": {
      "pred": "symbol=symbol, \n qty=int(-symbol_position), \n side=\"buy\", \n",
      "pred_parsed": "                    symbol=symbol,\n                    qty=int(-symbol_position),\n                    side=\"buy\",\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "symbol=symbol, \n qty=Int(-symbol_position), \n side=\"buy\", \n",
      "pred_parsed": "                    symbol=symbol,\n                    qty=Int(-symbol_position),\n                    side=\"buy\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "symbol=symbol, \n qty=int((-symbol_position)), \n side=\"buy\", \n",
      "pred_parsed": "                    symbol=symbol,\n                    qty=int((-symbol_position)),\n                    side=\"buy\",\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "symbol=symbol, \n qty=int(symbol_position), \n side=\"buy\", \n",
      "pred_parsed": "                    symbol=symbol,\n                    qty=int(symbol_position),\n                    side=\"buy\",\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "symbol=symbol, \n qty=int(str(-symbol_position)), \n side=\"buy\", \n",
      "pred_parsed": "                    symbol=symbol,\n                    qty=int(str(-symbol_position)),\n                    side=\"buy\",\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "ilcardella/TradingBot",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ilcardella-TradingBot",
    "commit": "d835f8b3955783b4b4ad5d4fbea44459b7fdd7fd",
    "filename": "tradingbot/Strategies/SimpleMACD.py",
    "source_code": "        return self.broker.get_macd(market, Interval.DAY, None)",
    "target_code": "\n        return self.broker.get_macd(market, Interval.DAY, 30)\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `int` for 3rd positional only parameter to call `Broker.get_macd` but got `None`.",
    "warning_line": 47,
    "pred_top-1": {
      "pred": "\n return self.broker.get_macd(market, Interval.DAY, []) \n \n",
      "pred_parsed": "        return self.broker.get_macd(market, Interval.DAY, [])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n return broker.get_macd(market, Interval.DAY, []) \n \n",
      "pred_parsed": "        return broker.get_macd(market, Interval.DAY, [])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n return self.broker.get_macd(market, Interval.DAY, '') \n \n",
      "pred_parsed": "        return self.broker.get_macd(market, Interval.DAY, '')\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n return self.broker.get_macd(market, Interval.DAY, \"\") \n \n",
      "pred_parsed": "        return self.broker.get_macd(market, Interval.DAY, \"\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n return self.broker.get_macd(market, Interval.DAY, [0], None) \n \n",
      "pred_parsed": "        return self.broker.get_macd(market, Interval.DAY, [0], None)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "edgedb/edgedb",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/edgedb-edgedb",
    "commit": "b1eec7ed6a649a16127f66447b9df8026854e9b4",
    "filename": "edb/edgeql/compiler/viewgen.py",
    "source_code": "    if link_view:\n        sources.append(rptrcls)",
    "target_code": "    <DED>if link_view:\n        <IND>assert rptrcls is not None\n        sources.append(rptrcls)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Union[s_pointers.Pointer, s_pointers.PseudoPointer, s_types.Type]` for 1st positional only parameter to call `list.append` but got `typing.Union[None, s_pointers.Pointer, s_pointers.PseudoPointer]`.",
    "warning_line": 1156,
    "pred_top-1": {
      "pred": "<DED> if link_view: \n <IND> assert link_view is not None \n sources.append(rptrcls) \n",
      "pred_parsed": "    if link_view:\n        assert link_view is not None\n        sources.append(rptrcls)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> if link_view: \n <IND> assert isinstance(s_pointers.Pointer, s_pointers.PseudoPointer, s_types.Type) \n sources.append(rptrcls) \n",
      "pred_parsed": "    if link_view:\n        assert isinstance(s_pointers.Pointer, s_pointers.PseudoPointer, s_types.Type)\n        sources.append(rptrcls)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> if link_view: \n <IND> assert isinstance(rptrcls, s_pointers.Pointer, s_pointers.PseudoPointer) \n sources.append(rptrcls) \n",
      "pred_parsed": "    if link_view:\n        assert isinstance(rptrcls, s_pointers.Pointer, s_pointers.PseudoPointer)\n        sources.append(rptrcls)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> if link_view: \n <IND> assert isinstance(s_pointers.Pointer, s_pointers.PseudoPointer) \n sources.append(rptrcls) \n",
      "pred_parsed": "    if link_view:\n        assert isinstance(s_pointers.Pointer, s_pointers.PseudoPointer)\n        sources.append(rptrcls)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> if link_view: \n <IND> assert isinstance(rptrcls, s_pointers.Pointer) \n sources.append(rptrcls) \n",
      "pred_parsed": "    if link_view:\n        assert isinstance(rptrcls, s_pointers.Pointer)\n        sources.append(rptrcls)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "deepmipt/DeepPavlov",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/deepmipt-DeepPavlov",
    "commit": "1de404c11bc5f40b766e966573506921980ff524",
    "filename": "deeppavlov/skills/ecommerce_bot/bot.py",
    "source_code": "        log.info(f\"Saving model to {self.save_path}\")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, self.save_path)",
    "target_code": "        log.info(f\"Saving model to {self.save_path}\")\n        save_pickle(self.ec_data, self.save_path)\n\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Dict[typing.Any, typing.Any]` for 1st positional only parameter to call `save_pickle` but got `List[typing.Any]`.",
    "warning_line": 86,
    "pred_top-1": {
      "pred": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path)) \n \n",
      "pred_parsed": "        log.info(f\"Saving model to { self.save_path } \")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, list(self.save_path))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, List[save_path]) \n \n",
      "pred_parsed": "        log.info(f\"Saving model to { self.save_path } \")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, List[save_path])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path, [])) \n \n",
      "pred_parsed": "        log.info(f\"Saving model to { self.save_path } \")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, list(self.save_path, []))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, List[self.save_path]) \n \n",
      "pred_parsed": "        log.info(f\"Saving model to { self.save_path } \")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, List[self.save_path])\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path, List[str, str])) \n \n",
      "pred_parsed": "        log.info(f\"Saving model to { self.save_path } \")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, list(self.save_path, List[str, str]))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "rotki/rotki",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/rotki-rotki",
    "commit": "b763072c34b7f9d444fc042c460c93b458c8c282",
    "filename": "rotkehlchen/blockchain.py",
    "source_code": "        self.owned_eth_tokens.extend(tokens)\n        self.query_ethereum_tokens(tokens, self.balances[S_ETH])\n        return {'per_account': self.balances, 'totals': self.totals}",
    "target_code": "        <DED>self.owned_eth_tokens.extend(tokens)\n        eth_balances = cast(EthBalances, self.balances[S_ETH])\n        self.query_ethereum_tokens(tokens, eth_balances)\n        return {'per_account': self.balances, 'totals': self.totals}\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Dict[typing.EthAddress, Dict[Union[str, typing.EthToken, typing.NonEthTokenBlockchainAsset], FVal]]` for 2nd positional only parameter to call `Blockchain.query_ethereum_tokens` but got `Dict[Union[typing.BTCAddress, typing.EthAddress], Dict[Union[str, typing.EthToken, typing.FiatAsset, typing.NonEthTokenBlockchainAsset], FVal]]`.",
    "warning_line": 131,
    "pred_top-1": {
      "pred": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, self.balances[S_ETH]) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "pred_parsed": "        self.owned_eth_tokens.extend(tokens)\n        self.query_ethereum_tokens(tokens, self.balances[S_ETH])\n        return { 'per_account': self.balances, 'totals': self.totals }\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, tokens.balances[S_ETH]) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "pred_parsed": "        self.owned_eth_tokens.extend(tokens)\n        self.query_ethereum_tokens(tokens, tokens.balances[S_ETH])\n        return { 'per_account': self.balances, 'totals': self.totals }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, tokens) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "pred_parsed": "        self.owned_eth_tokens.extend(tokens)\n        self.query_ethereum_tokens(tokens, tokens)\n        return { 'per_account': self.balances, 'totals': self.totals }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "pred_parsed": "        self.owned_eth_tokens.extend(tokens)\n        self.query_ethereum_tokens(tokens)\n        return { 'per_account': self.balances, 'totals': self.totals }\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> self.owned_eth_tokens.extend(tokens) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "pred_parsed": "        self.owned_eth_tokens.extend(tokens)\n        return { 'per_account': self.balances, 'totals': self.totals }\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "tribe29/checkmk",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/tribe29-checkmk",
    "commit": "584089be5d0a9ff7e70015a4a54e4dc8e7b8eaaf",
    "filename": "cmk/base/plugins/agent_based/checkpoint_connections.py",
    "source_code": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=[3])],\n)",
    "target_code": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=['3'])],\n)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.List[typing.Union[cmk.base.api.agent_based.section_types.OIDEnd, cmk.base.snmp_utils.OIDSpec, str]]` for 2nd parameter `oids` to call `cmk.base.api.agent_based.section_types.SNMPTree.__init__` but got `typing.List[int]`.",
    "warning_line": 23,
    "pred_top-1": {
      "pred": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int]]], \n ) \n",
      "pred_parsed": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int]]],\n    )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\")], \n ) \n",
      "pred_parsed": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\")],\n    )\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\"], oids=typing.List[int]]], \n ) \n",
      "pred_parsed": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\"], oids=typing.List[int]]],\n    )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int])], \n ) \n",
      "pred_parsed": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int])],\n    )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\"], oids=typing.List[int]], \n ) \n",
      "pred_parsed": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\"], oids=typing.List[int]],\n    )\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "argoai/argoverse-api",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/argoai-argoverse-api",
    "commit": "c8ff45fb6a50e0a6e1f1355a9ce9aafdfa8dfcf3",
    "filename": "tests/test_frustum_clipping.py",
    "source_code": "    fx = 10.0\n    img_height = 45.0\n    top_plane = form_top_clipping_plane(fx, img_height)",
    "target_code": "    fx = 10.0\n    img_height = 45\n    top_plane = form_top_clipping_plane(fx, img_height)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `int` for 2nd positional only parameter to call `form_top_clipping_plane` but got `float`.",
    "warning_line": 210,
    "pred_top-1": {
      "pred": "fx = 10.0 \n img_height = 40 \n top_plane = form_top_clipping_plane(fx, img_height) \n",
      "pred_parsed": "    fx = 10.0\n    img_height = 40\n    top_plane = form_top_clipping_plane(fx, img_height)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "fx = 10.0 \n img_height = 45 \n top_plane = form_top_clipping_plane(fx, img_height) \n",
      "pred_parsed": "    fx = 10.0\n    img_height = 45\n    top_plane = form_top_clipping_plane(fx, img_height)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "fx = 10.0 \n img_height = 45.0 \n top_plane = form_top_clipping_plane(fx, int(img_height)) \n",
      "pred_parsed": "    fx = 10.0\n    img_height = 45.0\n    top_plane = form_top_clipping_plane(fx, int(img_height))\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "fx = 10.0 \n img_height = 40 \n top_plane = form_top_clipping_plane(fx, int(img_height)) \n",
      "pred_parsed": "    fx = 10.0\n    img_height = 40\n    top_plane = form_top_clipping_plane(fx, int(img_height))\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "fx = 10.0 \n img_height = 45.0 \n top_plane = form_top_clipping_plane(fx, img_height) \n",
      "pred_parsed": "    fx = 10.0\n    img_height = 45.0\n    top_plane = form_top_clipping_plane(fx, img_height)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "QCoDeS/Qcodes",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/QCoDeS-Qcodes",
    "commit": "5981d9cc37ea0abbcecd0153a884fe8a80cd573e",
    "filename": "qcodes/station.py",
    "source_code": "            for filename in filenames:\n                path = self._get_config_file_path(filename)",
    "target_code": "            for filename in filenames:\n                <IND>assert isinstance(filename, str)\n                path = self._get_config_file_path(filename)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Optional[str]` for 1st positional only parameter to call `Station._get_config_file_path` but got `List[str]`.",
    "warning_line": 356,
    "pred_top-1": {
      "pred": "for filename in filenames: \n <IND> assert filename is not None \n path = self._get_config_file_path(filename) \n",
      "pred_parsed": "            for filename in filenames:\n                assert filename is not None\n                path = self._get_config_file_path(filename)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "for filename in filenames: \n <IND> assert filename is not None \n filename = self._get_config_file_path(filename) \n",
      "pred_parsed": "            for filename in filenames:\n                assert filename is not None\n                filename = self._get_config_file_path(filename)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "for filename in filenames: \n <IND> assert filename is not None, filename = self._get_config_file_path(filename) \n assert filename is not None \n path = self._get_config_file_path(filename) \n",
      "pred_parsed": "            for filename in filenames:\n                assert filename is not None, filename = self._get_config_file_path(filename)\n                assert filename is not None\n                path = self._get_config_file_path(filename)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "for filename in filenames: \n <IND> str = self._get_config_file_path(filename) \n",
      "pred_parsed": "            for filename in filenames:\n                str = self._get_config_file_path(filename)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "for filename in filenames: \n <IND> assert filename is not None, filename = self._get_config_file_path(filename) \n assert filename is not None \n return self._get_config_file_path(filename) \n",
      "pred_parsed": "            for filename in filenames:\n                assert filename is not None, filename = self._get_config_file_path(filename)\n                assert filename is not None\n                return self._get_config_file_path(filename)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "lykoss/lykos",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/lykoss-lykos",
    "commit": "3b3870c9f365944134225c5b7364430c5bce0158",
    "filename": "src/roles/madscientist.py",
    "source_code": "    for ms in get_all_players(var, (\"mad scientist\",)):\n        pl = get_players(var)\n        target1, target2 = _get_targets(var, pl, ms)",
    "target_code": "    <IND>for ms in get_all_players(var, (\"mad scientist\",)):\n        <IND>pl = get_all_players(var)\n        target1, target2 = _get_targets(var, pl, ms)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Set[User]` for 2nd positional only parameter to call `_get_targets` but got `typing.List[User]`.",
    "warning_line": 88,
    "pred_top-1": {
      "pred": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, pl, ms) \n",
      "pred_parsed": "    for ms in get_all_players(var, (\"mad scientist\",)):\n        pl = get_players(var)\n        target1, target2 = _get_targets(var, pl, ms)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, ms) \n",
      "pred_parsed": "    for ms in get_all_players(var, (\"mad scientist\",)):\n        pl = get_players(var)\n        target1, target2 = _get_targets(var, ms)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, pl, ms) \n",
      "pred_parsed": "    for ms in get_all_players(var, (\"mad scientist\",)):\n        pl = get_players(var)\n        target1, target2 = _get_targets(var, pl, ms)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = set(_get_targets(var, pl, ms)) \n",
      "pred_parsed": "    for ms in get_all_players(var, (\"mad scientist\",)):\n        pl = get_players(var)\n        target1, target2 = set(_get_targets(var, pl, ms))\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, _get_targets(var, pl, ms) \n",
      "pred_parsed": "    for ms in get_all_players(var, (\"mad scientist\",)):\n        pl = get_players(var)\n        target1, target2 = _get_targets(var, _get_targets(var, pl, ms)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "crownpku/Rasa_NLU_Chi",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/crownpku-Rasa_NLU_Chi",
    "commit": "f55804e5cc46f21d73e82374a57f71a48a24fb12",
    "filename": "rasa_nlu/model.py",
    "source_code": "        return Interpreter(self.pipeline, context=init_context, config=self.config)",
    "target_code": "\n        <DED><DED>return Interpreter(self.pipeline, context=init_context, config=self.config.as_dict())\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Dict[str, typing.Any]` for 3rd parameter `config` to call `Interpreter.__init__` but got `RasaNLUConfig`.",
    "warning_line": 190,
    "pred_top-1": {
      "pred": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config) \n \n",
      "pred_parsed": "        return Interpreter(self.pipeline, context=init_context, config=self.config)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> <DED> return Interpreter(self.pipeline, context=Init_context, config=self.config) \n \n",
      "pred_parsed": "        return Interpreter(self.pipeline, context=Init_context, config=self.config)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config, 0) \n \n",
      "pred_parsed": "        return Interpreter(self.pipeline, context=init_context, config=self.config, 0)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config) \n <DED>",
      "pred_parsed": "        return Interpreter(self.pipeline, context=init_context, config=self.config)\n    \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config).decode() \n \n",
      "pred_parsed": "        return Interpreter(self.pipeline, context=init_context, config=self.config).decode()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "flairNLP/flair",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/flairNLP-flair",
    "commit": "4ac18961c3c85b54f0fb5c4f2ea82fc0a4471402",
    "filename": "flair/models/diagnosis/distance_prediction_model.py",
    "source_code": "        for idx, conf in enumerate(softmax):\n            label_probs.append(Label(idx, conf.item()))\n        return label_probs",
    "target_code": "        for idx, conf in enumerate(softmax):\n            <IND>label_probs.append(Label(str(idx), conf.item()))\n        <DED>return label_probs\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `str` for 1st positional only parameter to call `Label.__init__` but got `int`.",
    "warning_line": 488,
    "pred_top-1": {
      "pred": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, conf.item())) \n <DED> return label_probs \n",
      "pred_parsed": "        for idx, conf in enumerate(softmax):\n            label_probs.append(Label(idx, conf.item()))\n        return label_probs\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, str(conf.item()))) \n <DED> return label_probs \n",
      "pred_parsed": "        for idx, conf in enumerate(softmax):\n            label_probs.append(Label(idx, str(conf.item())))\n        return label_probs\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Str(Label(idx, conf.item()))) \n <DED> return label_probs \n",
      "pred_parsed": "        for idx, conf in enumerate(softmax):\n            label_probs.append(Str(Label(idx, conf.item())))\n        return label_probs\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, conf.item())) \n <IND> return label_probs \n",
      "pred_parsed": "        for idx, conf in enumerate(softmax):\n            label_probs.append(Label(idx, conf.item()))\n                return label_probs\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Int(Label(idx, conf.item()))) \n <DED> return label_probs \n",
      "pred_parsed": "        for idx, conf in enumerate(softmax):\n            label_probs.append(Int(Label(idx, conf.item())))\n        return label_probs\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "samschott/maestral",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/samschott-maestral",
    "commit": "79e5f46885de75b022513de6598e8baf4ea66f97",
    "filename": "maestral/cli.py",
    "source_code": "    else:\n        fallback_entry_point = next(entry_points)\n        run = fallback_entry_point.load()",
    "target_code": "    <DED>else:\n        <IND>fallback_entry_point = next(iter(entry_points))\n        run = fallback_entry_point.load()\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Iterator[Variable[_T]]` for 1st positional only parameter to call `next` but got `List[typing.Any]`.",
    "warning_line": 559,
    "pred_top-1": {
      "pred": "<DED> else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n",
      "pred_parsed": "    else:\n        next(entry_points)\n        run = fallback_entry_point.load()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> else: \n <IND> next() \n fallback_entry_point = next(entry_points) \n run = fallback_entry_point.load() \n",
      "pred_parsed": "    else:\n        next()\n        fallback_entry_point = next(entry_points)\n        run = fallback_entry_point.load()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> else: \n <IND> next(entry_point) \n run = fallback_entry_point.load() \n",
      "pred_parsed": "    else:\n        next(entry_point)\n        run = fallback_entry_point.load()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n",
      "pred_parsed": "    else:\n        next(entry_points)\n        run = fallback_entry_point.load()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n",
      "pred_parsed": "    else:\n        next(entry_points)\n        run = fallback_entry_point.load()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "libp2p/py-libp2p",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/libp2p-py-libp2p",
    "commit": "b4bd997932ff5ee78a7f4f3c63e7e5cf1dddc397",
    "filename": "libp2p/pubsub/gossipsub.py",
    "source_code": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic],\n                    )\n                    # Add the peers to fanout[topic]\n                    self.fanout[topic].Update(selected_peers)",
    "target_code": "                        self.degree - num_fanout_peers_in_topic,\n                        list(self.fanout[topic]),\n                    )\n                    # Add the peers to fanout[topic]\n                    self.fanout[topic].update(selected_peers)\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `Sequence[ID]` for 3rd positional only parameter to call `GossipSub._get_in_topic_gossipsub_peers_from_minus` but got `Set[ID]`.",
    "warning_line": 473,
    "pred_top-1": {
      "pred": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to fanout[topic], \n self.fanout[topic].Update(selected_peers) \n \n",
      "pred_parsed": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic],\n                        )\n                        # Add the peers to fanout[topic],\n                        self.fanout[topic].Update(selected_peers)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to fanout[topic] \n self.fanout[topic].Update(selected_peers) \n \n",
      "pred_parsed": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic],\n                        )\n                        # Add the peers to fanout[topic]\n                        self.fanout[topic].Update(selected_peers)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic]: \n ) \n # Add the peers to fanout[topic] \n self.fanout[topic].Update(selected_peers) \n \n",
      "pred_parsed": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic]:\n                        )\n                        # Add the peers to fanout[topic]\n                        self.fanout[topic].Update(selected_peers)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to self.fanout[topic], \n self.fanout[topic].Update(selected_peers) \n \n",
      "pred_parsed": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic],\n                        )\n                        # Add the peers to self.fanout[topic],\n                        self.fanout[topic].Update(selected_peers)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to self.fanout[topic].Update(selected_peers) \n \n",
      "pred_parsed": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic],\n                        )\n                        # Add the peers to self.fanout[topic].Update(selected_peers)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "ConsenSys/mythril",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ConsenSys-mythril",
    "commit": "b2b21431cd255c33fed711aee2d1d749b3968474",
    "filename": "mythril/laser/ethereum/instructions.py",
    "source_code": "                new = Or(new, key_argument != index_argument)",
    "target_code": "\n                new = Or(new, cast(Bool, key_argument != index_argument))\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `mythril.laser.smt.bool.Bool` for 2nd positional only parameter to call `mythril.laser.smt.bool.Or` but got `bool`.",
    "warning_line": 1374,
    "pred_top-1": {
      "pred": "\n new = Or(new, key_argument!= index_argument) \n \n",
      "pred_parsed": "                new = Or(new, key_argument!= index_argument)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n assert key_argument is not None \n new = Or(new, key_argument!= index_argument) \n \n",
      "pred_parsed": "                assert key_argument is not None\n                new = Or(new, key_argument!= index_argument)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n bool = Or(new, key_argument!= index_argument) \n \n",
      "pred_parsed": "                bool = Or(new, key_argument!= index_argument)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n new_argument = Or(new, key_argument!= index_argument) \n \n",
      "pred_parsed": "                new_argument = Or(new, key_argument!= index_argument)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n or(new, key_argument!= index_argument) \n \n",
      "pred_parsed": "                or(new, key_argument!= index_argument)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "volatilityfoundation/volatility3",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/volatilityfoundation-volatility3",
    "commit": "113c23a66d4bf391eb2e1d1e6bafaa7673e7ce55",
    "filename": "volatility/framework/automagic/nlpdtbfinder.py",
    "source_code": "                        physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        layer = context.memory[physical_layer]",
    "target_code": "                        <IND>physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        if not isinstance(physical_layer, str):\n                            <IND>raise ValueError(\"Physical Layer configuration must be a string\")\n                        <DED>layer = context.memory[physical_layer]\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `str` for 1st positional only parameter to call `interfaces.layers.Memory.__getitem__` but got `typing.Union[typing.List[typing.Union[bool, bytes, int, str]], bool, bytes, int, str]`.",
    "warning_line": 168,
    "pred_top-1": {
      "pred": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n",
      "pred_parsed": "                        physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        assert isinstance(physical_layer, str)\n                        layer = context.memory[physical_layer]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert physical_layer is not None \n layer = context.memory[physical_layer] \n",
      "pred_parsed": "                        physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        assert physical_layer is not None\n                        layer = context.memory[physical_layer]\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, bool, bytes, int, str) \n layer = context.memory[physical_layer] \n",
      "pred_parsed": "                        physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        assert isinstance(physical_layer, bool, bytes, int, str)\n                        layer = context.memory[physical_layer]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n",
      "pred_parsed": "                        physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        assert isinstance(physical_layer, str)\n                        layer = context.memory[physical_layer]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n",
      "pred_parsed": "                        physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        assert isinstance(physical_layer, str)\n                        layer = context.memory[physical_layer]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "smallwat3r/shhh",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/smallwat3r-shhh",
    "commit": "9687d92934b4256ef5dd0489c1b0b714466fa05a",
    "filename": "shhh/config.py",
    "source_code": "    try:\n        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ.get(\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"))\n    except (ValueError, TypeError):",
    "target_code": "    <DED>try:\n        <IND>SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(\n            os.environ.get(\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\", 1)\n        )\n    <DED>except (ValueError, TypeError):\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Union[bytearray, bytes, str, typing.SupportsFloat, typing_extensions.SupportsIndex]` for 1st positional only parameter to call `float.__new__` but got `Optional[str]`.",
    "warning_line": 63,
    "pred_top-1": {
      "pred": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"]) \n <DED> except (ValueError, TypeError): \n",
      "pred_parsed": "    try:\n        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"])\n    except (ValueError, TypeError):\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\") \n <DED> except (ValueError, TypeError): \n",
      "pred_parsed": "    try:\n        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\")\n    except (ValueError, TypeError):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> try: \n <IND> assert isinstance(bytearray, str) \n SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\") \n <DED> except (ValueError, TypeError): \n",
      "pred_parsed": "    try:\n        assert isinstance(bytearray, str)\n        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\")\n    except (ValueError, TypeError):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float((os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\")) \n <DED> except (ValueError, TypeError): \n",
      "pred_parsed": "    try:\n        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float((os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"))\n    except (ValueError, TypeError):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"], float) \n <DED> except (ValueError, TypeError): \n",
      "pred_parsed": "    try:\n        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"], float)\n    except (ValueError, TypeError):\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "CogStack/MedCAT",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/CogStack-MedCAT",
    "commit": "ed2ec9365b688b0e890652e5410c2065075eb986",
    "filename": "medcat/cat.py",
    "source_code": "                    self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(len(texts)):\n                        if i == len(out):\n                            out.append(self._doc_to_out(None, only_cui, addl_info))\n                        elif out[i]['text'] != texts[i]:\n                            out.insert(i, self._doc_to_out(None, only_cui, addl_info))",
    "target_code": "                    <IND>self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i, text in enumerate(texts):\n                        <IND>if i == len(out):\n                            <IND>out.append(self._doc_to_out(None, only_cui, addl_info))\n                        <DED>elif out[i]['text'] != text:\n                            <IND>out.insert(i, self._doc_to_out(None, only_cui, addl_info))\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Union[Iterable[str], Iterable[typing.Tuple[typing.Any, ...]]]`.",
    "warning_line": 757,
    "pred_top-1": {
      "pred": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= out[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n",
      "pred_parsed": "                    self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(len(out)):\n                        out.append(self._doc_to_out(None, only_cui, addl_info))\n                    elif out[i]['text']!= out[i]:\n                        out.insert(i, self._doc_to_out(None, only_cui, addl_info))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n",
      "pred_parsed": "                    self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(len(out)):\n                        out.append(self._doc_to_out(None, only_cui, addl_info))\n                    elif out[i]['text']!= texts[i]:\n                        out.insert(i, self._doc_to_out(None, only_cui, addl_info))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(str(len(out))): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n",
      "pred_parsed": "                    self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(str(len(out))):\n                        out.append(self._doc_to_out(None, only_cui, addl_info))\n                    elif out[i]['text']!= texts[i]:\n                        out.insert(i, self._doc_to_out(None, only_cui, addl_info))\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> if i == len(out): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)",
      "pred_parsed": "                    self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(len(out)):\n                        if i == len(out):\n                            out.append(self._doc_to_out(None, only_cui, addl_info))\n                        elif out[i]['text']!= texts[i]:\n                            out.insert(i, self._doc_to_out(None, only_cui, addl_info)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> if i == len(out): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui",
      "pred_parsed": "                    self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(len(out)):\n                        if i == len(out):\n                            out.append(self._doc_to_out(None, only_cui, addl_info))\n                        elif out[i]['text']!= texts[i]:\n                            out.insert(i, self._doc_to_out(None, only_cui\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "explosion/spaCy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/explosion-spaCy",
    "commit": "657af5f91f88bb5a414ae133a99465dbc4f240be",
    "filename": "spacy/pipeline/textcat.py",
    "source_code": "            xp = get_array_module(tensors)\n            scores = xp.zeros((len(docs), len(self.labels)))\n            return scores",
    "target_code": "            xp = get_array_module(tensors)\n            scores = xp.zeros((len(list(docs)), len(self.labels)))\n            return scores\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Iterable[spacy.tokens.doc.Doc]`.",
    "warning_line": 156,
    "pred_top-1": {
      "pred": "xp = get_array_module(tensors) \n scores = xp.zeros((len(docs), len(self.labels))) \n return scores \n",
      "pred_parsed": "            xp = get_array_module(tensors)\n            scores = xp.zeros((len(docs), len(self.labels)))\n            return scores\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "xp = get_array_module(tensors) \n scores = xp.zeros((len(docs), len(self.labels.Tokens.doc.Doc))) \n return scores \n",
      "pred_parsed": "            xp = get_array_module(tensors)\n            scores = xp.zeros((len(docs), len(self.labels.Tokens.doc.Doc)))\n            return scores\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "xp = get_array_module(tensors) \n scores = xp.zeros((str(len(docs), str(len(self.labels)))) \n return scores \n",
      "pred_parsed": "            xp = get_array_module(tensors)\n            scores = xp.zeros((str(len(docs), str(len(self.labels))))\n            return scores\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "xp = get_array_module(tensors) \n scores = xp.zeros((str(len(docs), len(self.labels.Tokens.doc.Doc)))) \n return scores \n",
      "pred_parsed": "            xp = get_array_module(tensors)\n            scores = xp.zeros((str(len(docs), len(self.labels.Tokens.doc.Doc))))\n            return scores\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "xp = get_array_module(tensors) \n scores = xp.zeros((str(len(docs), str(len(self.labels.tokens.doc.Doc)))) \n return scores \n",
      "pred_parsed": "            xp = get_array_module(tensors)\n            scores = xp.zeros((str(len(docs), str(len(self.labels.tokens.doc.Doc))))\n            return scores\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "rpy2/rpy2",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/rpy2-rpy2",
    "commit": "206272f376fc31ecca831db466678d42d5cc8cfd",
    "filename": "rpy2/rinterface_lib/bufferprotocol.py",
    "source_code": "    rk = len(shape)\n    strides = [None, ] * rk\n    strides[0] = itemsize\n    for i in range(1, rk):\n        strides[i] = shape[i-1] * strides[i-1]\n    return tuple(strides)",
    "target_code": "    <IND>rk = len(shape)\n    strides = [itemsize, ]\n    for i in range(1, rk):\n        <IND>strides.append(shape[i-1] * strides[i-1])\n    <DED>return tuple(strides)\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `None` for 2nd positional only parameter to call `list.__setitem__` but got `int`.",
    "warning_line": 32,
    "pred_top-1": {
      "pred": "<IND> rk = len(shape) \n strides = [itemsize, ] \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "pred_parsed": "    rk = len(shape)\n    strides = [itemsize, ]\n    for i in range(1, rk):\n        strides[i] = shape[i-1] * strides[i-1]\n    return tuple(strides)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<IND> rk = len(shape) \n strides = [itemsize, ] \n for i in range(1, rk): \n <IND> strides = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "pred_parsed": "    rk = len(shape)\n    strides = [itemsize, ]\n    for i in range(1, rk):\n        strides = shape[i-1] * strides[i-1]\n    return tuple(strides)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<IND> rk = len(shape) \n strides = [itemsize, ] * rk \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "pred_parsed": "    rk = len(shape)\n    strides = [itemsize, ] * rk\n    for i in range(1, rk):\n        strides[i] = shape[i-1] * strides[i-1]\n    return tuple(strides)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<IND> rk = len(shape) \n strides = [itemsize, ] * strides[0] \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "pred_parsed": "    rk = len(shape)\n    strides = [itemsize, ] * strides[0]\n    for i in range(1, rk):\n        strides[i] = shape[i-1] * strides[i-1]\n    return tuple(strides)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<IND> rk = len(shape) \n strides = [itemsize, ] * rk \n for i in range(1, rk): \n <IND> strides = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "pred_parsed": "    rk = len(shape)\n    strides = [itemsize, ] * rk\n    for i in range(1, rk):\n        strides = shape[i-1] * strides[i-1]\n    return tuple(strides)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "allenai/allennlp",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/allenai-allennlp",
    "commit": "700abc65fd2172a2c6809dd9b72cf50fc2407772",
    "filename": "allennlp/models/coreference_resolution/coref.py",
    "source_code": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n    ) -> None:\n        super().__init__(vocab, regularizer)",
    "target_code": "        initializer: InitializerApplicator = InitializerApplicator(),\n        **kwargs\n    ) -> None:\n        <IND>super().__init__(vocab, **kwargs)\n\n",
    "warning_type": "Incompatible parameter type [6]",
    "warning_message": " Expected `allennlp.nn.regularizers.regularizer_applicator.RegularizerApplicator` for 2nd positional only parameter to call `Model.__init__` but got `Optional[allennlp.nn.regularizers.regularizer_applicator.RegularizerApplicator]`.",
    "warning_line": 79,
    "pred_top-1": {
      "pred": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, reg_applicator) \n \n",
      "pred_parsed": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n        ) -> None:\n            super().__init__(vocab, reg_applicator)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, regex) \n \n",
      "pred_parsed": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n        ) -> None:\n            super().__init__(vocab, regex)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, reg_applicator) \n \n",
      "pred_parsed": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n        ) -> None:\n            super().__init__(vocab, reg_applicator)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, regularizer) \n \n",
      "pred_parsed": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n        ) -> None:\n            super().__init__(vocab, regularizer)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, regularizer) \n \n",
      "pred_parsed": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n        ) -> None:\n            super().__init__(vocab, regularizer)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "TheAlgorithms/Python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python",
    "commit": "60895366c0f50844af2737130ed98c2510e90060",
    "filename": "ciphers/rsa_factorization.py",
    "source_code": "def rsafactor(d: int, e: int, N: int) -> [int]:",
    "target_code": "\ndef rsafactor(d: int, e: int, N: int) -> list[int]:\n    <IND>",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `[int]` is not a valid type.",
    "warning_line": 16,
    "pred_top-1": {
      "pred": "\n def rsafactor(d: int, e: int, N: int) -> str: \n <IND>",
      "pred_parsed": "def rsafactor(d: int, e: int, N: int) -> str:\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n def rsafactor(d: int, e: int, N: int) -> List[int]: \n <IND>",
      "pred_parsed": "def rsafactor(d: int, e: int, N: int) -> List[int]:\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n def rsafactor(d: int, e: int, N: int): \n <IND>",
      "pred_parsed": "def rsafactor(d: int, e: int, N: int):\n    \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n def rsafactor(d: int, e: int, N: int) -> int: \n <IND>",
      "pred_parsed": "def rsafactor(d: int, e: int, N: int) -> int:\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n def rsafactor(d: int, e: int, N: int) -> List[int]: \n <DED>",
      "pred_parsed": "def rsafactor(d: int, e: int, N: int) -> List[int]:\n\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "tensorflow/tfx",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/tensorflow-tfx",
    "commit": "c1e0704b2a83232469f55598efcdb7808b6c909f",
    "filename": "tfx/components/example_gen/base_example_gen_executor.py",
    "source_code": "class BaseExampleGenExecutor(\n    with_metaclass(abc.ABCMeta, base_beam_executor.BaseBeamExecutor)):",
    "target_code": "\n<DED>class BaseExampleGenExecutor(base_beam_executor.BaseBeamExecutor, abc.ABC):\n  <IND>",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `six.with_metaclass(abc.ABCMeta, tfx.dsl.components.base.base_beam_executor.BaseBeamExecutor)` is not a valid type.",
    "warning_line": 134,
    "pred_top-1": {
      "pred": "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base.base_beam_executor.BaseBeamExecutor): \n <IND>",
      "pred_parsed": "class BaseExampleGenExecutor(\ntfx.dsl.components.base.base_beam_executor.BaseBeamExecutor):\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base.BaseBeam_executor.BaseBeamExecutor): \n <IND>",
      "pred_parsed": "class BaseExampleGenExecutor(\ntfx.dsl.components.base.BaseBeam_executor.BaseBeamExecutor):\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base_beam_executor.BaseBeamExecutor): \n <IND>",
      "pred_parsed": "class BaseExampleGenExecutor(\ntfx.dsl.components.base_beam_executor.BaseBeamExecutor):\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> class BaseExampleGenExecutor( \n with_metaclass(abc.ABC): \n <IND>",
      "pred_parsed": "class BaseExampleGenExecutor(\nwith_metaclass(abc.ABC):\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> class BaseExampleGenExecutor( \n with_metaclass(abc.ABC, base_beam_executor.BaseBeamExecutor): \n <IND>",
      "pred_parsed": "class BaseExampleGenExecutor(\nwith_metaclass(abc.ABC, base_beam_executor.BaseBeamExecutor):\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "aws-ia/taskcat",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/aws-ia-taskcat",
    "commit": "5279c4e8be22a46e71e8b60b6d25de793e800741",
    "filename": "taskcat/config.py",
    "source_code": "    def _process_legacy_project(self, instance) -> [None, Exception]:\n        validate(instance, \"legacy_project_config\")",
    "target_code": "\n    <DED>def _process_legacy_project(self, instance) -> Optional[Exception]:\n        <IND>validate(instance, \"legacy_project_config\")\n",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `[None, Exception]` is not a valid type.",
    "warning_line": 240,
    "pred_top-1": {
      "pred": "\n <DED> def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n",
      "pred_parsed": "    def _process_legacy_project(self, instance) -> None:\n        validate(instance, \"legacy_project_config\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n <IND> def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n",
      "pred_parsed": "    def _process_legacy_project(self, instance) -> None:\n        validate(instance, \"legacy_project_config\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n <DED> def _process_legacy_project(self, instance) -> None: \n <DED> validate(instance, \"legacy_project_config\") \n",
      "pred_parsed": "    def _process_legacy_project(self, instance) -> None:\nvalidate(instance, \"legacy_project_config\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n \n def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n",
      "pred_parsed": "    \n    def _process_legacy_project(self, instance) -> None:\n        validate(instance, \"legacy_project_config\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n <DED> def _process_legacy_project(self, instance): \n <IND> validate(instance, \"legacy_project_config\") \n",
      "pred_parsed": "    def _process_legacy_project(self, instance):\n        validate(instance, \"legacy_project_config\")\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "lozuwa/impy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/lozuwa-impy",
    "commit": "eb7fa43ba86a2916ead5de602fdb3949c06749c8",
    "filename": "ObjectDetectionDataset.py",
    "source_code": "class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods,                ObjectDetectionDatasetStatisticsMethods)):",
    "target_code": "\n# class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods, \\\n# \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObjectDetectionDatasetStatisticsMethods)):\nclass ObjectDetectionDataset(object):\n\n",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `interface.implements(ObjectDetectionDatasetPreprocessMethods.ObjectDetectionDatasetPreprocessMethods, ObjectDetectionDatasetStatisticsMethods.ObjectDetectionDatasetStatisticsMethods)` is not a valid type.",
    "warning_line": 62,
    "exception": "'pred_top-1'"
  },
  {
    "repo": "aws-ia/taskcat",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/aws-ia-taskcat",
    "commit": "5279c4e8be22a46e71e8b60b6d25de793e800741",
    "filename": "taskcat/_config_types.py",
    "source_code": "        validate(self.parameters, \"overrides\")\n        self.regions = list(regions) if regions else []\n        self.auth: dict = auth\n        self.client_factory: [ClientFactory, None] = None\n        self.name: str = name",
    "target_code": "        <DED>validate(self.parameters, \"overrides\")\n        self.regions: set = set(regions) if regions else set()\n        self.auth: dict = auth\n        self.client_factory: ClientFactory = ClientFactory()\n        self.name: str = name\n",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `[taskcat.client_factory.ClientFactory, None]` is not a valid type.",
    "warning_line": 40,
    "pred_top-1": {
      "pred": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n",
      "pred_parsed": "        validate(self.parameters, \"overrides\")\n        self.regions = list(regions) if regions else []\n        self.auth: dict = auth\n        self.client_factory: List[ClientFactory, None] = None\n        self.name: str = name\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: Optional[ClientFactory, None] = None \n self.name: str = name \n",
      "pred_parsed": "        validate(self.parameters, \"overrides\")\n        self.regions = list(regions) if regions else []\n        self.auth: dict = auth\n        self.client_factory: Optional[ClientFactory, None] = None\n        self.name: str = name\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else None \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n",
      "pred_parsed": "        validate(self.parameters, \"overrides\")\n        self.regions = list(regions) if regions else None\n        self.auth: dict = auth\n        self.client_factory: List[ClientFactory, None] = None\n        self.name: str = name\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> validate(self.parameters, \"overrides\") \n self.regions: list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n",
      "pred_parsed": "        validate(self.parameters, \"overrides\")\n        self.regions: list(regions) if regions else []\n        self.auth: dict = auth\n        self.client_factory: List[ClientFactory, None] = None\n        self.name: str = name\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: ClientFactory, None = None \n self.name: str = name \n",
      "pred_parsed": "        validate(self.parameters, \"overrides\")\n        self.regions = list(regions) if regions else []\n        self.auth: dict = auth\n        self.client_factory: ClientFactory, None = None\n        self.name: str = name\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "Ultimaker/Cura",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Ultimaker-Cura",
    "commit": "ea9a9d58b17e93eed22923001069fceafea8a798",
    "filename": "plugins/Toolbox/src/CloudSync/SubscribedPackagesModel.py",
    "source_code": "    @staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: [str]) -> bool:",
    "target_code": "    <DED>@staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: List[str]) -> bool:\n        <IND>",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `[str]` is not a valid type.",
    "warning_line": 76,
    "pred_top-1": {
      "pred": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: str) -> bool: \n <IND>",
      "pred_parsed": "    @staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: str) -> bool:\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager) -> bool: \n <IND>",
      "pred_parsed": "    @staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager) -> bool:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: Optional[str]) -> bool: \n <IND>",
      "pred_parsed": "    @staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: Optional[str]) -> bool:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: List[str]) -> bool: \n <IND>",
      "pred_parsed": "    @staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: List[str]) -> bool:\n        \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: bool) -> bool: \n <IND>",
      "pred_parsed": "    @staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: bool) -> bool:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "argoai/argoverse-api",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/argoai-argoverse-api",
    "commit": "b9f1b8f874c25d37f6154edecda510672289bd5c",
    "filename": "argoverse/evaluation/stereo/eval.py",
    "source_code": "        data_sum = data.sum()\n        summary: dict() = dict()",
    "target_code": "        data_sum = data.sum()\n        summary = dict()\n\n",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `dict()` is not a valid type.",
    "warning_line": 147,
    "pred_top-1": {
      "pred": "data_sum = data.sum() \n summary: dict() \n \n",
      "pred_parsed": "        data_sum = data.sum()\n        summary: dict()\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "data_sum = data.sum() \n summary = dict() \n \n",
      "pred_parsed": "        data_sum = data.sum()\n        summary = dict()\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "data_sum = data.sum() \n sum = dict() \n \n",
      "pred_parsed": "        data_sum = data.sum()\n        sum = dict()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "data_sum = data.sum() \n summary: [] = dict() \n \n",
      "pred_parsed": "        data_sum = data.sum()\n        summary: [] = dict()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "data_sum = data.sum() \n summary=dict() \n \n",
      "pred_parsed": "        data_sum = data.sum()\n        summary=dict()\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "TheAlgorithms/Python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python",
    "commit": "25164bb6380ae760bed5fe3efc5f2fc3ec5c38a1",
    "filename": "backtracking/all_combinations.py",
    "source_code": "def generate_all_combinations(n: int, k: int) -> [[int]]:",
    "target_code": "\nfrom typing import List\n\n\ndef generate_all_combinations(n: int, k: int) -> List[List[int]]:\n    <IND>",
    "warning_type": "Invalid type [31]",
    "warning_message": " Expression `[[int]]` is not a valid type.",
    "warning_line": 8,
    "pred_top-1": {
      "pred": "\n \n \n def generate_all_combinations(n: int, k: int) -> List[int]: \n <IND>",
      "pred_parsed": "\n\ndef generate_all_combinations(n: int, k: int) -> List[int]:\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n \n \n def generate_all_combinations(n: int, k: int): \n <IND>",
      "pred_parsed": "\n\ndef generate_all_combinations(n: int, k: int):\n    \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n \n \n def generate_all_combinations(n: int, k: int) -> List[[int]]: \n <IND>",
      "pred_parsed": "\n\ndef generate_all_combinations(n: int, k: int) -> List[[int]]:\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n \n \n def generate_all_combinations(n: int, k: int) -> str: \n <IND>",
      "pred_parsed": "\n\ndef generate_all_combinations(n: int, k: int) -> str:\n    \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n \n <DED> def generate_all_combinations(n: int, k: int) -> List[int]: \n <IND>",
      "pred_parsed": "\ndef generate_all_combinations(n: int, k: int) -> List[int]:\n\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "unit8co/darts",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/unit8co-darts",
    "commit": "2977f4f666e255b617ad980eab81d6ff6aad9db3",
    "filename": "darts/models/theta.py",
    "source_code": "    def fit(self, ts, component_index: Optional[int] = None):\n        super().fit(ts, component_index)\n        # Check univariate time series",
    "target_code": "\n    <DED>def fit(self, ts):\n        <IND>super().fit(ts)\n        # Check univariate time series\n",
    "warning_type": "Inconsistent override [14]",
    "warning_message": " `darts.models.theta.FourTheta.fit` overrides method defined in `UnivariateForecastingModel` inconsistently. Could not find parameter `series` in overriding signature.",
    "warning_line": 218,
    "pred_top-1": {
      "pred": "\n <DED> def fit(self, ts, component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "pred_parsed": "    def fit(self, ts, component_index: Optional[int] = None):\n        super().fit(ts, component_index)\n        # Check univariate time series\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> def fit(self, ts: Optional[int], component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "pred_parsed": "    def fit(self, ts: Optional[int], component_index: Optional[int] = None):\n        super().fit(ts, component_index)\n        # Check univariate time series\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def fit(self, ts: Optional[int] = None, component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "pred_parsed": "    def fit(self, ts: Optional[int] = None, component_index: Optional[int] = None):\n        super().fit(ts, component_index)\n        # Check univariate time series\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def fit(self, ts, component_index=None): \n <IND> super().fit(ts, component_index=None) \n # Check univariate time series \n",
      "pred_parsed": "    def fit(self, ts, component_index=None):\n        super().fit(ts, component_index=None)\n        # Check univariate time series\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n <DED> def fit(self, ts, component_index: Optional[int] = None) -> None: \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "pred_parsed": "    def fit(self, ts, component_index: Optional[int] = None) -> None:\n        super().fit(ts, component_index)\n        # Check univariate time series\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": true
  },
  {
    "repo": "online-judge-tools/verification-helper",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/online-judge-tools-verification-helper",
    "commit": "97fda380fc5689b70152f868b9f96a073a2a62fc",
    "filename": "onlinejudge_verify/languages/csharpscript.py",
    "source_code": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes:\n        raise NotImplementedError",
    "target_code": "\n    <DED>def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path, options: Dict[str, Any]) -> bytes:\n        <IND>raise NotImplementedError\n",
    "warning_type": "Inconsistent override [14]",
    "warning_message": " `onlinejudge_verify.languages.csharpscript.CSharpScriptLanguage.bundle` overrides method defined in `Language` inconsistently. Could not find parameter `options` in overriding signature.",
    "warning_line": 112,
    "pred_top-1": {
      "pred": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes: \n <IND> raise NotImplementedError \n",
      "pred_parsed": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes:\n        raise NotImplementedError\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> str(bytes): \n <IND> raise NotImplementedError \n",
      "pred_parsed": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> str(bytes):\n        raise NotImplementedError\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> Bytes: \n <IND> raise NotImplementedError \n",
      "pred_parsed": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> Bytes:\n        raise NotImplementedError\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> str: \n <IND> raise NotImplementedError \n",
      "pred_parsed": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> str:\n        raise NotImplementedError\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path): \n <IND> raise NotImplementedError \n",
      "pred_parsed": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path):\n        raise NotImplementedError\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "PyFilesystem/pyfilesystem2",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/PyFilesystem-pyfilesystem2",
    "commit": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "filename": "fs/memoryfs.py",
    "source_code": "    def write(self, data):\n        # type: (bytes) -> int\n        if not self._mode.writing:",
    "target_code": "    <DED>def write(self, data):\n        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n        <IND>if not self._mode.writing:\n",
    "warning_type": "Inconsistent override [14]",
    "warning_message": " `fs.memoryfs._MemoryFile.write` overrides method defined in `io.RawIOBase` inconsistently. Parameter of type `bytes` is not a supertype of the overridden parameter `Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]`.",
    "warning_line": 192,
    "pred_top-1": {
      "pred": "<DED> def write(self, data): \n # type: () -> int \n <IND> if not self._mode.writing: \n",
      "pred_parsed": "    def write(self, data):\n    # type: () -> int\n        if not self._mode.writing:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> def write(self, data): \n <IND> if not self._mode.writing: \n",
      "pred_parsed": "    def write(self, data):\n        if not self._mode.writing:\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<DED> def write(self, data): \n <DED> if not self._mode.writing: \n",
      "pred_parsed": "    def write(self, data):\nif not self._mode.writing:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> def write(self, data): \n # type: () -> int \n <DED> if not self._mode.writing: \n",
      "pred_parsed": "    def write(self, data):\n    # type: () -> int\nif not self._mode.writing:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> def write(self, data): \n \n if not self._mode.writing: \n",
      "pred_parsed": "    def write(self, data):\n    \n    if not self._mode.writing:\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "quantumblacklabs/kedro",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/quantumblacklabs-kedro",
    "commit": "49c095d0a747ce00b99727e358bb1f7f41106fe9",
    "filename": "kedro/contrib/colors/logging/color_logger.py",
    "source_code": "    def format(self, record: str) -> str:",
    "target_code": "\n    <DED>def format(self, record: logging.LogRecord) -> str:\n        <IND>",
    "warning_type": "Inconsistent override [14]",
    "warning_message": " `kedro.contrib.colors.logging.color_logger.ColorHandler.format` overrides method defined in `logging.Handler` inconsistently. Parameter of type `str` is not a supertype of the overridden parameter `logging.LogRecord`.",
    "warning_line": 110,
    "pred_top-1": {
      "pred": "\n <DED> def format(self, record: str) -> str: \n <IND>",
      "pred_parsed": "    def format(self, record: str) -> str:\n        \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> def format(self, record: logger.Str) -> str: \n <IND>",
      "pred_parsed": "    def format(self, record: logger.Str) -> str:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def format(self, record: logging.Handler.format) -> str: \n <IND>",
      "pred_parsed": "    def format(self, record: logging.Handler.format) -> str:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def format(self, record: str) -> str: \n <IND>",
      "pred_parsed": "    def format(self, record: str) -> str:\n        \n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "\n <DED> def format(self, record: str) -> k: \n <IND>",
      "pred_parsed": "    def format(self, record: str) -> k:\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "ConsenSys/mythril",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ConsenSys-mythril",
    "commit": "556d138d50ef5ce02bd725a0743f8c7bf3038ae9",
    "filename": "mythril/laser/smt/bitvecfunc.py",
    "source_code": "    def __or__(self, other: \"BitVec\") -> \"BitVecFunc\":",
    "target_code": "\n    <DED>def __or__(self, other: Union[int, \"BitVec\"]) -> \"BitVecFunc\":\n        <IND>",
    "warning_type": "Inconsistent override [14]",
    "warning_message": " `mythril.laser.smt.bitvecfunc.BitVecFunc.__or__` overrides method defined in `BitVec` inconsistently. Parameter of type `BitVec` is not a supertype of the overridden parameter `Union[BitVec, int]`.",
    "warning_line": 137,
    "pred_top-1": {
      "pred": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc\": \n <IND>",
      "pred_parsed": "    def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc\":\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc",
      "pred_parsed": "    def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str], Union[str]]]]) -> \"BitVecFunc\": \n <IND>",
      "pred_parsed": "    def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str], Union[str]]]]) -> \"BitVecFunc\":\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]) -> \"BitVecFunc\": \n <IND>",
      "pred_parsed": "    def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]) -> \"BitVecFunc\":\n        \n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str], Union[str]]]]]]])",
      "pred_parsed": "    def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str], Union[str]]]]]]])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "flairNLP/flair",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/flairNLP-flair",
    "commit": "0b834f5167d11f06037398fcbe1554f244167e18",
    "filename": "flair/embeddings/token.py",
    "source_code": "        else:\n            self.context_embeddings: FlairEmbeddings = contextual_embeddings\n\n        # length is twice the original character LM embedding length\n        self.embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"",
    "target_code": "        <DED>else:\n            <IND>self.context_embeddings = contextual_embeddings\n\n        # length is twice the original character LM embedding length\n        <DED>self.__embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `embedding_length` declared in class `PooledFlairEmbeddings` has type `BoundMethod[typing.Callable(PooledFlairEmbeddings.embedding_length)[[Named(self, PooledFlairEmbeddings)], int], PooledFlairEmbeddings]` but is used as type `int`.",
    "warning_line": 807,
    "pred_top-1": {
      "pred": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "pred_parsed": "        else:\n            self.context_embeddings: FlairEmbeddings = contextual_embeddings\n            # embedding length is twice the original character LM embedding length\n        self.embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <IND> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "pred_parsed": "        else:\n            self.context_embeddings: FlairEmbeddings = contextual_embeddings\n            # embedding length is twice the original character LM embedding length\n                self.embedding_length = self.context_embeddings.embedding_length * 2\n                self.name = self.context_embeddings.name + \"-context\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n \n self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "pred_parsed": "        else:\n            self.context_embeddings: FlairEmbeddings = contextual_embeddings\n            # embedding length is twice the original character LM embedding length\n            \n            self.embedding_length = self.context_embeddings.embedding_length * 2\n            self.name = self.context_embeddings.name + \"-context\"\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "pred_parsed": "        else:\n            self.context_embeddings: FlairEmbeddings = contextual_embeddings\n            # length is twice the original character LM embedding length\n        self.embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<IND> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "pred_parsed": "        else:\n            self.context_embeddings: FlairEmbeddings = contextual_embeddings\n            # embedding length is twice the original character LM embedding length\n        self.embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "datatheorem/strongarm",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/macho/macho_analyzer.py",
    "source_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = None\n        self._objc_method_list: List[ObjcMethodInfo] = None",
    "target_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: List[ObjcMethodInfo] = []\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `_objc_method_list` declared in class `MachoAnalyzer` has type `List[strongarm.objc.objc_analyzer.ObjcMethodInfo]` but is used as type `None`.",
    "warning_line": 51,
    "pred_top-1": {
      "pred": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: Optional[ObjcRuntimeDataParser] = None \n self._objc_method_list: Optional[List[ObjcMethodInfo]] = None \n \n",
      "pred_parsed": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: Optional[List[ObjcMethodInfo]] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: ObjcRuntimeDataParser = [] \n self._objc_method_list: List[ObjcMethodInfo] = [] \n \n",
      "pred_parsed": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = []\n        self._objc_method_list: List[ObjcMethodInfo] = []\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: ObjcRuntimeDataParser = \"\" \n self._objc_method_list: List[ObjcMethodInfo] = \"\" \n \n",
      "pred_parsed": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = \"\"\n        self._objc_method_list: List[ObjcMethodInfo] = \"\"\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: ObjcRuntimeDataParser = [] \n self._objc_method_list: ObjcRuntimeDataParser = [] \n \n",
      "pred_parsed": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = []\n        self._objc_method_list: ObjcRuntimeDataParser = []\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: Optional[ObjcRuntimeDataParser] = None \n self._objc_method_list: Optional[List[ObjcMethodInfo]] = None \n <DED>",
      "pred_parsed": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: Optional[List[ObjcMethodInfo]] = None\n    \n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "dcs-liberation/dcs_liberation",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation",
    "commit": "e851223733ca24b8479dc9c4cfaf76cb724661a3",
    "filename": "game/settings.py",
    "source_code": "    supercarrier: bool = False\n    multiplier: bool = 1\n    generate_marks: bool = True",
    "target_code": "    supercarrier: bool = False\n    multiplier: float = 1\n    generate_marks: bool = True\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `multiplier` declared in class `Settings` has type `bool` but is used as type `int`.",
    "warning_line": 24,
    "pred_top-1": {
      "pred": "supercarrier: bool = False \n multiplier: int = 1 \n generate_marks: bool = True \n",
      "pred_parsed": "    supercarrier: bool = False\n    multiplier: int = 1\n    generate_marks: bool = True\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "supercarrier: int = False \n multiplier: int = 1 \n generate_marks: int = True \n",
      "pred_parsed": "    supercarrier: int = False\n    multiplier: int = 1\n    generate_marks: int = True\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "supercarrier: bool = False \n multiplier: int = 1 \n generate_marks: int = True \n",
      "pred_parsed": "    supercarrier: bool = False\n    multiplier: int = 1\n    generate_marks: int = True\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "supercarrier: bool = False \n multiplier: bool = 1 \n generate_marks: bool = True \n",
      "pred_parsed": "    supercarrier: bool = False\n    multiplier: bool = 1\n    generate_marks: bool = True\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "supercarrier: int = False \n multiplier: int = 1 \n generate_marks: bool = True \n",
      "pred_parsed": "    supercarrier: int = False\n    multiplier: int = 1\n    generate_marks: bool = True\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "mesonbuild/meson",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/mesonbuild-meson",
    "commit": "b8e4600bb84c94c1efde93c186eba7a2f5305836",
    "filename": "mesonbuild/interpreterbase.py",
    "source_code": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None:\n        self.held_object = obj        # type: InterpreterObject\n        self.subproject = subproject  # type: str",
    "target_code": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    <IND>def __init__(self, obj: TV_InterpreterObject, subproject: str = '') -> None:\n        <IND>self.held_object = obj\n        self.subproject = subproject\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `subproject` declared in class `ObjectHolder` has type `str` but is used as type `T.Optional[str]`.",
    "warning_line": 65,
    "pred_top-1": {
      "pred": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: T.Optional[str] \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "pred_parsed": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None:\n        self.held_object = obj # type: T.Optional[str]\n        self.subproject = subproject # type: T.Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: InterpreterObject \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "pred_parsed": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None:\n        self.held_object = obj # type: InterpreterObject\n        self.subproject = subproject # type: T.Optional[str]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: Optional[T.Optional[str]] = None) -> None: \n <IND> self.held_object = obj # type: InterpreterObject \n self.subproject = subproject # type: Optional[str] \n \n",
      "pred_parsed": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    def __init__(self, obj: InterpreterObject, subproject: Optional[T.Optional[str]] = None) -> None:\n        self.held_object = obj # type: InterpreterObject\n        self.subproject = subproject # type: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: T.Optional[InterpreterObject] \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "pred_parsed": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None:\n        self.held_object = obj # type: T.Optional[InterpreterObject]\n        self.subproject = subproject # type: T.Optional[str]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: Optional[T.Optional[str]] = None) -> None: \n <IND> self.held_object = obj # type: InterpreterObject \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "pred_parsed": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    def __init__(self, obj: InterpreterObject, subproject: Optional[T.Optional[str]] = None) -> None:\n        self.held_object = obj # type: InterpreterObject\n        self.subproject = subproject # type: T.Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "libp2p/py-libp2p",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/libp2p-py-libp2p",
    "commit": "b2f496d081db5176636449d585dbbdba7f71061d",
    "filename": "libp2p/pubsub/gossipsub.py",
    "source_code": "        # pylint: disable=too-many-arguments\n        self.protocols: List[str] = protocols\n        self.pubsub: Pubsub = None",
    "target_code": "        # pylint: disable=too-many-arguments\n        <IND>self.protocols = list(protocols)\n        self.pubsub = None\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `protocols` declared in class `GossipSub` has type `List[str]` but is used as type `Sequence[str]`.",
    "warning_line": 65,
    "pred_top-1": {
      "pred": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: Pubsub = None \n \n",
      "pred_parsed": "        # pylint: disable=too-many-arguments\n        self.protocols: List[str] = []\n        self.pubsub: Pubsub = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: Pubsub = [] \n \n",
      "pred_parsed": "        # pylint: disable=too-many-arguments\n        self.protocols: List[str] = []\n        self.pubsub: Pubsub = []\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: List[str] = None \n \n",
      "pred_parsed": "        # pylint: disable=too-many-arguments\n        self.protocols: List[str] = []\n        self.pubsub: List[str] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List = [] \n self.pubsub: Pubsub = None \n \n",
      "pred_parsed": "        # pylint: disable=too-many-arguments\n        self.protocols: List = []\n        self.pubsub: Pubsub = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: List[PubSub] = None \n \n",
      "pred_parsed": "        # pylint: disable=too-many-arguments\n        self.protocols: List[str] = []\n        self.pubsub: List[PubSub] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "StellarCN/py-stellar-base",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/StellarCN-py-stellar-base",
    "commit": "fb330563ff2269540bfbfd662fa535080d1cc1f6",
    "filename": "stellar_sdk/memo.py",
    "source_code": "        self.memo_text: bytes = text\n        if not isinstance(text, bytes):\n            self.memo_text = bytes(text, encoding=\"utf-8\")",
    "target_code": "\n        <DED>if not isinstance(text, bytes):\n            <IND>text = bytes(text, encoding=\"utf-8\")\n        <DED>self.memo_text: bytes = text\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `memo_text` declared in class `TextMemo` has type `bytes` but is used as type `Union[bytes, str]`.",
    "warning_line": 99,
    "pred_top-1": {
      "pred": "\n <DED> self.memo_text: Union[bytes, bytes] = text \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "pred_parsed": "        self.memo_text: Union[bytes, bytes] = text\n        if not isinstance(text, bytes):\n            self.memo_text = bytes(text, encoding=\"utf-8\")\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "\n <DED> self.memo_text: bytes = text \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "pred_parsed": "        self.memo_text: bytes = text\n        if not isinstance(text, bytes):\n            self.memo_text = bytes(text, encoding=\"utf-8\")\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "\n <DED> self.memo_text: Union[bytes, str] = bytes \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "pred_parsed": "        self.memo_text: Union[bytes, str] = bytes\n        if not isinstance(text, bytes):\n            self.memo_text = bytes(text, encoding=\"utf-8\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n <DED> self.memo_text: bytes = [] \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "pred_parsed": "        self.memo_text: bytes = []\n        if not isinstance(text, bytes):\n            self.memo_text = bytes(text, encoding=\"utf-8\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n <DED> self.memo_text: bytes = text \n if not isinstance(text): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "pred_parsed": "        self.memo_text: bytes = text\n        if not isinstance(text):\n            self.memo_text = bytes(text, encoding=\"utf-8\")\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "collerek/ormar",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/collerek-ormar",
    "commit": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "filename": "tests/test_new_annotation_style.py",
    "source_code": "    id: int = ormar.Integer(primary_key=True)\n    album: Album = ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title: str = ormar.String(max_length=100)",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    album= ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title = ormar.String(max_length=100)\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `title` declared in class `Cover` has type `str` but is used as type `ormar.fields.model_fields.String`.",
    "warning_line": 45,
    "pred_top-1": {
      "pred": "\n <DED> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title= ormar.String(max_length=100) \n \n",
      "pred_parsed": "    id = ormar.Integer(primary_key=True)\n    album= ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title= ormar.String(max_length=100)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "\n <DED> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "pred_parsed": "    id = ormar.Integer(primary_key=True)\n    album = ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title = ormar.String(max_length=100)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n <DED> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "pred_parsed": "    id = ormar.Integer(primary_key=True)\n    album= ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title = ormar.String(max_length=100)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "\n <IND> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title= ormar.String(max_length=100) \n \n",
      "pred_parsed": "    id = ormar.Integer(primary_key=True)\n    album= ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title= ormar.String(max_length=100)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "\n <IND> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "pred_parsed": "    id = ormar.Integer(primary_key=True)\n    album = ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title = ormar.String(max_length=100)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "TheAlgorithms/Python",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/TheAlgorithms-Python",
    "commit": "8285913e81fb8f46b90d0e19da233862964c07dc",
    "filename": "data_structures/queue/double_ended_queue.py",
    "source_code": "        val: Any = None\n        next: \"Deque._Node\" = None\n        prev: \"Deque._Node\" = None",
    "target_code": "        val: Any = None\n        next: Deque._Node | None = None\n        prev: Deque._Node | None = None\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `prev` declared in class `Deque._Node` has type `Deque._Node` but is used as type `None`.",
    "warning_line": 55,
    "pred_top-1": {
      "pred": "val: Any = None \n next: Optional[\"Deque._Node\"] = None \n prev: Optional[\"Deque._Node\"] = None \n \n",
      "pred_parsed": "        val: Any = None\n        next: Optional[\"Deque._Node\"] = None\n        prev: Optional[\"Deque._Node\"] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "val: Any = None \n next: Deque._Node | None = None \n prev: Deque._Node | None = None \n \n",
      "pred_parsed": "        val: Any = None\n        next: Deque._Node | None = None\n        prev: Deque._Node | None = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "val: Any = None \n next: Deque._Node = None \n prev: Deque._Node = None \n \n",
      "pred_parsed": "        val: Any = None\n        next: Deque._Node = None\n        prev: Deque._Node = None\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "val: Any = None \n next: \"Deque._Node\" = None \n prev: \"Deque._Node\" = None \n \n",
      "pred_parsed": "        val: Any = None\n        next: \"Deque._Node\" = None\n        prev: \"Deque._Node\" = None\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "val: Any = None \n next: Deque._Node() \n prev: Deque._Node() \n \n",
      "pred_parsed": "        val: Any = None\n        next: Deque._Node()\n        prev: Deque._Node()\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "ehForwarderBot/efb-telegram-master",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ehForwarderBot-efb-telegram-master",
    "commit": "ba3d8d85152e2e58a8385a74f19be04c5c7a4fe6",
    "filename": "efb_telegram_master/master_message.py",
    "source_code": "            m.author = self.chat_manager.self\n            m.chat = self.chat_manager.get_chat(channel, uid)\n            if not m.chat:\n                # Chat not found anyway, build a fake object",
    "target_code": "            m.author = self.chat_manager.self\n            m_chat = self.chat_manager.get_chat(channel, uid)\n            if not m_chat:\n                # Chat not found anyway, build a fake object\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `chat` declared in class `ETMMsg` has type `efb_telegram_master.chat.ETMChat` but is used as type `Optional[efb_telegram_master.chat.ETMChat]`.",
    "warning_line": 271,
    "pred_top-1": {
      "pred": "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, uid) \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "pred_parsed": "            m.author = self.chat_manager.self\n            m.chat = self.chat_manager.get_chat(channel, uid)\n            if not m.chat:\n            # Chat not found anyway, build a fake object\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, efb_telegram_master.chat.ETMChat) \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "pred_parsed": "            m.author = self.chat_manager.self\n            m.chat = self.chat_manager.get_chat(channel, efb_telegram_master.chat.ETMChat)\n            if not m.chat:\n            # Chat not found anyway, build a fake object\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "m.author = self.chat_manager.self \n m.chat_manager = self.chat_manager.get_chat(channel, uid) \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "pred_parsed": "            m.author = self.chat_manager.self\n            m.chat_manager = self.chat_manager.get_chat(channel, uid)\n            if not m.chat:\n            # Chat not found anyway, build a fake object\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, uid).get_chat \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "pred_parsed": "            m.author = self.chat_manager.self\n            m.chat = self.chat_manager.get_chat(channel, uid).get_chat\n            if not m.chat:\n            # Chat not found anyway, build a fake object\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "m.author = self.chat_manager.self \n m.chat_manager = self.chat_manager.get_chat(channel, uid) \n if not m.chat_manager: \n # Chat not found anyway, build a fake object \n",
      "pred_parsed": "            m.author = self.chat_manager.self\n            m.chat_manager = self.chat_manager.get_chat(channel, uid)\n            if not m.chat_manager:\n            # Chat not found anyway, build a fake object\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "poljar/matrix-nio",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/poljar-matrix-nio",
    "commit": "bb2eeca8c4f591d828f657d466fd3ff1ef5842d8",
    "filename": "nio/client/http_client.py",
    "source_code": "    request_class: Type[Response] = field()\n    extra_data: Tuple = None",
    "target_code": "    <IND>request_class: Type[Response] = field()\n    extra_data: Tuple = ()\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `extra_data` declared in class `RequestInfo` has type `typing.Tuple[typing.Any, ...]` but is used as type `None`.",
    "warning_line": 93,
    "pred_top-1": {
      "pred": "<IND> request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n",
      "pred_parsed": "    request_class: Type[Response] = field()\n    extra_data: Optional[Tuple] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n",
      "pred_parsed": "    request_class: Type[Response] = field()\n    extra_data: Optional[Tuple] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n",
      "pred_parsed": "    request_class: Type[Response] = field()\n    extra_data: Optional[Tuple] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "<IND> request_class: Type[Response] = field() \n extra_data: Tuple \n \n",
      "pred_parsed": "    request_class: Type[Response] = field()\n    extra_data: Tuple\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> request_class: Type[Response] = field() \n extra_data: Optional[tuple] = None \n \n",
      "pred_parsed": "    request_class: Type[Response] = field()\n    extra_data: Optional[tuple] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "python/mypy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/build.py",
    "source_code": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\"  # type: str\n\n    # Options, specialized for this file\n    options = None  # type: Options",
    "target_code": "    # Contains a hash of the public interface in incremental mode\n    interface_hash: str = \"\"\n\n    # Options, specialized for this file\n    options: Options\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `options` declared in class `State` has type `Options` but is used as type `None`.",
    "warning_line": 1772,
    "pred_top-1": {
      "pred": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options = None # type: Options \n \n",
      "pred_parsed": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\" # type: str\n    \n    # Options, specialized for this file\n    options = None # type: Options\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options: Optional[str] \n \n",
      "pred_parsed": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\" # type: str\n    \n    # Options, specialized for this file\n    options: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: Optional[str] \n \n # Options, specialized for this file \n options = None # type: Optional[str] \n \n",
      "pred_parsed": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\" # type: Optional[str]\n    \n    # Options, specialized for this file\n    options = None # type: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "# Contains a hash of the public interface in incremental mode \n interface_hash: Optional[str] = \"\" \n \n # Options, specialized for this file \n options: Optional[str] = None \n \n",
      "pred_parsed": "    # Contains a hash of the public interface in incremental mode\n    interface_hash: Optional[str] = \"\"\n    \n    # Options, specialized for this file\n    options: Optional[str] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options: Optional[str] = None \n \n",
      "pred_parsed": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\" # type: str\n    \n    # Options, specialized for this file\n    options: Optional[str] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "microsoft/msticpy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/microsoft-msticpy",
    "commit": "9a28ea1687acb5e18a44219fd090ad3ed83b0228",
    "filename": "msticpy/sectools/tiproviders/ti_provider_base.py",
    "source_code": "    ioc_type: str\n    safe_ioc: str = None\n    query_subtype: Optional[str] = None",
    "target_code": "    ioc_type: str\n    safe_ioc: str = \"\"\n    query_subtype: Optional[str] = None\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `safe_ioc` declared in class `LookupResult` has type `str` but is used as type `None`.",
    "warning_line": 126,
    "pred_top-1": {
      "pred": "ioc_type: str \n safe_ioc: Optional[str] = None \n query_subtype: Optional[str] = None \n",
      "pred_parsed": "    ioc_type: str\n    safe_ioc: Optional[str] = None\n    query_subtype: Optional[str] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "ioc_type: str \n safe_ioc: str \n query_subtype: Optional[str] = None \n",
      "pred_parsed": "    ioc_type: str\n    safe_ioc: str\n    query_subtype: Optional[str] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "ioc_type: str \n safe_ioc: str = '' \n query_subtype: Optional[str] = None \n",
      "pred_parsed": "    ioc_type: str\n    safe_ioc: str = ''\n    query_subtype: Optional[str] = None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "ioc_type: str \n safe_ioc: str <IND> query_subtype: Optional[str] = None \n",
      "pred_parsed": "    ioc_type: str\n        safe_ioc: str  query_subtype: Optional[str] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "ioc_type: str \n safe_ioc: str <DED> query_subtype: Optional[str] = None \n",
      "pred_parsed": "    ioc_type: str\nsafe_ioc: str  query_subtype: Optional[str] = None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "wemake-services/dotenv-linter",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/wemake-services-dotenv-linter",
    "commit": "69892deec3de61824124bfe3e1da9182f1527ba6",
    "filename": "dotenv_linter/grammar/fst.py",
    "source_code": "    body: List[Union[Comment, Statement]] = field(default=list)",
    "target_code": "\n    __slots__ = {'lineno', 'col_offset', 'raw_text', 'text', 'body'}\n\n    body: List[Union[Comment, Statement]]\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `body` declared in class `Module` has type `List[Union[Comment, Statement]]` but is used as type `typing.Type[list]`.",
    "warning_line": 139,
    "pred_top-1": {
      "pred": "\n body: List[Comment, Statement] = field(default=list) \n",
      "pred_parsed": "    body: List[Comment, Statement] = field(default=list)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n body: List[Comment, Statement] = field(default=str) \n",
      "pred_parsed": "    body: List[Comment, Statement] = field(default=str)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "\n body: List[Comment, Statement] = field(default=global[list]) \n",
      "pred_parsed": "    body: List[Comment, Statement] = field(default=global[list])\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n body: list[Comment, Statement] = field(default=list) \n",
      "pred_parsed": "    body: list[Comment, Statement] = field(default=list)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n body: List[Comment, Statement] = field(default=field) \n",
      "pred_parsed": "    body: List[Comment, Statement] = field(default=field)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "Ultimaker/Uranium",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Ultimaker-Uranium",
    "commit": "f19f64136988856b95ba86888483c150f7c1a076",
    "filename": "UM/Settings/SettingFunction.py",
    "source_code": "        #  Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()  # type: frozenset[str]\n        self._used_values = frozenset()\n\n        self._compiled = None\n        self._valid = False  # type: str",
    "target_code": "        #  Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()  # type: FrozenSet[str]\n        self._used_values = frozenset() # type: FrozenSet[str]\n\n        self._compiled = None\n        self._valid = False  # type: bool\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `_valid` declared in class `SettingFunction` has type `str` but is used as type `bool`.",
    "warning_line": 39,
    "pred_top-1": {
      "pred": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n",
      "pred_parsed": "        # Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()\n        self._used_values = frozenset()\n        self._compiled = None\n        self._valid = False # type: bool\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() # type: frozenset[str] \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n",
      "pred_parsed": "        # Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset() # type: frozenset[str]\n        self._used_values = frozenset()\n        self._compiled = None\n        self._valid = False # type: bool\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() # type: frozenset[str] \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: str \n \n",
      "pred_parsed": "        # Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset() # type: frozenset[str]\n        self._used_values = frozenset()\n        self._compiled = None\n        self._valid = False # type: str\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() <DED> self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n",
      "pred_parsed": "        # Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()  self._used_values = frozenset()\n        self._compiled = None\n        self._valid = False # type: bool\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() \n self._used_values = frozenset() \n self._compiled = False \n self._valid = False # type: bool \n \n",
      "pred_parsed": "        # Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()\n        self._used_values = frozenset()\n        self._compiled = False\n        self._valid = False # type: bool\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "ConsenSys/mythril",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/ConsenSys-mythril",
    "commit": "d35bb7892f2ebde220103b105d49bf6ec8a5d5e6",
    "filename": "mythril/support/signatures.py",
    "source_code": "            # wait at least 2 mins to try again\n            self.online_lookup_timeout = time.time() + 2 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)",
    "target_code": "            # wait at least 2 mins to try again\n            <IND>self.online_lookup_timeout = int(time.time()) + 2 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `online_lookup_timeout` declared in class `SignatureDB` has type `int` but is used as type `float`.",
    "warning_line": 229,
    "pred_top-1": {
      "pred": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 2 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "pred_parsed": "            # wait at least 2 mins to try again\n            self.online_lookup_timeout = time.time() + 2 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + \"\" \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "pred_parsed": "            # wait at least 2 mins to try again\n            self.online_lookup_timeout = time.time() + \"\"\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 0 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "pred_parsed": "            # wait at least 2 mins to try again\n            self.online_lookup_timeout = time.time() + 0 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + '60' \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "pred_parsed": "            # wait at least 2 mins to try again\n            self.online_lookup_timeout = time.time() + '60'\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 0.5 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "pred_parsed": "            # wait at least 2 mins to try again\n            self.online_lookup_timeout = time.time() + 0.5 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "python/mypy",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/python-mypy",
    "commit": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "filename": "mypy/errors.py",
    "source_code": "    messages = None  # type: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker = None  # type: Optional[str]",
    "target_code": "\n    messages: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str] = None\n\n",
    "warning_type": "Incompatible attribute type [8]",
    "warning_message": " Attribute `messages` declared in class `CompileError` has type `List[str]` but is used as type `None`.",
    "warning_line": 730,
    "pred_top-1": {
      "pred": "\n messages: List[str] \n use_stdout: List[str] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "pred_parsed": "    messages: List[str]\n    use_stdout: List[str] = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "\n messages = None # type: Optional[List[str]] \n use_stdout = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker = None # type: Optional[str] \n \n",
      "pred_parsed": "    messages = None # type: Optional[List[str]]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker = None # type: Optional[str]\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "\n messages: List[str] \n use_stdout: Optional[stdout] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "pred_parsed": "    messages: List[str]\n    use_stdout: Optional[stdout] = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "\n messages: Optional[List[str]] \n use_stdout: Optional[False] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "pred_parsed": "    messages: Optional[List[str]]\n    use_stdout: Optional[False] = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "\n messages: Optional[List[str]] \n use_stdout: Optional[stdout] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "pred_parsed": "    messages: Optional[List[str]]\n    use_stdout: Optional[stdout] = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str]\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "optuna/optuna",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/optuna-optuna",
    "commit": "8917099bb57bb168116e0cb4343ddb82876abb04",
    "filename": "tests/storages_tests/test_storages.py",
    "source_code": "        else:\n            assert datetime_before < trial.datetime_start < datetime_after\n            assert trial.datetime_complete is None",
    "target_code": "        <DED>else:\n            <IND>assert trial.datetime_start is not None\n            assert trial.datetime_complete is None\n            assert datetime_before < trial.datetime_start < datetime_after\n\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `<` is not supported for operand types `typing.Optional[datetime]` and `datetime`.",
    "warning_line": 396,
    "pred_top-1": {
      "pred": "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n",
      "pred_parsed": "        else:\n            assert trial.datetime_complete is None\n            assert trial.datetime_complete is None\n            assert datetime_before  trial.datetime_start  datetime_after\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n",
      "pred_parsed": "        else:\n            assert trial.datetime_complete is None\n            assert trial.datetime_complete is None\n            assert trial.datetime_complete is None\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<DED> else: \n <IND> assert trial.datetime_start is not None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n",
      "pred_parsed": "        else:\n            assert trial.datetime_start is not None\n            assert trial.datetime_complete is None\n            assert datetime_before  trial.datetime_start  datetime_after\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n \n",
      "pred_parsed": "        else:\n            assert trial.datetime_complete is None\n            assert trial.datetime_complete is None\n            assert datetime_before  trial.datetime_start  datetime_after\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> else: \n <IND> assert trial.datetime_start is not None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n \n",
      "pred_parsed": "        else:\n            assert trial.datetime_start is not None\n            assert trial.datetime_complete is None\n            assert datetime_before  trial.datetime_start  datetime_after\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "jupyterhub/zero-to-jupyterhub-k8s",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/jupyterhub-zero-to-jupyterhub-k8s",
    "commit": "4e9b4a22f516a7f7545c1cfebe440f0b2dde5a6d",
    "filename": "images/hub/jupyterhub_config.py",
    "source_code": "    ):\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)",
    "target_code": "    ):\n        <IND>if cfg_key is None:\n            <IND>cfg_key = camelCaseify(trait)\n        <DED>set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `+` is not supported for operand types `str` and `typing.Optional[str]`.",
    "warning_line": 291,
    "pred_top-1": {
      "pred": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n",
      "pred_parsed": "    ):\n        assert cfg_key is not None\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "): \n <IND> assert cfg_authenticator is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n",
      "pred_parsed": "    ):\n        assert cfg_authenticator is not None\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.') \n",
      "pred_parsed": "    ):\n        assert cfg_key is not None\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.')\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-4": {
      "pred": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, cfg_key) \n",
      "pred_parsed": "    ):\n        assert cfg_key is not None\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, cfg_key)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-5": {
      "pred": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n \n",
      "pred_parsed": "    ):\n        assert cfg_key is not None\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "Ultimaker/Uranium",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/Ultimaker-Uranium",
    "commit": "cc9ae324e35ef54e418133f15dc30844a86aa963",
    "filename": "UM/TaskManagement/HttpRequestManager.py",
    "source_code": "        if self._enable_request_benchmarking:\n            time_spent = time.time() - request_data.start_time\n            Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",",
    "target_code": "        if self._enable_request_benchmarking:\n            <IND>time_spent = None  # type: Optional[float]\n            if request_data.start_time is not None:\n                <IND>time_spent = time.time() - request_data.start_time\n            <DED>Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `-` is not supported for operand types `float` and `Optional[float]`.",
    "warning_line": 340,
    "pred_top-1": {
      "pred": "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - Optional[request_data.start_time] \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "pred_parsed": "        if self._enable_request_benchmarking:\n            time_spent = time.time() - Optional[request_data.start_time]\n            Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-2": {
      "pred": "if self._enable_request_benchmarking: \n <IND> time_spent = float(time.time() - request_data.start_time) \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "pred_parsed": "        if self._enable_request_benchmarking:\n            time_spent = float(time.time() - request_data.start_time)\n            Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "if self._enable_request_benchmarking: \n <IND> if self._enable_request_benchmarking is not None: \n <IND> time_spent = time.time() - request_data.start_time \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "pred_parsed": "        if self._enable_request_benchmarking:\n            if self._enable_request_benchmarking is not None:\n                time_spent = time.time() - request_data.start_time\n                Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - request_data.start_time \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "pred_parsed": "        if self._enable_request_benchmarking:\n            time_spent = time.time() - request_data.start_time\n            Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - float(request_data.start_time) \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "pred_parsed": "        if self._enable_request_benchmarking:\n            time_spent = time.time() - float(request_data.start_time)\n            Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "dcs-liberation/dcs_liberation",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/dcs-liberation-dcs_liberation",
    "commit": "8eef1eaa7cdcd8f9672a93dc5e8f9771a1ce9a3d",
    "filename": "gen/flights/traveltime.py",
    "source_code": "                tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        return tot - travel_time - self.HOLD_TIME",
    "target_code": "                <IND>tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n                if tot is None:\n                    <IND>logging.error(f\"TOT waypoint for {flight} has no TOT\")\n                    tot = self.package.time_over_target\n        <DED><DED><DED>return tot - travel_time - self.HOLD_TIME\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `-` is not supported for operand types `Optional[timedelta]` and `timedelta`.",
    "warning_line": 136,
    "pred_top-1": {
      "pred": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - self.HOLD_TIME \n",
      "pred_parsed": "                tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        return tot - travel_time - self.HOLD_TIME\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> assert tot is not None \n return tot - travel_time - self.HOLD_TIME \n",
      "pred_parsed": "                tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        assert tot is not None\n        return tot - travel_time - self.HOLD_TIME\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - (self.HOLD_TIME) \n",
      "pred_parsed": "                tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        return tot - travel_time - (self.HOLD_TIME)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - str(self.HOLD_TIME) \n",
      "pred_parsed": "                tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        return tot - travel_time - str(self.HOLD_TIME)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - 0 \n",
      "pred_parsed": "                tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        return tot - travel_time - 0\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "common-workflow-language/cwltool",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/common-workflow-language-cwltool",
    "commit": "189a496366d46754f96c7aefa0db7f3e26bd5453",
    "filename": "tests/test_examples.py",
    "source_code": "    result = scatter_workflow(range=3)\n    assert \"output\" in result",
    "target_code": "    result = scatter_workflow(range=3)\n    assert isinstance(result, dict)\n    assert \"output\" in result\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `in` is not supported for right operand type `Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], typing.MutableSequence[Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], bool, float, int, str]], typing.MutableSequence[Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], typing.MutableSequence[Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], bool, float, int, str]], bool, float, int, str]], str]`.",
    "warning_line": 1378,
    "pred_top-1": {
      "pred": "result = scatter_workflow(range=3) \n assert \"output\" in result \n",
      "pred_parsed": "    result = scatter_workflow(range=3)\n    assert \"output\" in result\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "pred_parsed": "    result = scatter_workflow(range=3)\n    assert output is not None\n    assert output is not None\n    assert output is not None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "pred_parsed": "    result = scatter_workflow(range=3)\n    assert output is not None\n    assert output is not None\n    assert output is not None\n    assert output is not None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "pred_parsed": "    result = scatter_workflow(range=3)\n    assert output is not None\n    assert output is not None\n    assert output is not None\n    assert output is not None\n    assert output is not None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "pred_parsed": "    result = scatter_workflow(range=3)\n    assert output is not None\n    assert output is not None\n    assert output is not None\n    assert output is not None\n    assert output is not None\n    assert output is not None\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "datatheorem/strongarm",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/datatheorem-strongarm",
    "commit": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "filename": "strongarm/objc/objc_analyzer.py",
    "source_code": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = msgsend_idx - 3",
    "target_code": "        <DED>msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        if not msgsend_idx:\n            <IND>raise ValueError(f'instruction index not found for address {msgsend_instr.address}')\n\n        <DED>search_space_start_idx = msgsend_idx - 3\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `-` is not supported for operand types `Optional[int]` and `int`.",
    "warning_line": 317,
    "pred_top-1": {
      "pred": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n assert msgsend_idx is not None \n search_space_start_idx = msgsend_idx - 3 \n",
      "pred_parsed": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        assert msgsend_idx is not None\n        search_space_start_idx = msgsend_idx - 3\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n search_space_start_idx = int(msgsend_idx) - 3 \n",
      "pred_parsed": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = int(msgsend_idx) - 3\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n return self._get_instruction_index_of_address(msgsend_instr.address) \n search_space_start_idx = int(msgsend_idx) - 3 \n",
      "pred_parsed": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        return self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = int(msgsend_idx) - 3\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n return self._get_instruction_index_of_address(msgsend_instr.address) \n search_space_start_idx = msgsend_idx - 3 \n",
      "pred_parsed": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        return self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = msgsend_idx - 3\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n assert isinstance(msgsend_idx, int, search_space_start_idx) - 3 \n",
      "pred_parsed": "        msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        assert isinstance(msgsend_idx, int, search_space_start_idx) - 3\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "asyml/texar-pytorch",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/asyml-texar-pytorch",
    "commit": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "filename": "texar/torch/run/condition.py",
    "source_code": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training:\n            self.accumulated_time += time_now() - self.start_time",
    "target_code": "    <DED>def check_validation_begin(self, executor) -> bool:\n        <IND>if self.only_training and self.start_time is not None:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `-` is not supported for operand types `float` and `Optional[float]`.",
    "warning_line": 284,
    "pred_top-1": {
      "pred": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "pred_parsed": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training is not None:\n            self.accumulated_time += time_now() - self.start_time\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training and self.start_time is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "pred_parsed": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training and self.start_time is not None:\n            self.accumulated_time += time_now() - self.start_time\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-3": {
      "pred": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += float(time_now() - self.start_time) \n",
      "pred_parsed": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training is not None:\n            self.accumulated_time += float(time_now() - self.start_time)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "pred_parsed": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training is None:\n            self.accumulated_time += time_now() - self.start_time\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-5": {
      "pred": "<IND> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "pred_parsed": "    def check_validation_begin(self, executor) -> bool:\n        if self.only_training is not None:\n            self.accumulated_time += time_now() - self.start_time\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "top-1_removal": false,
    "top-3_removal": true,
    "top-5_removal": true
  },
  {
    "repo": "RhinoSecurityLabs/pacu",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/RhinoSecurityLabs-pacu",
    "commit": "54b0de44c8fc862e652d0efb54077d0d1385f333",
    "filename": "pacu/modules/cloudwatch__download_logs/main.py",
    "source_code": "        }\n    dl_root = downloads_dir() + '/cloud_watch_logs/'\n    summary_data['log_download_path'] = '{}{}'.format(dl_root, scan_time)",
    "target_code": "        }\n    <DED>dl_root = str(downloads_dir()) + '/cloud_watch_logs/'\n    summary_data['log_download_path'] = '{}{}'.format(dl_root, scan_time)\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `+` is not supported for operand types `pathlib.Path` and `str`.",
    "warning_line": 161,
    "pred_top-1": {
      "pred": "} \n <DED> dl_root = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "pred_parsed": "        }\n    dl_root = downloads_dir() + '/cloud_watch_logs/'\n    summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-2": {
      "pred": "} \n <DED> dl_root = downloads_dir() + str('/cloud_watch_logs/') \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "pred_parsed": "        }\n    dl_root = downloads_dir() + str('/cloud_watch_logs/')\n    summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-3": {
      "pred": "} \n <DED> dl_root = downloads_dir(pathlib.Path) + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "pred_parsed": "        }\n    dl_root = downloads_dir(pathlib.Path) + '/cloud_watch_logs/'\n    summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-4": {
      "pred": "} \n <IND> dl_root = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "pred_parsed": "        }\n            dl_root = downloads_dir() + '/cloud_watch_logs/'\n            summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "} \n <DED> dl_root_dir = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "pred_parsed": "        }\n    dl_root_dir = downloads_dir() + '/cloud_watch_logs/'\n    summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "top-1_removal": false,
    "top-3_removal": false,
    "top-5_removal": false
  },
  {
    "repo": "jupyterhub/zero-to-jupyterhub-k8s",
    "repo_dir": "/home/chowyi/TypeAnnotation_Study/GitHub/jupyterhub-zero-to-jupyterhub-k8s",
    "commit": "4e9b4a22f516a7f7545c1cfebe440f0b2dde5a6d",
    "filename": "images/hub/jupyterhub_config.py",
    "source_code": "    for trait, cfg_key in common_oauth_traits:\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)",
    "target_code": "    for trait, cfg_key in common_oauth_traits:\n        <IND>if cfg_key is None:\n            <IND>cfg_key = camelCaseify(trait)\n        <DED>set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
    "warning_type": "Unsupported operand [58]",
    "warning_message": " `+` is not supported for operand types `str` and `typing.Optional[str]`.",
    "warning_line": 279,
    "pred_top-1": {
      "pred": "for trait, cfg_key in common_oauth_traits: \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "pred_parsed": "    for trait, cfg_key in common_oauth_traits:\n        assert cfg_key is not None\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "pred_top-2": {
      "pred": "for trait, cfg_key in common_oauth_traits: \n <IND> assert isinstance(trait, cfg_key) \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "pred_parsed": "    for trait, cfg_key in common_oauth_traits:\n        assert isinstance(trait, cfg_key)\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-3": {
      "pred": "for trait, cfg_key in common_oauth_traits: \n <IND> assert c.GitLabOAuthenticator is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "pred_parsed": "    for trait, cfg_key in common_oauth_traits:\n        assert c.GitLabOAuthenticator is not None\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
      "warning_removed": false,
      "fail_reason": "Error Still Exists"
    },
    "pred_top-4": {
      "pred": "for trait, cfg_key in common_oauth_traits: \n <IND> assert cfg_authenticator is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "pred_parsed": "    for trait, cfg_key in common_oauth_traits:\n        assert cfg_authenticator is not None\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
      "warning_removed": false,
      "fail_reason": "New Error(s) Appear"
    },
    "pred_top-5": {
      "pred": "for trait, cfg_key in common_oauth_traits: \n <IND> assert c.GitLabOAuthenticator is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, cfg_key) \n",
      "pred_parsed": "    for trait, cfg_key in common_oauth_traits:\n        assert c.GitLabOAuthenticator is not None\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, cfg_key)\n",
      "warning_removed": true,
      "fail_reason": "N/A"
    },
    "top-1_removal": true,
    "top-3_removal": true,
    "top-5_removal": true
  }
]