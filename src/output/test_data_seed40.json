[
  {
    "source_code": "from zeus.utils.imports import import_submodules\n\nimport_submodules(locals(), __name__, __path__)\n",
    "target_code": "from .auth_github import *  # NOQA\nfrom .index import *  # NOQA\n",
    "warning_line": "import_submodules(locals(), __name__, __path__)",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `__path__` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 3,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "getsentry/zeus",
    "source_filename": "zeus/web/views/__init__.py",
    "target_filename": "zeus/web/views/__init__.py",
    "source_changeid": "95d4a82109fbc0d67f42caa85a198fecb9681a03^",
    "target_changeid": "95d4a82109fbc0d67f42caa85a198fecb9681a03",
    "predictions": [
      "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__, __path__) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__, __path__) \n",
      "1": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__) \n",
      "2": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__) \n \n",
      "3": "from.config.imports import import_submodules \n from.config.import_submodules \n import_submodules(locals(), __name__, __path__) \n \n",
      "4": "from.config.imports import import_submodules \n from.config.import_submodules \n \n import_submodules(locals(), __name__) \n"
    }
  },
  {
    "source_code": "    # internal API\n    <DED>@method_accepts(basestring, basestring, basestring, basestring,\n                    int, int, int, int, int)\n    @returns(basestring)\n    def __create_attribute_of_node_for_resource(self,\n",
    "target_code": "    # internal API\n    <DED>@method_accepts(str, str, str, str,\n                    int, int, int, int, int)\n    @returns(str)\n    def __create_attribute_of_node_for_resource(self,\n",
    "warning_line": "    @method_accepts(basestring, basestring, basestring, basestring,",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `basestring` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 94,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "grnet/synnefo",
    "source_filename": "commissioning/hlapi/api.py",
    "target_filename": "commissioning/hlapi/api.py",
    "source_changeid": "2004262b6fefba2c2fcb9e6672227c2aade49476^",
    "target_changeid": "2004262b6fefba2c2fcb9e6672227c2aade49476",
    "predictions": [
      "# internal API \n <DED> @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring, \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# internal API \n <DED> @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring, \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n",
      "1": "# internal API \n <DED> @method_accepts(method_accepts(basestring, basestring, method_accepts(basestring, basestring, basestring, \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(basestring)) \n def __create_attribute_of_node_for_resource(self, \n",
      "2": "# internal API \n <DED> @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring), \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n",
      "3": "# internal API \n <DED> @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring), \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(method_accepts(basestring))) \n def __create_attribute_of_node_for_resource(self, \n",
      "4": "# internal API \n <DED> @method_accepts(method_accepts(basestring, method_accepts(basestring, method_accepts(basestring, basestring, basestring), \n int, int, int, int, int) \n @returns(method_accepts(method_accepts(method_accepts(method_accepts(basestring), basestring)) \n def __create_attribute_of_node_for_resource(self, \n"
    }
  },
  {
    "source_code": "\n        data = {\"set_mode\": int(require_admin_approval), \"thread_fbid\": thread_id}\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
    "target_code": "\n        data = {\"set_mode\": int(require_admin_approval), \"thread_fbid\": self.id}\n        j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data)\n",
    "warning_line": "        data = {\"set_mode\": int(require_admin_approval), \"thread_fbid\": thread_id}",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `thread_id` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 122,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "fbchat-dev/fbchat",
    "source_filename": "fbchat/_group.py",
    "target_filename": "fbchat/_group.py",
    "source_changeid": "deda3b433d5759311fb8232f1d9b6db23a9d4372^",
    "target_changeid": "deda3b433d5759311fb8232f1d9b6db23a9d4372",
    "predictions": [
      "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": int(thread_id) } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": int(thread_id) } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "1": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": dpr } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "2": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": id } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "3": "\n data = { \"set_mode\": int(require_admin_approval), \"thread_fbid\": bool } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n",
      "4": "\n data = { \"set_mode\": int(require_admin_approval) } \n j = self.session._payload_post(\"/messaging/set_approval_mode/?dpr=1\", data) \n"
    }
  },
  {
    "source_code": "\nexecfile('nsot/version.py')\n\n",
    "target_code": "\nfrom nsot.version import __version__\n\n",
    "warning_line": "execfile('nsot/version.py')",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `execfile` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 17,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dropbox/nsot",
    "source_filename": "setup.py",
    "target_filename": "setup.py",
    "source_changeid": "84ba48d6c55286bc18194247072cfd956dfec69f^",
    "target_changeid": "84ba48d6c55286bc18194247072cfd956dfec69f",
    "predictions": [
      "\n execfile('nsot/version.py') \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n execfile('nsot/version.py') \n \n",
      "1": "\n execpath('nsot/version.py') \n \n",
      "2": "\n executil('nsot/version.py') \n \n",
      "3": "\n execfile('nsot/version.py', []) \n \n",
      "4": "\n 'nsot/version.py': \n \n"
    }
  },
  {
    "source_code": "  def __new__(cls,\n              output_dir: Text,\n              log_root: Text,\n              beam_pipeline_args: Optional[Text] = None):\n    <IND>cls.exec_properties = {\n",
    "target_code": "  def __new__(cls,\n              output_dir,\n              log_root,\n              beam_pipeline_args = None):\n    <IND>cls.exec_properties = {\n",
    "warning_line": "              output_dir: Text,",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `Text` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 40,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/tfx",
    "source_filename": "tfx/orchestration/kubeflow/base_component.py",
    "target_filename": "tfx/orchestration/kubeflow/base_component.py",
    "source_changeid": "3d7bb6a0ae0aa0ed6269c2e1f4d2bb3e8bee2a93^",
    "target_changeid": "3d7bb6a0ae0aa0ed6269c2e1f4d2bb3e8bee2a93",
    "predictions": [
      "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args: Optional[Text] = None): \n <IND> cls.exec_properties = { \n"
    ],
    "correct": false,
    "top_five": {
      "0": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args: Optional[Text] = None): \n <IND> cls.exec_properties = { \n",
      "1": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args = None): \n <IND> cls.exec_properties = { \n",
      "2": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args, \n beam_pipeline_args = None): \n <IND> cls.exec_properties = { \n",
      "3": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args, \n beam_pipeline_args: Optional[Text] = None): \n <IND> cls.exec_properties = { \n",
      "4": "def __new__(cls, \n output_dir, \n log_root, \n beam_pipeline_args, \n beam_pipeline_args, \n ): \n <IND> cls.exec_properties = { \n"
    }
  },
  {
    "source_code": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: Set[int] = set()\n\n",
    "target_code": "    limiter = trio.CapacityLimiter(max_concurrent)\n    remaining_tasks: t.Set[int] = set()\n\n",
    "warning_line": "    remaining_tasks: Set[int] = set()",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `Set` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 223,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "python-mario/mario",
    "source_filename": "src/mario/traversals.py",
    "target_filename": "src/mario/traversals.py",
    "source_changeid": "7e9dc5cb9351a2f07d2b0bfcdf3a2fc2e972f962^",
    "target_changeid": "7e9dc5cb9351a2f07d2b0bfcdf3a2fc2e972f962",
    "predictions": [
      "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Optional[Set[int]] = set() \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Optional[Set[int]] = set() \n \n",
      "1": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Optional[Set] = set() \n \n",
      "2": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Int = set() \n \n",
      "3": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Row[int] = set() \n \n",
      "4": "limiter = trio.CapacityLimiter(max_concurrent) \n remaining_tasks: Trio[int] = set() \n \n"
    }
  },
  {
    "source_code": "        if res.createProject.error:\n            <IND>raise ClientError(result.createProject.error)\n\n",
    "target_code": "        if res.createProject.error:\n            <IND>raise ClientError(res.createProject.error)\n\n",
    "warning_line": "            raise ClientError(result.createProject.error)",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `result` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 389,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PrefectHQ/prefect",
    "source_filename": "src/prefect/client/client.py",
    "target_filename": "src/prefect/client/client.py",
    "source_changeid": "7738c57aea2ca1f4847e2106fbf6d6f3279aaa6c^",
    "target_changeid": "7738c57aea2ca1f4847e2106fbf6d6f3279aaa6c",
    "predictions": [
      "if res.createProject.error: \n <IND> raise ClientError('Unable to create project', result.createProject.error) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if res.createProject.error: \n <IND> raise ClientError('Unable to create project', result.createProject.error) \n \n",
      "1": "if res.createProject.error: \n <IND> raise ClientError('Unable to create Project', result.createProject.error) \n \n",
      "2": "if res.createProject.error: \n <IND> raise ClientError('Unable to create project') \n \n",
      "3": "if res.createProject.error: \n <IND> raise ClientError(\"Unable to create project due to a failure\") \n \n",
      "4": "if res.createProject.error: \n <IND> raise ClientError('Unable to create project', result.createProject.error') \n \n"
    }
  },
  {
    "source_code": "\n    raw_input('finished')\n",
    "target_code": "\n    input('finished')\n",
    "warning_line": "    raw_input('finished')",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 160,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/cahnHilliard/tanh1D.py",
    "target_filename": "examples/cahnHilliard/tanh1D.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "\n input('finished') \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n input('finished') \n \n",
      "1": "\n input('finished') \n \n \n",
      "2": "\n input('finished') \n \n <DED> \n",
      "3": "\n input('finished') \n \n \n \n",
      "4": "\n input('finished') \n \n <IND> \n"
    }
  },
  {
    "source_code": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \"{method}\" are configured '\n            f'for API \"{api_version}\"',\n        )\n",
    "target_code": "            logging.CRITICAL,\n            f'Unknown authentication method(s) \"{method}\" are configured ',\n        )\n",
    "warning_line": "            f'for API \"{api_version}\"',",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `api_version` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 315,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tableau/TabPy",
    "source_filename": "tabpy/tabpy_server/handlers/base_handler.py",
    "target_filename": "tabpy/tabpy_server/handlers/base_handler.py",
    "source_changeid": "38fde421c5a8e1e5b8a28e22aff6f2acb8f25aa4^",
    "target_changeid": "38fde421c5a8e1e5b8a28e22aff6f2acb8f25aa4",
    "predictions": [
      "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { api_version } \"', \n ) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { api_version } \"', \n ) \n",
      "1": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { version } \"', \n ) \n",
      "2": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { sys.api_version } \"', \n ) \n",
      "3": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { f', \n ) \n",
      "4": "logging.CRITICAL, \n f'Unknown authentication method(s) \" { method } \" are configured'\n f'for API \" { python_version } \"', \n ) \n"
    }
  },
  {
    "source_code": "    exec(fipy.tests.doctestPlus._getScript())\n    raw_input(\"finished\")\n",
    "target_code": "    exec(fipy.tests.doctestPlus._getScript())\n    input(\"finished\")\n",
    "warning_line": "    raw_input(\"finished\")",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 81,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/levelSet/advection/mesh1D.py",
    "target_filename": "examples/levelSet/advection/mesh1D.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n \n",
      "1": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n",
      "2": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n \n \n",
      "3": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n <IND>",
      "4": "exec(fipy.tests.doctestPlus._getScript()) \n input(\"finished\") \n <DED> \n"
    }
  },
  {
    "source_code": "<DED><DED>_BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT,_UPDATE = xrange(8)\n\n",
    "target_code": "<DED><DED>_BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT,_UPDATE = range(8)\n\n",
    "warning_line": "_UPDATE = xrange(8)",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `xrange` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 296,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "wrye-bash/wrye-bash",
    "source_filename": "Mopy/bash/basher/frames.py",
    "target_filename": "Mopy/bash/basher/frames.py",
    "source_changeid": "65bac9cf90d11d24003971cbe457a93e7138c211^",
    "target_changeid": "65bac9cf90d11d24003971cbe457a93e7138c211",
    "predictions": [
      "<DED> <DED> _BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE = xrange(8) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> <DED> _BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE = xrange(8) \n \n",
      "1": "<DED> <DED> _BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE = xrange(8) \n \n",
      "2": "<DED> <DED> _BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE) \n \n",
      "3": "<DED> <DED> _BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE = 8 \n \n",
      "4": "\n <DED> <DED> _BACK, _FORWARD, _MOD_LIST, _CRC, _VERSION, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE, _LOAD_PLUGINS, _COPY_TEXT, _UPDATE = xrange(8) \n \n"
    }
  },
  {
    "source_code": "\n    raw_input(\"finished\")\n",
    "target_code": "\n    input(\"finished\")\n",
    "warning_line": "    raw_input(\"finished\")",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 181,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/elphf/phase.py",
    "target_filename": "examples/elphf/phase.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "\n input(\"finished\") \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n input(\"finished\") \n \n",
      "1": "\n input(\"finished\") \n",
      "2": "\n input(\"finished\") \n \n \n",
      "3": "\n input(\"finished\") \n <DED> \n",
      "4": "\n input(\"finished\") \n <IND> \n"
    }
  },
  {
    "source_code": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n                   (u'skills', [0 for _x in xrange(21)]), u'health',\n                   u'unused2', (u'attributes', [0 for _y in xrange(8)])),\n        MelFid(b'HNAM', 'hair'),\n",
    "target_code": "        MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'],\n                   (u'skills', [0 for _x in range(21)]), u'health',\n                   u'unused2', (u'attributes', [0 for _y in range(8)])),\n        MelFid(b'HNAM', 'hair'),\n",
    "warning_line": "                   (u'skills', [0 for _x in xrange(21)]), u'health',",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `xrange` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1390,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "wrye-bash/wrye-bash",
    "source_filename": "Mopy/bash/game/oblivion/records.py",
    "target_filename": "Mopy/bash/game/oblivion/records.py",
    "source_changeid": "65bac9cf90d11d24003971cbe457a93e7138c211^",
    "target_changeid": "65bac9cf90d11d24003971cbe457a93e7138c211",
    "predictions": [
      "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(8)])), \n MelFid(b'HNAM', 'hair'), \n"
    ],
    "correct": false,
    "top_five": {
      "0": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(8)])), \n MelFid(b'HNAM', 'hair'), \n",
      "1": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(21)])), \n MelFid(b'HNAM', 'hair'), \n",
      "2": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _x in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(21)])), \n MelFid(b'HNAM', 'hair'), \n",
      "3": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _x in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range(8)])), \n MelFid(b'HNAM', 'hair'), \n",
      "4": "MelNpcData(b'DATA', [u'21B', u'H', u'2s', u'8B'], \n (u'skills', [0 for _y in range(21)]), u'health', \n u'unused2', (u'attributes', [0 for _y in range((8)]))), \n MelFid(b'HNAM', 'hair'), \n"
    }
  },
  {
    "source_code": "\n    raw_input(\"finished\")\n",
    "target_code": "\n    input(\"finished\")\n",
    "warning_line": "    raw_input(\"finished\")",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 181,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/diffusion/electrostatics.py",
    "target_filename": "examples/diffusion/electrostatics.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "\n input(\"finished\") \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n input(\"finished\") \n \n",
      "1": "\n input(\"finished\") \n",
      "2": "\n input(\"finished\") \n \n \n",
      "3": "\n input(\"finished\") \n <DED> \n",
      "4": "\n input(\"finished\") \n <IND> \n"
    }
  },
  {
    "source_code": "    <DED>else:\n\t\t\t\t\t<IND>raise Error(True, \"Debugger must be run inside a sublime project\")\n\n",
    "target_code": "    <DED>else:\n\t\t\t\t\t<IND>raise core.Error(\"Debugger must be run inside a sublime project\")\n\n",
    "warning_line": "\t\t\t\t\traise Error(True, \"Debugger must be run inside a sublime project\")",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `Error` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 169,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "daveleroy/sublime_debugger",
    "source_filename": "modules/debugger/debugger_interface.py",
    "target_filename": "modules/debugger/debugger_interface.py",
    "source_changeid": "d410a39c5313babd215d70bc996303648cf639fe^",
    "target_changeid": "d410a39c5313babd215d70bc996303648cf639fe",
    "predictions": [
      "<DED> else: \n <IND> raise Error(True, \"Debugger must be run inside a sublime project\") \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> else: \n <IND> raise Error(True, \"Debugger must be run inside a sublime project\") \n \n",
      "1": "<DED> else: \n <IND> raise Error(False, \"Debugger must be run inside a sublime project\") \n \n",
      "2": "\n <DED> else: \n <IND> raise Error(True, \"Debugger must be run inside a sublime project\") \n \n",
      "3": "<IND> else: \n <IND> raise Error(True, \"Debugger must be run inside a sublime project\") \n \n",
      "4": "<DED> else: \n <IND> raise Error(True, \"Debugger must be run inside a sublime project\") \n <DED>"
    }
  },
  {
    "source_code": "        type = self.parse_type()\n        return StarType(type, line)\n\n",
    "target_code": "        type = self.parse_type()\n        return StarType(type, star.line)\n\n",
    "warning_line": "        return StarType(type, line)",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `line` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 153,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "python/mypy",
    "source_filename": "mypy/parsetype.py",
    "target_filename": "mypy/parsetype.py",
    "source_changeid": "5938c9212918aadbf26300ab52c6fe7173a35da7^",
    "target_changeid": "5938c9212918aadbf26300ab52c6fe7173a35da7",
    "predictions": [
      "type = self.parse_type() \n return StarType(type, str(line)) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "type = self.parse_type() \n return StarType(type, str(line)) \n \n",
      "1": "type = self.parse_type() \n return StarType(type, str) \n \n",
      "2": "type = self.parse_type() \n return StarType(type, str(type), line) \n \n",
      "3": "type = self.parse_type() \n return StarType(type) \n \n",
      "4": "type = self.parse_type() \n return StarType(type, 'line') \n \n"
    }
  },
  {
    "source_code": "\n    fig.savefig(snakemake.output.only_map, dpi=150,\n                bbox_inches='tight', bbox_extra_artists=[l1,l2,l3])\n\n",
    "target_code": "\n    fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight')\n\n",
    "warning_line": "                bbox_inches='tight', bbox_extra_artists=[l1,l2,l3])",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `l1` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 277,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PyPSA/pypsa-eur",
    "source_filename": "scripts/plot_network.py",
    "target_filename": "scripts/plot_network.py",
    "source_changeid": "eaf30a9b6552a9cc1b53d5ef94d677553656d854^",
    "target_changeid": "eaf30a9b6552a9cc1b53d5ef94d677553656d854",
    "predictions": [
      "\n fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight') \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight') \n \n",
      "1": "\n fig.savefig(snakemake.output.only_map, dpi=150, \n bbox_inches='tight') \n \n",
      "2": "\n fig.savefig(snakemake.output.only_map, dpi=150) \n bbox_inches='tight' \n bbox_extra_artists=[l1,l2,l3] \n",
      "3": "\n fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight', bbox_extra_artists=[l1,l2,l3]) \n \n",
      "4": "\n fig.savefig(snakemake.output.only_map, dpi=150) \n bbox_inches='tight' \n \n"
    }
  },
  {
    "source_code": "    <IND>if args.visualize:\n        <IND>hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))\n\n",
    "target_code": "    <IND>if args.visualize:\n        <IND>hetr.register_graph_pass(ng.transformers.passes.nviz.VizPass(show_all_metadata=True))\n\n",
    "warning_line": "        hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True))",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `ng` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 83,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "NervanaSystems/ngraph-python",
    "source_filename": "examples/dist_hetr.py",
    "target_filename": "examples/dist_hetr.py",
    "source_changeid": "1898ddba881de3a0b4a8132205b936609ac69a44^",
    "target_changeid": "1898ddba881de3a0b4a8132205b936609ac69a44",
    "predictions": [
      "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "1": "<IND> if args.visualize: \n <IND> if args.visualize: \n <IND> hetr.register_graph_pass(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "2": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(t.ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "3": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(str(ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n",
      "4": "<IND> if args.visualize: \n <IND> hetr.register_graph_pass(v=ngraph.transformers.passes.nviz.VizPass(show_all_metadata=True)) \n \n"
    }
  },
  {
    "source_code": "\n    fig.savefig(snakemake.output.only_map, dpi=150,\n                bbox_inches='tight', bbox_extra_artists=[l1,l2,l3])\n\n",
    "target_code": "\n    fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight')\n\n",
    "warning_line": "                bbox_inches='tight', bbox_extra_artists=[l1,l2,l3])",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `l2` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 277,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PyPSA/pypsa-eur",
    "source_filename": "scripts/plot_network.py",
    "target_filename": "scripts/plot_network.py",
    "source_changeid": "eaf30a9b6552a9cc1b53d5ef94d677553656d854^",
    "target_changeid": "eaf30a9b6552a9cc1b53d5ef94d677553656d854",
    "predictions": [
      "\n fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight') \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n fig.savefig(snakemake.output.only_map, dpi=150, bbox_inches='tight') \n \n",
      "1": "\n fig.savefig(snakemake.output.only_map, dpi=150, \n bbox_inches='tight') \n \n",
      "2": "\n fig.savefig(snakemake.output.only_map, dpi=150) \n bbox_inches='tight' \n bbox_extra_artists=[l1,l2,l3] \n",
      "3": "\n fig.savefig(snakemake.output.only_map, dpi=150) \n bbox_inches='tight' \n \n",
      "4": "\n fig.savefig(snakemake.output.only_map, dpi=150) \n bbox_inches='tight' \n bbox_extra_artists=bbox_extra_artists) \n \n"
    }
  },
  {
    "source_code": "    viewer.plot()\n    raw_input(\"finished\")\n",
    "target_code": "    viewer.plot()\n    input(\"finished\")\n\n",
    "warning_line": "    raw_input(\"finished\")",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 47,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/diffusion/steadyState/mesh50x50/tri2Dinput.py",
    "target_filename": "examples/diffusion/steadyState/mesh50x50/tri2Dinput.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "viewer.plot() \n input(\"finished\") \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "viewer.plot() \n input(\"finished\") \n \n",
      "1": "viewer.plot() \n input(\"finished\") \n \n \n",
      "2": "viewer.plot() \n input(\"finished\") \n",
      "3": "viewer.plot() \n input(\"finished\") \n <DED> \n",
      "4": "viewer.plot() \n input(\"finished\") \n \n <DED> \n"
    }
  },
  {
    "source_code": "\n    <DED>@wsme_pecan.wsexpose(ChassisCollection, unicode, int, unicode, unicode)\n    def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'):\n",
    "target_code": "\n    <DED>@wsme_pecan.wsexpose(ChassisCollection, wtypes.text,\n                         int, wtypes.text, wtypes.text)\n    def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'):\n",
    "warning_line": "    @wsme_pecan.wsexpose(ChassisCollection, unicode, int, unicode, unicode)",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `unicode` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 139,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "openstack/ironic",
    "source_filename": "ironic/api/controllers/v1/chassis.py",
    "target_filename": "ironic/api/controllers/v1/chassis.py",
    "source_changeid": "6aec2c18ba7abf06f24ad5c9431c6395eac41f18^",
    "target_changeid": "6aec2c18ba7abf06f24ad5c9431c6395eac41f18",
    "predictions": [
      "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int, unicode, int) \n def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int, unicode, int) \n def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'): \n",
      "1": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int) \n def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'): \n",
      "2": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int, unicode: int) \n def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'): \n",
      "3": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, unicode: int) \n def get_all(self, marker=None, limit:None, sort_key='id', sort_dir='asc'): \n",
      "4": "\n <DED> @wsme_pecan.wsexpose(ChassisCollection, int: int, int: int, unicode: int) \n def get_all(self, marker=None, limit=None, sort_key='id', sort_dir='asc'): \n"
    }
  },
  {
    "source_code": "    <IND>\"\"\"WSGI controller for object requests.\"\"\"\n    server_type = _('Object')\n\n",
    "target_code": "    <IND>\"\"\"WSGI controller for object requests.\"\"\"\n    server_type = 'Object'\n\n",
    "warning_line": "    server_type = _('Object')",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `_` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 235,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "openstack/swift",
    "source_filename": "swift/proxy/controllers/obj.py",
    "target_filename": "swift/proxy/controllers/obj.py",
    "source_changeid": "2a38a040924b621bce4e999b3c7dab692f497a21^",
    "target_changeid": "2a38a040924b621bce4e999b3c7dab692f497a21",
    "predictions": [
      "<IND> \"\"\"WSGI controller for object requests.\"\"\" \n server_type = 'Object' \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> \"\"\"WSGI controller for object requests.\"\"\" \n server_type = 'Object' \n \n",
      "1": "<IND> \"\"\"WSGI controller for object requests.\"\"\" \n server_type = 'object' \n \n",
      "2": "<IND> \"\"\"WSGI controller for object requests.\"\"\" \n server_type = Object \n \n",
      "3": "<IND> \"\"\"WSGI controller for object requests.\"\"\" \n server_type = \"Object\" \n \n",
      "4": "<DED> \"\"\"WSGI controller for object requests.\"\"\" \n server_type = 'Object' \n \n"
    }
  },
  {
    "source_code": "\n    <DED>raw_input(\"finished\")\n",
    "target_code": "\n    <DED>input(\"finished\")\n",
    "warning_line": "    raw_input(\"finished\")",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 151,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/levelSet/electroChem/adsorption.py",
    "target_filename": "examples/levelSet/electroChem/adsorption.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "\n <DED> input(\"finished\") \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> input(\"finished\") \n",
      "1": "\n <DED> input(\"finished\") \n \n",
      "2": "\n <DED> input(\"finished\") \n <DED> \n",
      "3": "\n <DED> input(\"finished\") \n <IND>",
      "4": "\n <IND> input(\"finished\") \n"
    }
  },
  {
    "source_code": "    viewer.plot()\n    raw_input('finished')\n",
    "target_code": "    viewer.plot()\n    input('finished')\n\n\n",
    "warning_line": "    raw_input('finished')",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `raw_input` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 68,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "usnistgov/fipy",
    "source_filename": "examples/levelSet/distanceFunction/interior.py",
    "target_filename": "examples/levelSet/distanceFunction/interior.py",
    "source_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787^",
    "target_changeid": "ccec299e7c00058b92e0c2d863f4a27c1eb2b787",
    "predictions": [
      "viewer.plot() \n input('finished') \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "viewer.plot() \n input('finished') \n \n",
      "1": "viewer.plot() \n input('finished') \n \n \n",
      "2": "viewer.plot() \n input('finished') \n \n \n \n",
      "3": "viewer.plot() \n input('finished') \n \n <IND> \n",
      "4": "viewer.plot() \n input('finished') \n \n <DED> \n"
    }
  },
  {
    "source_code": "                            \"Severity\": {\"Label\": \"INFORMATIONAL\"},\n                            \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\",\n                            \"Description\": \"CloudFront Distribution \"\n                            + cfId\n                            + \" has not been indexed by Shodan.\",\n",
    "target_code": "                            \"Severity\": {\"Label\": \"INFORMATIONAL\"},\n                            \"Title\": \"[Shodan.GlobalAccelerator.1] Accelerators should be monitored for being indexed by Shodan\",\n                            \"Description\": \"Accelerator \"\n                            + gaxName\n                            + \" has not been indexed by Shodan.\",\n",
    "warning_line": "                            + cfId",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `cfId` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1280,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jonrau1/ElectricEye",
    "source_filename": "eeauditor/auditors/aws/Shodan_Auditor.py",
    "target_filename": "eeauditor/auditors/aws/Shodan_Auditor.py",
    "source_changeid": "d1aef27493d0202aebb0a0ec85cf1de9afb9f625^",
    "target_changeid": "d1aef27493d0202aebb0a0ec85cf1de9afb9f625",
    "predictions": [
      "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + \" has not been indexed by Shodan.\", \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + \" has not been indexed by Shodan.\", \n",
      "1": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + cfId \n + \" has not been indexed by Shodan.\", \n",
      "2": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\", \n + \" has not been indexed by Shodan.\", \n",
      "3": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should not be indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + \" has not been indexed by Shodan.\", \n",
      "4": "\"Severity\": { \"Label\": \"INFORMATIONAL\" }, \n \"Title\": \"[Shodan.CloudFront.1] CloudFront Distributions should be monitored for being indexed by Shodan\", \n \"Description\": \"CloudFront Distribution\" \n + cfId <DED> \n + \" has not been indexed by Shodan.\", \n"
    }
  },
  {
    "source_code": "\n    <DED><DED>@wsme_pecan.wsexpose(PortCollection, unicode, unicode, int,\n                         unicode, unicode)\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
    "target_code": "\n    <DED><DED>@wsme_pecan.wsexpose(PortCollection, wtypes.text, wtypes.text, int,\n                         wtypes.text, wtypes.text)\n    def get_all(self, node_id=None, marker=None, limit=None,\n",
    "warning_line": "    @wsme_pecan.wsexpose(PortCollection, unicode, unicode, int,",
    "linter_report": {
      "rule_id": "Unbound name [10]",
      "message": " Name `unicode` is used but not defined in the current scope.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 169,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "openstack/ironic",
    "source_filename": "ironic/api/controllers/v1/port.py",
    "target_filename": "ironic/api/controllers/v1/port.py",
    "source_changeid": "6aec2c18ba7abf06f24ad5c9431c6395eac41f18^",
    "target_changeid": "6aec2c18ba7abf06f24ad5c9431c6395eac41f18",
    "predictions": [
      "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, int, \n unicode, int) \n def get_all(self, node_id=None, marker=None, limit=None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, int, \n unicode, int) \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "1": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, unicode, int, \n unicode, int) \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "2": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(unicode), int, \n unicode, wsme_pecan.wsexpose(PortCollection, unicode)) \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "3": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(unicode), int, \n unicode, wsme_pecan.wsexpose(PortCollection, unicode, int, \n def get_all(self, node_id=None, marker=None, limit=None, \n",
      "4": "\n <DED> <DED> @wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(PortCollection, unicode, wsme_pecan.wsexpose(Unicode, wsme_pecan.wsexpose(PortCollection), int, \n unicode, wsme_pecan.wsexpose(PortCollection), \n def get_all(self, node_id=None, marker=None, limit=None, \n"
    }
  },
  {
    "source_code": "\n    __slots__ = ('__weakref__',)\n\n",
    "target_code": "\n    __slots__ = BaseUser.__slots__ + ('__weakref__',)\n\n",
    "warning_line": "    __slots__ = ('__weakref__',)",
    "linter_report": {
      "rule_id": "Inconsistent override [15]",
      "message": " `__slots__` overrides attribute defined in `BaseUser` inconsistently. Type `typing.Tuple[str]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str, str, str, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 653,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Rapptz/discord.py",
    "source_filename": "discord/user.py",
    "target_filename": "discord/user.py",
    "source_changeid": "e75c248a9a41e14639dc4c032cea47867c886ec0^",
    "target_changeid": "e75c248a9a41e14639dc4c032cea47867c886ec0",
    "predictions": [
      "\n __slots__ = BaseUser.__slots__ + ('__weakref__',) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n __slots__ = BaseUser.__slots__ + ('__weakref__',) \n \n",
      "1": "\n __slots__ = BaseUser.__slots__ \n \n",
      "2": "\n __slots__ = BaseUser.__slots__ = ('__weakref__',) \n \n",
      "3": "\n __slots__ = BaseUser.__slots__ + ('__weakref__',) \n <DED>",
      "4": "\n __slots__ = BaseUser.__slots__ + ('__weakref__',) \n <IND>"
    }
  },
  {
    "source_code": "    fields = (\n        (\"Timestamp (UTC)\", \"timestamp\"),\n        (\"Date (DD/MM/YY\", \"date\"),\n",
    "target_code": "    fields = (\n        (\"Timestamp (UTC)\", \"timestamp\", timestamp),\n        (\"Date (DD/MM/YY\", \"date\"),\n",
    "warning_line": "    fields = (",
    "linter_report": {
      "rule_id": "Inconsistent override [15]",
      "message": " `fields` overrides attribute defined in `pynmea2.nmea.NMEASentence` inconsistently. Type `typing.Tuple[typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str], typing.Tuple[str, str]]` is not a subtype of the overridden attribute `typing.Tuple[]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 387,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Knio/pynmea2",
    "source_filename": "pynmea2/types/talker.py",
    "target_filename": "pynmea2/types/talker.py",
    "source_changeid": "b52decfa23d8482b072e42507692533666c4151e^",
    "target_changeid": "b52decfa23d8482b072e42507692533666c4151e",
    "predictions": [
      "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n"
    ],
    "correct": false,
    "top_five": {
      "0": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n",
      "1": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"Date (DD/MM/YY\", \"date\"), \n",
      "2": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"date\"), \n",
      "3": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"date\"), \n",
      "4": "fields = ( \n (\"Timestamp (UTC)\", \"timestamp\"), \n (\"Date (DD/MM/YY\", \"date\"), \n \"Date (DD/MM/YY\", \"date\"), \n \"Date (DD/MM/YY\", \"date\"), \n"
    }
  },
  {
    "source_code": "\n        <DED>def close(self) -> None:\n            <IND>if self._session:\n",
    "target_code": "\n        <DED>async def close(self) -> None:\n            <IND>if self._session:\n",
    "warning_line": "        def close(self) -> None:",
    "linter_report": {
      "rule_id": "Inconsistent override [15]",
      "message": " `auth.gcloud.aio.auth.session.SyncSession.close` overrides method defined in `BaseSession` inconsistently. Returned type `None` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, None]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 206,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "talkiq/gcloud-aio",
    "source_filename": "auth/gcloud/aio/auth/session.py",
    "target_filename": "auth/gcloud/aio/auth/session.py",
    "source_changeid": "82af90a9877490b01daff1af609a39a2525d2db2^",
    "target_changeid": "82af90a9877490b01daff1af609a39a2525d2db2",
    "predictions": [
      "\n <DED> def close(self) -> BaseSession: \n <IND> if self._session: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def close(self) -> BaseSession: \n <IND> if self._session: \n",
      "1": "\n <DED> def close(self) -> SyncSession: \n <IND> if self._session: \n",
      "2": "\n <DED> def close(self) -> BasicSession: \n <IND> if self._session: \n",
      "3": "\n <DED> def close(self) -> SyncSession(None): \n <IND> if self._session: \n",
      "4": "\n <DED> def close(self) -> BaseSession(None): \n <IND> if self._session: \n"
    }
  },
  {
    "source_code": "<DED>class IteratorWrapperSeparate(IteratorWrapper):\n    <IND>@threaded_separate\n    def _run(self) -> None:\n        <IND>return self._in_thread()\n\n",
    "target_code": "<DED>class IteratorWrapperSeparate(IteratorWrapper):\n    <IND>async def _run(self) -> Any:\n        <IND>return await run_in_new_thread(self._in_thread)\n\n",
    "warning_line": "    def _run(self) -> None:",
    "linter_report": {
      "rule_id": "Inconsistent override [15]",
      "message": " `aiomisc.thread_pool.IteratorWrapperSeparate._run` overrides method defined in `IteratorWrapper` inconsistently. Returned type `typing.Awaitable[typing.Any]` is not a subtype of the overridden return `typing.Coroutine[typing.Any, typing.Any, typing.Any]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 334,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "aiokitchen/aiomisc",
    "source_filename": "aiomisc/thread_pool.py",
    "target_filename": "aiomisc/thread_pool.py",
    "source_changeid": "83c3493c88e439a1616850842664c156ef219e93^",
    "target_changeid": "83c3493c88e439a1616850842664c156ef219e93",
    "predictions": [
      "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n",
      "1": "<IND> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n",
      "2": "\n class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> None: \n <IND> return self._in_thread() \n \n",
      "3": "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> str: \n <IND> return self._in_thread() \n \n",
      "4": "<DED> class IteratorWrapperSeparate(IteratorWrapper): \n <IND> @threaded_separate \n def _run(self) -> '': \n <IND> return self._in_thread() \n \n"
    }
  },
  {
    "source_code": "\n    __slots__ = ('email', 'locale', '_flags', 'verified', 'mfa_enabled',\n                 'premium', 'premium_type', '_relationships', '__weakref__')\n",
    "target_code": "\n    __slots__ = BaseUser.__slots__ +                ('email', 'locale', '_flags', 'verified', 'mfa_enabled',\n                 'premium', 'premium_type', '_relationships', '__weakref__')\n",
    "warning_line": "    __slots__ = ('email', 'locale', '_flags', 'verified', 'mfa_enabled',",
    "linter_report": {
      "rule_id": "Inconsistent override [15]",
      "message": " `__slots__` overrides attribute defined in `BaseUser` inconsistently. Type `typing.Tuple[str, str, str, str, str, str, str, str, str]` is not a subtype of the overridden attribute `typing.Tuple[str, str, str, str, str, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 297,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "nextcord/nextcord",
    "source_filename": "discord/user.py",
    "target_filename": "discord/user.py",
    "source_changeid": "e75c248a9a41e14639dc4c032cea47867c886ec0^",
    "target_changeid": "e75c248a9a41e14639dc4c032cea47867c886ec0",
    "predictions": [
      "\n __slots__ = BaseUser.__slots__ + ('email', 'locale', '_flags','verified','mfa_enabled', \n 'premium', 'premium_type', '_relationships', '__weakref__') \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n __slots__ = BaseUser.__slots__ + ('email', 'locale', '_flags','verified','mfa_enabled', \n 'premium', 'premium_type', '_relationships', '__weakref__') \n",
      "1": "\n __slots__ = BaseUser.__slots__ + ('email', 'locale', '_flags','verified','mfa_enabled', \n 'premium', 'premium_type', '_relationships', '__weakref__') \n \n",
      "2": "\n __slots__ = BaseUser.__slots__ + ('email', 'locale', '_flags','verified','mfa_enabled', \n '_relationships', '__weakref__') \n",
      "3": "\n __slots__ = BaseUser.__slots__ + ('email', 'locale', '_flags','verified','mfa_enabled', \n 'premium', 'premium_type', '_relationships', '__weakref__') \n <IND>",
      "4": "\n __slots__ = BaseUser.__slots__, ('email', 'locale', '_flags','verified','mfa_enabled', \n 'premium', 'premium_type', '_relationships', '__weakref__') \n"
    }
  },
  {
    "source_code": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    <IND>subscription_msg_types = {commands.NewBlock}\n",
    "target_code": "class ETHChainTipMonitor(BaseChainTipMonitor):\n    <IND>subscription_msg_types = frozenset({commands.NewBlock})\n",
    "warning_line": "    subscription_msg_types = {commands.NewBlock}",
    "linter_report": {
      "rule_id": "Inconsistent override [15]",
      "message": " `subscription_msg_types` overrides attribute defined in `p2p.peer.PeerSubscriber` inconsistently. Type `typing.Set[typing.Type[commands.NewBlock]]` is not a subtype of the overridden attribute `typing.Set[typing.Type[p2p.protocol.Command]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 6,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ethereum/trinity",
    "source_filename": "trinity/protocol/eth/monitors.py",
    "target_filename": "trinity/protocol/eth/monitors.py",
    "source_changeid": "ad61361109f7df88eb807a543191d491e76eed0c^",
    "target_changeid": "ad61361109f7df88eb807a543191d491e76eed0c",
    "predictions": [
      "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n",
      "1": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n",
      "2": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } \n",
      "3": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } \n ) \n",
      "4": "class ETHChainTipMonitor(BaseChainTipMonitor): \n <IND> subscription_msg_types = set( { commands.NewBlock } ) \n \n"
    }
  },
  {
    "source_code": "\n<DED><DED><DED>def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=None) -> int:\n    <IND>\"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
    "target_code": "\n<DED><DED><DED>def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=\"\") -> int:\n    <IND>\"\"\"Takes stuff and returns the number of items taken\"\"\"\n",
    "warning_line": "def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=None) -> int:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " where_str is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 450,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "irmen/Tale",
    "source_filename": "tale/cmds/normal.py",
    "target_filename": "tale/cmds/normal.py",
    "source_changeid": "0a78d4a821d7da405bf5335ba3741757f0b593fe^",
    "target_changeid": "0a78d4a821d7da405bf5335ba3741757f0b593fe",
    "predictions": [
      "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "1": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str]=None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "2": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str]= { } ) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "3": "\n <IND> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: Optional[str] = None) -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n",
      "4": "\n <DED> <DED> <DED> def take_stuff(player: Player, items: Iterable[base.Item], container: base.MudObject, where_str: str=\"\") -> int: \n <IND> \"\"\"Takes stuff and returns the number of items taken\"\"\" \n"
    }
  },
  {
    "source_code": "    event: Dict,\n    schema: Dict = None,\n    formats: Optional[Dict] = None,\n",
    "target_code": "    event: Dict,\n    schema: Dict,\n    formats: Optional[Dict] = None,\n",
    "warning_line": "    schema: Dict = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " schema is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 136,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "awslabs/aws-lambda-powertools-python",
    "source_filename": "aws_lambda_powertools/utilities/validation/validator.py",
    "target_filename": "aws_lambda_powertools/utilities/validation/validator.py",
    "source_changeid": "29497d47d63b2e795c2a9d81eaca3985dfe8f071^",
    "target_changeid": "29497d47d63b2e795c2a9d81eaca3985dfe8f071",
    "predictions": [
      "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n",
      "1": "event: Dict, <DED> schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n",
      "2": "event: Dict, <IND> schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, \n",
      "3": "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, <IND>",
      "4": "event: Dict, \n schema: Optional[Dict] = None, \n formats: Optional[Dict] = None, <DED>"
    }
  },
  {
    "source_code": "        <IND>locksroot = EMPTY_MERKLE_ROOT\n        nonce = 0\n        transferred_amount: TokenAmount = 0\n        locked_amount: TokenAmount = 0\n\n",
    "target_code": "        <IND>locksroot = EMPTY_MERKLE_ROOT\n        nonce = Nonce(0)\n        transferred_amount = TokenAmount(0)\n        locked_amount = TokenAmount(0)\n\n",
    "warning_line": "        locked_amount: TokenAmount = 0",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " locked_amount is declared to have type `TokenAmount` but is used as type `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 923,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/channel.py",
    "target_filename": "raiden/transfer/channel.py",
    "source_changeid": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242^",
    "target_changeid": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242",
    "predictions": [
      "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = 0 \n locked_amount = 0 \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = 0 \n locked_amount = 0 \n \n",
      "1": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = TokenAmount() \n locked_amount = TokenAmount() \n \n",
      "2": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = TokenAmount0 \n locked_amount = TokenAmount0 \n \n",
      "3": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = 0 \n transferred_amount = TokenAmount(0) \n locked_amount = TokenAmount(0) \n \n",
      "4": "<IND> locksroot = EMPTY_MERKLE_ROOT \n nonce = None \n transferred_amount = None \n locked_amount = None \n \n"
    }
  },
  {
    "source_code": "  def __init__(self,\n               stats: channel.Channel,\n               name: Text = None,\n               outputs: Dict[Text, channel.Channel] = None):\n    <IND>",
    "target_code": "  def __init__(self,\n               stats,\n               name = None,\n               outputs = None):\n    <IND>",
    "warning_line": "               name: Text = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " name is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 41,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/tfx",
    "source_filename": "tfx/components/schema_gen/component.py",
    "target_filename": "tfx/components/schema_gen/component.py",
    "source_changeid": "3d7bb6a0ae0aa0ed6269c2e1f4d2bb3e8bee2a93^",
    "target_changeid": "3d7bb6a0ae0aa0ed6269c2e1f4d2bb3e8bee2a93",
    "predictions": [
      "def __init__(self, \n stats: channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "def __init__(self, \n stats: channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>",
      "1": "def __init__(self, \n stats: Channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>",
      "2": "def __init__(self, \n stats: Optional[channel.Channel], \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None): \n <IND>",
      "3": "def __init__(self, \n stats: channel.Channel, \n name: Optional[Text] = None, \n outputs: Optional[Dict[Text, channel.Channel]] = None) -> None: \n <IND>",
      "4": "def __init__(self, \n stats: channel.Channel, \n name: str, \n outputs: Dict[Text, channel.Channel] = None): \n <IND>"
    }
  },
  {
    "source_code": "        <DED>env_copy = {}\n        key = None  # type: Union[Text, bytes]\n        for key in env:\n            <IND>key = key.encode(\"utf-8\")\n            env_copy[key] = env[key]\n",
    "target_code": "        <DED>env_copy = {}\n        key = None  # type: Any\n        for key in env:\n            <IND>env_copy[key] = env[key]\n",
    "warning_line": "        key = None  # type: Union[Text, bytes]",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " key is declared to have type `Union[bytes, str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 467,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "common-workflow-language/cwltool",
    "source_filename": "cwltool/job.py",
    "target_filename": "cwltool/job.py",
    "source_changeid": "6abb39915cf4fd279e8ef0fba8a9e7906cdf1878^",
    "target_changeid": "6abb39915cf4fd279e8ef0fba8a9e7906cdf1878",
    "predictions": [
      "<DED> env_copy = { } \n key: Union[Text, bytes] \n for key in env: \n <IND> key = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> env_copy = { } \n key: Union[Text, bytes] \n for key in env: \n <IND> key = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "1": "<DED> env_copy = { } \n key_encoded = None # type: Union[Text, bytes] \n for key in env: \n <IND> key_encoded = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "2": "<DED> env_copy = { } \n key: Union[bytes, bytes] \n for key in env: \n <IND> key = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "3": "<DED> env_copy = { } \n key_bytes = Union[bytes, bytes] \n for key in env: \n <IND> key_bytes = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n",
      "4": "<DED> env_copy = { } \n key: Union[Text, bytes] \n for key in env: \n <IND> key_encoded = key.encode(\"utf-8\") \n env_copy[key] = env[key] \n"
    }
  },
  {
    "source_code": "\n    def end(self, end_time: int = None) -> None:\n        <IND>",
    "target_code": "\n    def end(self, end_time: typing.Optional[int] = None) -> None:\n        <IND>",
    "warning_line": "    def end(self, end_time: int = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " end_time is declared to have type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 148,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "open-telemetry/opentelemetry-python",
    "source_filename": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
    "target_filename": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
    "source_changeid": "cfecca122c202f1dcc9361f6ab2b286c0ec17226^",
    "target_changeid": "cfecca122c202f1dcc9361f6ab2b286c0ec17226",
    "predictions": [
      "\n def end(self, end_time: Optional[int] = None) -> None: \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def end(self, end_time: Optional[int] = None) -> None: \n <IND>",
      "1": "\n def end(self, end_time: typing.Optional[int] = None) -> None: \n <IND>",
      "2": "\n def end(self, end_time: Optional[int] = None) -> None: \n <DED>",
      "3": "\n def end(self, end_time: typing.Optional[int] = None) -> None: \n <DED>",
      "4": "\n def end(self, end_time: Optional[int] = None) -> None: \n \n"
    }
  },
  {
    "source_code": "\ndef _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = None, end_position: int = None, section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry.RouterStatusEntry']:\n  <IND>",
    "target_code": "\ndef _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: Optional[int] = None, end_position: Optional[int] = None, section_end_keywords: Tuple[str, ...] = (), extra_args: Sequence[Any] = ()) -> Iterator['stem.descriptor.router_status_entry.RouterStatusEntry']:\n  <IND>",
    "warning_line": "def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = None, end_position: int = None, section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry.RouterStatusEntry']:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " start_position is declared to have type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 49,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "torproject/stem",
    "source_filename": "stem/descriptor/router_status_entry.py",
    "target_filename": "stem/descriptor/router_status_entry.py",
    "source_changeid": "076f89dfb4fd4a156ae32fde8c78c531385162e8^",
    "target_changeid": "076f89dfb4fd4a156ae32fde8c78c531385162e8",
    "predictions": [
      "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: Optional[int] = None, end_position: Optional[int] = None, section_end_keywords: Optional[Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = '', end_position: int = '', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "1": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = '0', end_position: int = '0', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "2": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = 0 \n end_position: int = 0 \n section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "3": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int = -1, end_position: int = -1, section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status_entry",
      "4": "\n def _parse_file(document_file: BinaryIO, validate: bool, entry_class: Type['stem.descriptor.router_status_entry.RouterStatusEntry'], entry_keyword: str = 'r', start_position: int, end_position: int = '', section_end_keywords: Sequence[str] = (), extra_args: Sequence[str] = ()) -> Iterator['stem.descriptor.router_status"
    }
  },
  {
    "source_code": "<DED><DED>def set_package_logger(\n    level: Union[str, int] = logging.DEBUG, stream: IO[str] = None, formatter: logging.Formatter = None\n):\n",
    "target_code": "<DED><DED>def set_package_logger(\n    level: Union[str, int] = logging.DEBUG,\n    stream: Optional[IO[str]] = None,\n    formatter: Optional[logging.Formatter] = None,\n):\n",
    "warning_line": "    level: Union[str, int] = logging.DEBUG, stream: IO[str] = None, formatter: logging.Formatter = None",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " stream is declared to have type `IO[str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 424,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "awslabs/aws-lambda-powertools-python",
    "source_filename": "aws_lambda_powertools/logging/logger.py",
    "target_filename": "aws_lambda_powertools/logging/logger.py",
    "source_changeid": "5b87bb195fb154d2a112364a5d1d5c9513898e55^",
    "target_changeid": "5b87bb195fb154d2a112364a5d1d5c9513898e55",
    "predictions": [
      "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "1": "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: IO[str] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "2": "\n <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "3": "<IND> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None \n ): \n",
      "4": "<DED> <DED> def set_package_logger( \n level: Union[str, int] = logging.DEBUG, stream: IO[str] = 0 \n ): \n"
    }
  },
  {
    "source_code": "\n    <DED>def extra_usage(self, bot, update, groupdict: Dict[str, str] = None):\n        <IND>if int(groupdict['id']) >= len(self.modules_list):\n",
    "target_code": "\n    <DED>def extra_usage(self, bot, update, groupdict: Dict[str, str]):\n        <IND>if int(groupdict['id']) >= len(self.modules_list):\n",
    "warning_line": "    def extra_usage(self, bot, update, groupdict: Dict[str, str] = None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " groupdict is declared to have type `Dict[str, str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 162,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ehForwarderBot/efb-telegram-master",
    "source_filename": "efb_telegram_master/commands.py",
    "target_filename": "efb_telegram_master/commands.py",
    "source_changeid": "437a9d58539e033a25a46e7c415a69ce29d99348^",
    "target_changeid": "437a9d58539e033a25a46e7c415a69ce29d99348",
    "predictions": [
      "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "1": "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None): \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "2": "\n <IND> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> None: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "3": "\n <DED> def extra_usage(self, bot, update, groupdict: Dict[str, str]): \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n",
      "4": "\n <DED> def extra_usage(self, bot, update, groupdict: Optional[Dict[str, str]] = None) -> bool: \n <IND> if int(groupdict['id']) >= len(self.modules_list): \n"
    }
  },
  {
    "source_code": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], bool] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:\n            # This method is called (indirectly) by __del__, so it cannot\n",
    "target_code": "                _WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED,\n                _WTERMSIG: Callable[[int], int] = os.WTERMSIG,\n                _WIFEXITED: Callable[[int], bool] = os.WIFEXITED,\n                _WEXITSTATUS: Callable[[int], int] = os.WEXITSTATUS) -> None:\n            # This method is called (indirectly) by __del__, so it cannot\n",
    "warning_line": "                _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " _WEXITSTATUS is declared to have type `typing.Callable[[int], bool]` but is used as type `typing.Callable(os.WEXITSTATUS)[[Named(status, int)], int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1408,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "python/mypy",
    "source_filename": "test-data/stdlib-samples/3.2/subprocess.py",
    "target_filename": "test-data/stdlib-samples/3.2/subprocess.py",
    "source_changeid": "c6c201c391fba5a2322561e1126ce4c7395b0bd7^",
    "target_changeid": "c6c201c391fba5a2322561e1126ce4c7395b0bd7",
    "predictions": [
      "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n",
      "1": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED, \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n",
      "2": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n # This method is called (indirectly)",
      "3": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED, \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n # This method is called (indirectly)",
      "4": "_WIFSIGNALED: Callable[[int], bool] = os.WIFSIGNALED, \n _WTERMSIG: Callable[[int], bool] = os.WTERMSIG, \n _WIFEXITED: Callable[[int], bool] = os.WIFEXITED, \n _WEXITSTATUS: Callable[[int], bool] = os.WEXITSTATUS) -> None: \n # This method is called"
    }
  },
  {
    "source_code": "        project_id: str,\n        region: str = None,\n        location: Optional[str] = None,\n",
    "target_code": "        project_id: str,\n        region: Optional[str] = None,\n        location: Optional[str] = None,\n",
    "warning_line": "        region: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " region is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1659,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "apache/airflow",
    "source_filename": "airflow/providers/google/cloud/operators/dataproc.py",
    "target_filename": "airflow/providers/google/cloud/operators/dataproc.py",
    "source_changeid": "174681911f96f17d41a4f560ca08d5e200944f7f^",
    "target_changeid": "174681911f96f17d41a4f560ca08d5e200944f7f",
    "predictions": [
      "project_id: str, \n region: Optional[str] = None, \n location: Optional[str] = None, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "project_id: str, \n region: Optional[str] = None, \n location: Optional[str] = None, \n",
      "1": "project_id: str, \n region: str, \n location: Optional[str] = None, \n",
      "2": "project_id: str, \n region: Optional[str] = None, \n location: Optional[str] = None, <IND>",
      "3": "project_id: str, \n region: Optional[str] = None, \n location: Optional[str] = None, <DED>",
      "4": "project_id: str, <IND> region: Optional[str] = None, \n location: Optional[str] = None, \n"
    }
  },
  {
    "source_code": "    thresh: str = \"25.0 degC\",\n    window: str = 5,\n    freq: str = \"YS\",\n",
    "target_code": "    thresh: str = \"25.0 degC\",\n    window: int = 5,\n    freq: str = \"YS\",\n",
    "warning_line": "    window: str = 5,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " window is declared to have type `str` but is used as type `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 403,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ouranosinc/xclim",
    "source_filename": "xclim/indices/_threshold.py",
    "target_filename": "xclim/indices/_threshold.py",
    "source_changeid": "ec14d1cfdd74ac63fb57908a7a5029b4b5e8079d^",
    "target_changeid": "ec14d1cfdd74ac63fb57908a7a5029b4b5e8079d",
    "predictions": [
      "thresh: str = \"25.0 degC\", \n window: int = 5, \n freq: str = \"YS\", \n"
    ],
    "correct": true,
    "top_five": {
      "0": "thresh: str = \"25.0 degC\", \n window: int = 5, \n freq: str = \"YS\", \n",
      "1": "thresh: str = \"25.0 degC\", \n window: str = 5, \n freq: str = \"YS\", \n",
      "2": "thresh: str = \"25.0 degC\", \n window: typing.Optional[str] = 5, \n freq: str = \"YS\", \n",
      "3": "thresh: str = \"25.0 degC\", \n window: int = 5 \n freq: str = \"YS\", \n",
      "4": "thresh: str = \"25.0 degC\", \n window: int = 5, \n freq: str = \"YS\", \n"
    }
  },
  {
    "source_code": "    save_path: Union[str, pathlib.Path, io.BufferedIOBase],\n    data: Dict[str, Any] = None,\n    params: Dict[str, Any] = None,\n    pytorch_variables: Dict[str, Any] = None,\n    verbose: int = 0,\n",
    "target_code": "    save_path: Union[str, pathlib.Path, io.BufferedIOBase],\n    data: Optional[Dict[str, Any]] = None,\n    params: Optional[Dict[str, Any]] = None,\n    pytorch_variables: Optional[Dict[str, Any]] = None,\n    verbose: int = 0,\n",
    "warning_line": "    params: Dict[str, Any] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " params is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 290,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "DLR-RM/stable-baselines3",
    "source_filename": "stable_baselines3/common/save_util.py",
    "target_filename": "stable_baselines3/common/save_util.py",
    "source_changeid": "be86883f36eaa706e6f4a5a57d0583209471969d^",
    "target_changeid": "be86883f36eaa706e6f4a5a57d0583209471969d",
    "predictions": [
      "save_path: Union[str, pathlib.Path, io.BufferedIOBase], \n data: Optional[Dict[str, Any]] = None, \n params: Optional[Dict[str, Any]] = None, \n pytorch_variables: Optional[Dict[str, Any]] = None, \n verbose: int = 0, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "save_path: Union[str, pathlib.Path, io.BufferedIOBase], \n data: Optional[Dict[str, Any]] = None, \n params: Optional[Dict[str, Any]] = None, \n pytorch_variables: Optional[Dict[str, Any]] = None, \n verbose: int = 0, \n",
      "1": "save_path: Union[str, pathlib.Path, io.BufferedIOBase], \n data: Optional[Dict[str, Any]] = None, <IND> params: Optional[Dict[str, Any]] = None, \n pytorch_variables: Optional[Dict[str, Any]] = None, \n verbose: int = 0, \n",
      "2": "save_path: Union[str, pathlib.Path, io.BufferedIOBase], \n data: Optional[Dict[str, Any]] = None, \n params: Optional[Dict[str, Any]] = None, \n pytorch_variables: Optional[Dict[str, Any]] = None, \n verbose: int = 0, <IND>",
      "3": "save_path: Union[str, pathlib.Path, io.BufferedIOBase], \n data: Optional[Dict[str, Any]] = None, \n params: Optional[Dict[str, Any]] = None, \n pytorch_variables: Optional[Dict[str, Any]] = None, <IND> verbose: int = 0, \n",
      "4": "save_path: Union[str, pathlib.Path, io.BufferedIOBase], \n data: Optional[Dict[str, Any]] = None, \n pytorch_variables: Optional[Dict[str, Any]] = None, \n verbose: int = 0, \n"
    }
  },
  {
    "source_code": "            runtimeContext,         # type: RuntimeContext\n            tmpdir_lock=None        # type: threading.Lock\n            ):  # type: (...) -> None\n",
    "target_code": "            runtimeContext,         # type: RuntimeContext\n            tmpdir_lock=None        # type: Optional[threading.Lock]\n            ):  # type: (...) -> None\n",
    "warning_line": "            tmpdir_lock=None        # type: threading.Lock",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tmpdir_lock is declared to have type `threading.Lock` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 430,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "common-workflow-language/cwltool",
    "source_filename": "cwltool/job.py",
    "target_filename": "cwltool/job.py",
    "source_changeid": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c^",
    "target_changeid": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c",
    "predictions": [
      "runtimeContext, # type: RuntimeContext \n tmpdir_lock=None # type: Optional[threading.Lock] \n ): # type: (...) -> None \n"
    ],
    "correct": true,
    "top_five": {
      "0": "runtimeContext, # type: RuntimeContext \n tmpdir_lock=None # type: Optional[threading.Lock] \n ): # type: (...) -> None \n",
      "1": "runtimeContext, # type: RuntimeContext \n # type: Optional[threading.Lock] \n tmpdir_lock=None # type: Optional[threading.Lock] \n ): # type: (...) -> None \n",
      "2": "runtimeContext, # type: RuntimeContext \n tmpdir_lock=None # type: None \n ): # type: (...) -> None \n",
      "3": "runtimeContext, # type: RuntimeContext \n tmpdir_lock=None # type: Optional[Threading.Lock] \n ): # type: (...) -> None \n",
      "4": "runtimeContext, # type: RuntimeContext \n tmpdir_lock=None # type: Optional[threading.Lock] \n ): # type: (...) -> None <IND>"
    }
  },
  {
    "source_code": "        should_archive: bool = True,\n        extra_data: Dict = None,\n        dispatch_to: List[str] = None,\n    ) -> None:\n",
    "target_code": "        should_archive: bool = True,\n        extra_data: Optional[Dict] = None,\n        dispatch_to: Optional[List[str]] = None,\n    ) -> None:\n",
    "warning_line": "        extra_data: Dict = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " extra_data is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 29,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PUNCH-Cyber/stoq",
    "source_filename": "stoq/data_classes.py",
    "target_filename": "stoq/data_classes.py",
    "source_changeid": "da996c201bee36f66ad1a879c6b7b9d3949ccb9c^",
    "target_changeid": "da996c201bee36f66ad1a879c6b7b9d3949ccb9c",
    "predictions": [
      "should_archive: bool = True, \n extra_data: Optional[Dict] = None, \n dispatch_to: Optional[List[str]] = None, \n ) -> None: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "should_archive: bool = True, \n extra_data: Optional[Dict] = None, \n dispatch_to: Optional[List[str]] = None, \n ) -> None: \n",
      "1": "should_archive: bool = True, \n extra_data: Dict, \n dispatch_to: List[str] = None, \n ) -> None: \n",
      "2": "should_archive: bool = True, \n extra_data: Optional[Dict] = None, \n dispatch_to: Optional[List[str]] = None, \n ) -> None: <IND>",
      "3": "should_archive: bool = True, <DED> extra_data: Optional[Dict] = None, \n dispatch_to: Optional[List[str]] = None, \n ) -> None: \n",
      "4": "should_archive: bool = True, <IND> extra_data: Optional[Dict] = None, \n dispatch_to: Optional[List[str]] = None, \n ) -> None: \n"
    }
  },
  {
    "source_code": "        value: typing.Any,\n        attr: str = None,\n        data: typing.Mapping[str, typing.Any] = None,\n        **kwargs\n",
    "target_code": "        value: typing.Any,\n        attr: typing.Optional[str] = None,\n        data: typing.Optional[typing.Mapping[str, typing.Any]] = None,\n        **kwargs\n",
    "warning_line": "        data: typing.Mapping[str, typing.Any] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " data is declared to have type `typing.Mapping[str, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 322,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "marshmallow-code/marshmallow",
    "source_filename": "src/marshmallow/fields.py",
    "target_filename": "src/marshmallow/fields.py",
    "source_changeid": "43db1072f94ae6af40cbedc058f1c02f3cedb379^",
    "target_changeid": "43db1072f94ae6af40cbedc058f1c02f3cedb379",
    "predictions": [
      "value: typing.Any, \n attr: typing.Optional[str] = None, \n data: typing.Optional[typing.Mapping[str, typing.Any]] = None, \n **kwargs \n"
    ],
    "correct": true,
    "top_five": {
      "0": "value: typing.Any, \n attr: typing.Optional[str] = None, \n data: typing.Optional[typing.Mapping[str, typing.Any]] = None, \n **kwargs \n",
      "1": "value: typing.Any, \n attr: Optional[str] = None, \n data: Optional[typing.Mapping[str, typing.Any]] = None, \n **kwargs \n",
      "2": "value: typing.Any, \n attr: Optional[typing.Mapping[str, typing.Any]] = None, \n data: Optional[typing.Mapping[str, typing.Any]] = None, \n **kwargs \n",
      "3": "value: typing.Any, \n attr: str, \n data: typing.Optional[typing.Mapping[str, typing.Any]] = None, \n **kwargs \n",
      "4": "value: typing.Any, \n attr: Optional[str] = None, \n data: Optional[typing.Mapping[str, any]] = None, \n **kwargs \n"
    }
  },
  {
    "source_code": "                                     stats: Dict[int, Dict[str, float]],\n                                     ranges: Dict[str, List[float]] = None,\n                                     immutable_features: List[str] = None,\n                                     diverse=False) -> List[np.ndarray]:\n",
    "target_code": "                                     stats: Dict[int, Dict[str, float]],\n                                     ranges: Optional[Dict[str, List[float]]] = None,\n                                     immutable_features: Optional[List[str]] = None,\n                                     diverse=False) -> List[np.ndarray]:\n",
    "warning_line": "                                     immutable_features: List[str] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " immutable_features is declared to have type `List[str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 561,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "SeldonIO/alibi",
    "source_filename": "alibi/explainers/backends/cfrl_tabular.py",
    "target_filename": "alibi/explainers/backends/cfrl_tabular.py",
    "source_changeid": "dcf6282c677d0cab48f62e23f707f4ad05497d60^",
    "target_changeid": "dcf6282c677d0cab48f62e23f707f4ad05497d60",
    "predictions": [
      "stats: Dict[int, Dict[str, float]], \n ranges: Optional[Dict[str, List[float]]] = None, \n immutable_features: Optional[List[str]] = None, \n diverse=False) -> List[np.ndarray]: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "stats: Dict[int, Dict[str, float]], \n ranges: Optional[Dict[str, List[float]]] = None, \n immutable_features: Optional[List[str]] = None, \n diverse=False) -> List[np.ndarray]: \n",
      "1": "stats: Dict[int, Dict[str, float]], \n ranges: Optional[Dict[str], List[float]] = None, \n immutable_features: Optional[List[str]] = None, \n diverse=False) -> List[np.ndarray]: \n",
      "2": "stats: Dict[int, Dict[str, float]], \n ranges: Optional[Dict[str, List[float]]] = None, \n immutable_features: Optional[List[str]] = None, \n diverse=False) -> List[np.ndarray]: <IND>",
      "3": "stats: Dict[int, Dict[str, float]], \n ranges: Optional[Dict[str, List[float]]] = None, \n immutable_features: Optional[List[str]] = None, \n diverse=False) -> List[np.ndarray]: <DED>",
      "4": "stats: Dict[int, Dict[str, float]], \n ranges: Optional[Dict[str, List[float]]] = None, \n immutable_features: Optional[List[str]] = None, <IND> diverse=False) -> List[np.ndarray]: \n"
    }
  },
  {
    "source_code": "    <DED>def convert_weight(self, c: Counter) -> Dict[str, float]:\n        <IND>c = c.most_common()\n        _max_count = c[0][1]\n        weight = {k: v / _max_count for k, v in c}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
    "target_code": "    <DED>def convert_weight(self, c: Counter) -> Dict[str, float]:\n        <IND>most_common = c.most_common()\n        _max_count = most_common[0][1]\n        weight = {k: v / _max_count for k, v in most_common}\n        weight = {k: weight[k] for k in list(weight.keys())}\n",
    "warning_line": "        c = c.most_common()",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " c is declared to have type `Counter[typing.Any]` but is used as type `List[Tuple[typing.Any, int]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 29,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "vaaaaanquish/cloudia",
    "source_filename": "cloudia/word_data.py",
    "target_filename": "cloudia/word_data.py",
    "source_changeid": "795b15cc64c7687cb2c221ee0e40e2121e4baf8a^",
    "target_changeid": "795b15cc64c7687cb2c221ee0e40e2121e4baf8a",
    "predictions": [
      "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "1": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c = c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "2": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> return c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "3": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common() \n _max_count = c.most_common() \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n",
      "4": "<DED> def convert_weight(self, c: Counter) -> Dict[str, float]: \n <IND> c.most_common = c.most_common() \n _max_count = c[0][1] \n weight = { k: v / _max_count for k, v in c } \n weight = { k: weight[k] for k in list(weight.keys()) } \n"
    }
  },
  {
    "source_code": "        sample_rate: int,\n        channel_index: int = Deprecated,\n        channels_first: bool = False,\n",
    "target_code": "        sample_rate: int,\n        channel_index=Deprecated,\n        channels_first: bool = False,\n",
    "warning_line": "        channel_index: int = Deprecated,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " channel_index is declared to have type `int` but is used as type `art.utils._Deprecated`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 52,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Trusted-AI/adversarial-robustness-toolbox",
    "source_filename": "art/defences/preprocessor/mp3_compression.py",
    "target_filename": "art/defences/preprocessor/mp3_compression.py",
    "source_changeid": "e9e70152a0070f2bb6b5e77c3c5f5f3fc6176c0c^",
    "target_changeid": "e9e70152a0070f2bb6b5e77c3c5f5f3fc6176c0c",
    "predictions": [
      "sample_rate: int, \n channel_index=Deprecated, \n channels_first: bool = False, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "sample_rate: int, \n channel_index=Deprecated, \n channels_first: bool = False, \n",
      "1": "sample_rate: int, \n channel_index=Deprecated, \n channels_first: bool = False, <IND>",
      "2": "sample_rate: int, <DED> channel_index=Deprecated, \n channels_first: bool = False, \n",
      "3": "sample_rate: int, <IND> channel_index=Deprecated, \n channels_first: bool = False, \n",
      "4": "sample_rate: int, \n channel_index=Deprecated, \n channels_first: bool = False, <DED>"
    }
  },
  {
    "source_code": "    def __init__(self, statechart: model.Statechart, *,\n                 evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator,\n                 initial_context: Mapping=None,\n",
    "target_code": "    def __init__(self, statechart: model.Statechart, *,\n                 evaluator_klass: Callable[['Interpreter'], Evaluator]=PythonEvaluator,\n                 initial_context: Mapping=None,\n",
    "warning_line": "                 evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " evaluator_klass is declared to have type `typing.Callable[[Interpreter, Mapping[typing.Any, typing.Any]], sismic.code.evaluator.Evaluator]` but is used as type `typing.Type[sismic.code.python.PythonEvaluator]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 29,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "AlexandreDecan/sismic",
    "source_filename": "sismic/interpreter.py",
    "target_filename": "sismic/interpreter.py",
    "source_changeid": "ffb6ef590d7d7e0679ff8a753d6836805fb76122^",
    "target_changeid": "ffb6ef590d7d7e0679ff8a753d6836805fb76122",
    "predictions": [
      "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator, \n initial_context: Mapping=None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator, \n initial_context: Mapping=None, \n",
      "1": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Callable[['Interpreter', Mapping], Evaluator]=Evaluator, \n initial_context: Mapping=None, \n",
      "2": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Optional[Callable[['Interpreter', Mapping], Evaluator]=PythonEvaluator, \n initial_context: Mapping=None, \n",
      "3": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: PythonEvaluator, \n initial_context: Mapping=None, \n",
      "4": "def __init__(self, statechart: model.Statechart, *, \n evaluator_klass: Optional[PythonEvaluator] = PythonEvaluator, \n initial_context: Mapping=None, \n"
    }
  },
  {
    "source_code": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    command = \" \".join(command)\n    api.keybindings.bind(keybinding, command, modeobj)\n\n",
    "target_code": "    modeobj = api.modes.get_by_name(mode) if mode else api.modes.current()\n    api.keybindings.bind(keybinding, \" \".join(command), modeobj)\n\n",
    "warning_line": "    command = \" \".join(command)",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " command is declared to have type `List[str]` but is used as type `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 67,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "karlch/vimiv-qt",
    "source_filename": "vimiv/config/configcommands.py",
    "target_filename": "vimiv/config/configcommands.py",
    "source_changeid": "4ce84989a3b7460ee03fb4d41a08b5d9a2d4ccc0^",
    "target_changeid": "4ce84989a3b7460ee03fb4d41a08b5d9a2d4ccc0",
    "predictions": [
      "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command = \" \".join(command) \n api.keybindings.bind(keybinding, command, modeobj) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command = \" \".join(command) \n api.keybindings.bind(keybinding, command, modeobj) \n \n",
      "1": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command_name = \" \".join(command) \n api.keybindings.bind(keybinding, command_name, modeobj) \n \n",
      "2": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command_ = \" \".join(command) \n api.keybindings.bind(keybinding, command_, modeobj) \n \n",
      "3": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command__ = \" \".join(command) \n api.keybindings.bind(keybinding, command__, modeobj) \n \n",
      "4": "modeobj = api.modes.get_by_name(mode) if mode else api.modes.current() \n command = \" \".join(command) \n keybindings.bind(keybinding, command, modeobj) \n \n"
    }
  },
  {
    "source_code": "    formats: Optional[Dict] = None,\n    envelope: str = None,\n    jmespath_options: Dict = None,\n):\n",
    "target_code": "    formats: Optional[Dict] = None,\n    envelope: Optional[str] = None,\n    jmespath_options: Optional[Dict] = None,\n):\n",
    "warning_line": "    envelope: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " envelope is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 138,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "awslabs/aws-lambda-powertools-python",
    "source_filename": "aws_lambda_powertools/utilities/validation/validator.py",
    "target_filename": "aws_lambda_powertools/utilities/validation/validator.py",
    "source_changeid": "5b87bb195fb154d2a112364a5d1d5c9513898e55^",
    "target_changeid": "5b87bb195fb154d2a112364a5d1d5c9513898e55",
    "predictions": [
      "formats: Optional[Dict] = None, \n envelope: Optional[str] = None, \n jmespath_options: Optional[Dict] = None, \n ): \n"
    ],
    "correct": true,
    "top_five": {
      "0": "formats: Optional[Dict] = None, \n envelope: Optional[str] = None, \n jmespath_options: Optional[Dict] = None, \n ): \n",
      "1": "formats: Optional[Dict] = None, \n envelope_options: Optional[str] = None, \n jmespath_options: Optional[Dict] = None, \n ): \n",
      "2": "formats: Optional[Dict] = None, \n envelopes: Optional[str] = None, \n jmespath_options: Optional[Dict] = None, \n ): \n",
      "3": "formats: Optional[Dict] = None, \n envelope: str = '', \n jmespath_options: Optional[Dict] = None, \n ): \n",
      "4": "formats: Optional[Dict] = None, \n envelope_type: Optional[str] = None, \n jmespath_options: Optional[Dict] = None, \n ): \n"
    }
  },
  {
    "source_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n\n",
    "target_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord_list = op_ord.split(',')\n    _parser.validate_op_order(op_ord_list)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord_list\n\n",
    "warning_line": "    op_ord = op_ord.split(',')",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " op_ord is declared to have type `str` but is used as type `typing.List[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1204,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "pygae/galgebra",
    "source_filename": "galgebra/printer.py",
    "target_filename": "galgebra/printer.py",
    "source_changeid": "ceacd273cdb095122678af6b1239f2b7b18cd9f4^",
    "target_changeid": "ceacd273cdb095122678af6b1239f2b7b18cd9f4",
    "predictions": [
      "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n"
    ],
    "correct": false,
    "top_five": {
      "0": "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "1": "global _eval_global_dict, _eval_parse_order \n op_ord.split(',') \n _parser.validate_op_order(op_ord.split(',')) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "2": "global _eval_global_dict, _eval_parse_order \n op_ord_split = op_ord.split(',') \n _parser.validate_op_order(op_ord_split) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n \n",
      "3": "global _eval_global_dict, _eval_parse_order \n op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "4": "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _parser.validate_op_order(op_ord) \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n \n"
    }
  },
  {
    "source_code": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False):\n        <IND>self.snippetSupport = snippet_support\n",
    "target_code": "                 preselected_support: Optional[bool] = False,\n                 tag_support: Optional[CompletionTagSupportClientCapabilities] = None):\n        <IND>self.snippetSupport = snippet_support\n",
    "warning_line": "                 tag_support: Optional[CompletionTagSupportClientCapabilities] = False):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tag_support is declared to have type `Optional[CompletionTagSupportClientCapabilities]` but is used as type `bool`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 65,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "openlawlibrary/pygls",
    "source_filename": "pygls/types/language_features/completion.py",
    "target_filename": "pygls/types/language_features/completion.py",
    "source_changeid": "866698899d9d082b1929d0e3a80564f01f8f905b^",
    "target_changeid": "866698899d9d082b1929d0e3a80564f01f8f905b",
    "predictions": [
      "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False): \n <IND> self.snippetSupport = snippet_support \n"
    ],
    "correct": false,
    "top_five": {
      "0": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False): \n <IND> self.snippetSupport = snippet_support \n",
      "1": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False) -> None: \n <IND> self.snippetSupport = snippet_support \n",
      "2": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False): \n <DED> self.snippetSupport = snippet_support \n",
      "3": "preselected_support: Optional[bool] = False, \n tag_support: Optional[CompletionTagSupportClientCapabilities] = False) \n <IND> self.snippetSupport = snippet_support \n",
      "4": "preselected_support: Optional[bool] = False, \n tag_support: bool = False): \n <IND> self.snippetSupport = snippet_support \n"
    }
  },
  {
    "source_code": "    <DED>@classmethod\n    def unsetFace(cls, object: SceneNode = None) -> None:\n        <IND>if not object or not cls.__selected_face or object is cls.__selected_face[0]:\n",
    "target_code": "    <DED>@classmethod\n    def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None:\n        <IND>if not object or not cls.__selected_face or object is cls.__selected_face[0]:\n",
    "warning_line": "    def unsetFace(cls, object: SceneNode = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " object is declared to have type `SceneNode` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 52,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Uranium",
    "source_filename": "UM/Scene/Selection.py",
    "target_filename": "UM/Scene/Selection.py",
    "source_changeid": "c194c9b6c2371c27cf81a9dfd419ebcff7520367^",
    "target_changeid": "c194c9b6c2371c27cf81a9dfd419ebcff7520367",
    "predictions": [
      "<DED> @classmethod \n def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None: \n <IND> if not object or not cls.__selected_face or object is cls.__selected_face[0]: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> @classmethod \n def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None: \n <IND> if not object or not cls.__selected_face or object is cls.__selected_face[0]: \n",
      "1": "<IND> @classmethod \n def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None: \n <IND> if not object or not cls.__selected_face or object is cls.__selected_face[0]: \n",
      "2": "\n @classmethod \n def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None: \n <IND> if not object or not cls.__selected_face or object is cls.__selected_face[0]: \n",
      "3": "<DED> @classmethod \n def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None: \n <DED> if not object or not cls.__selected_face or object is cls.__selected_face[0]: \n",
      "4": "<DED> @classmethod \n def unsetFace(cls, object: Optional[\"SceneNode\"] = None) -> None: \n \n if not object or not cls.__selected_face or object is cls.__selected_face[0]: \n"
    }
  },
  {
    "source_code": "        if not mimetype:\n            <IND>mimetype, _ = mimetypes_storage.guess_type(file_path, strict=False)\n        <DED>reader = self._get_vtk_reader(mimetype)\n",
    "target_code": "        if not mimetype:\n            <IND>guessed_mimetype, _ = mimetypes_storage.guess_type(file_path, strict=False)\n            # INFO - G.M - 2019-11-22 - guessed_mimetype can be None\n            mimetype = guessed_mimetype or \"\"\n        <DED>reader = self._get_vtk_reader(mimetype)\n",
    "warning_line": "            mimetype, _ = mimetypes_storage.guess_type(file_path, strict=False)",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " mimetype is declared to have type `str` but is used as type `typing.Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 100,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "algoo/preview-generator",
    "source_filename": "preview_generator/preview/builder/cad__vtk.py",
    "target_filename": "preview_generator/preview/builder/cad__vtk.py",
    "source_changeid": "09895c027a8c7c20318d2820caf0c40083f32ce8^",
    "target_changeid": "09895c027a8c7c20318d2820caf0c40083f32ce8",
    "predictions": [
      "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=False) \n <DED> reader = self._get_vtk_reader(mimetype) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=False) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "1": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str(str)) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "2": "if not mimetype: \n <IND> mimetype = mimetypes_storage.guess_type(file_path, str(str)) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "3": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=false) \n <DED> reader = self._get_vtk_reader(mimetype) \n",
      "4": "if not mimetype: \n <IND> mimetype, _ = mimetypes_storage.guess_type(file_path, str=False) \n <IND> reader = self._get_vtk_reader(mimetype) \n"
    }
  },
  {
    "source_code": "\n<DED>def message(target: str, message: str, tags: dict=None\n        ) -> 'utils.irc.IRCParsedLine':\n    <IND>return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\n<DED>def notice(target: str, message: str, tags: dict=None\n        ) -> 'utils.irc.IRCParsedLine':\n",
    "target_code": "\n<DED>def message(target: str, message: str, tags: typing.Dict[str, str]={}\n        ) -> 'utils.irc.IRCParsedLine':\n    <IND>return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags)\n<DED>def notice(target: str, message: str, tags: typing.Dict[str, str]={}\n        ) -> 'utils.irc.IRCParsedLine':\n",
    "warning_line": "def message(target: str, message: str, tags: dict=None",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 36,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jesopo/bitbot",
    "source_filename": "src/utils/irc/protocol.py",
    "target_filename": "src/utils/irc/protocol.py",
    "source_changeid": "577fae7ceabfd2a43b798e02a67c518c23ed33bd^",
    "target_changeid": "577fae7ceabfd2a43b798e02a67c518c23ed33bd",
    "predictions": [
      "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine",
      "1": "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.",
      "2": "\n <DED> def message(target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Optional[typing.Dict[str]= { \n ) -> 'utils.irc.",
      "3": "\n <DED> def message(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <IND> def notice(target: str, message: str, tags: typing.Dict[str, str]= { } \n ) -> 'utils.irc.IRCParsedLine",
      "4": "\n <DED> def message(target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } \n ) -> 'utils.irc.IRCParsedLine': \n <IND> return utils.irc.IRCParsedLine(\"PRIVMSG\", [target, message], tags=tags) \n <DED> def notice(target: str, message: str, tags: typing.Optional[typing.Dict[str]= { \n ) -> 'utils.ir"
    }
  },
  {
    "source_code": "    def statement_timeout_ms(self, value: Union[int, None]):\n        <IND>if value is not None:\n            <IND>value = str(value)\n        <DED>self._properties[\"statementTimeoutMs\"] = value\n\n",
    "target_code": "    def statement_timeout_ms(self, value: Union[int, None]):\n        <IND>new_value = None if value is None else str(value)\n        self._properties[\"statementTimeoutMs\"] = new_value\n\n",
    "warning_line": "            value = str(value)",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " value is declared to have type `Optional[int]` but is used as type `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 197,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "googleapis/python-bigquery",
    "source_filename": "google/cloud/bigquery/job/query.py",
    "target_filename": "google/cloud/bigquery/job/query.py",
    "source_changeid": "66b3dd9f9aec3fda9610a3ceec8d8a477f2ab3b9^",
    "target_changeid": "66b3dd9f9aec3fda9610a3ceec8d8a477f2ab3b9",
    "predictions": [
      "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = str(value) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = str(value) \n \n",
      "1": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = value \n \n",
      "2": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n self._properties[\"statementTimeoutMs\"] = str \n \n",
      "3": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n <DED> self._properties[\"statementTimeoutMs\"] = str(value) \n \n",
      "4": "def statement_timeout_ms(self, value: Union[int, None]): \n <IND> if value is None else str(value) \n <DED> self._properties[\"statementTimeoutMs\"] = value \n \n"
    }
  },
  {
    "source_code": "    y: int,\n    channel_id: str = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
    "target_code": "    y: int,\n    channel_id: Optional[str] = None,\n    xs: int = 100,  # TODO: are these defaults reasonable or should no defaults be specified?\n",
    "warning_line": "    channel_id: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " channel_id is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 80,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "theislab/squidpy",
    "source_filename": "squidpy/im/crop.py",
    "target_filename": "squidpy/im/crop.py",
    "source_changeid": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed^",
    "target_changeid": "0a9fd7e4a3747db318e65a0a9fd3a31e87c06eed",
    "predictions": [
      "y: int, \n channel_id: Optional[str] = None, \n xs: Optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n"
    ],
    "correct": false,
    "top_five": {
      "0": "y: int, \n channel_id: Optional[str] = None, \n xs: Optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "1": "y: int, \n channel_id: Optional[str] = None, \n xs: int = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "2": "y: int, \n channel_id: Optional[str] = None, \n xs: optional[int] = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "3": "y: int, \n channel_id: Optional[str] = None, \n xs: int = 100, \n # TODO: are these defaults reasonable or should no defaults be specified? \n",
      "4": "y: int, \n channel_id: str, \n xs: int = 100, # TODO: are these defaults reasonable or should no defaults be specified? \n"
    }
  },
  {
    "source_code": "        status: str = \"\",\n        expiry_timestamp: int = None,\n        response_data: Optional[str] = \"\",\n        payload_hash: str = None,\n    ) -> None:\n",
    "target_code": "        status: str = \"\",\n        expiry_timestamp: Optional[int] = None,\n        response_data: Optional[str] = \"\",\n        payload_hash: Optional[str] = None,\n    ) -> None:\n",
    "warning_line": "        expiry_timestamp: int = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " expiry_timestamp is declared to have type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 42,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "awslabs/aws-lambda-powertools-python",
    "source_filename": "aws_lambda_powertools/utilities/idempotency/persistence/base.py",
    "target_filename": "aws_lambda_powertools/utilities/idempotency/persistence/base.py",
    "source_changeid": "5b87bb195fb154d2a112364a5d1d5c9513898e55^",
    "target_changeid": "5b87bb195fb154d2a112364a5d1d5c9513898e55",
    "predictions": [
      "status: str = \"\", \n expiry_timestamp: Optional[int] = None, \n response_data: Optional[str] = \"\", \n payload_hash: Optional[str] = None, \n ) -> None: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "status: str = \"\", \n expiry_timestamp: Optional[int] = None, \n response_data: Optional[str] = \"\", \n payload_hash: Optional[str] = None, \n ) -> None: \n",
      "1": "status: str = \"\", \n expiry_timestamp: Optional[str] = None, \n response_data: Optional[str] = \"\", \n payload_hash: Optional[str] = None, \n ) -> None: \n",
      "2": "status: str = \"\", \n expiry_timestamp: int = 0 \n response_data: Optional[str] = \"\", \n payload_hash: int = 0 \n ) -> None: \n",
      "3": "status: str = \"\", \n expiry_timestamp: int = -1, \n response_data: Optional[str] = \"\", \n payload_hash: int = -1, \n ) -> None: \n",
      "4": "status: str = \"\", \n expiry_timestamp: int = 0, \n response_data: Optional[str] = \"\", \n payload_hash: int = 0, \n ) -> None: \n"
    }
  },
  {
    "source_code": "        flavors=None,\n        signature: ModelSignature = None,\n        saved_input_example_info: Dict[str, Any] = None,\n",
    "target_code": "        flavors=None,\n        signature=None,  # ModelSignature\n        saved_input_example_info: Dict[str, Any] = None,\n",
    "warning_line": "        signature: ModelSignature = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " signature is declared to have type `ModelSignature` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 34,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "mlflow/mlflow",
    "source_filename": "mlflow/models/model.py",
    "target_filename": "mlflow/models/model.py",
    "source_changeid": "d1a2647a4d265f290261ab91db44125422ee57ab^",
    "target_changeid": "d1a2647a4d265f290261ab91db44125422ee57ab",
    "predictions": [
      "flavors=None, \n signature: Optional[ModelSignature] = None, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "flavors=None, \n signature: Optional[ModelSignature] = None, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n",
      "1": "flavors=None, \n signature: ModelSignature, \n saved_input_example_info: Dict[str, Any] = None, \n",
      "2": "flavors=None, \n signature: Optional[ModelSignature] = None, \n saved_input_example_info: Dict[str, Any] = None, \n",
      "3": "flavors=None, \n signatures: Optional[ModelSignature] = None, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n",
      "4": "flavors=None, \n signature: ModelSignature, \n saved_input_example_info: Optional[Dict[str, Any]] = None, \n"
    }
  },
  {
    "source_code": "<DED>async def async_test_function(\n    arg1: str, arg2: str, kwarg1: str = None, kwarg2: str = None\n):\n",
    "target_code": "<DED>async def async_test_function(\n    arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"\n):\n",
    "warning_line": "    arg1: str, arg2: str, kwarg1: str = None, kwarg2: str = None",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " kwarg1 is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 28,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "facebook/TestSlide",
    "source_filename": "tests/sample_module.py",
    "target_filename": "tests/sample_module.py",
    "source_changeid": "97c39d89c2a047a3396be659645bd89dab01d859^",
    "target_changeid": "97c39d89c2a047a3396be659645bd89dab01d859",
    "predictions": [
      "<DED> async def async_test_function( \n arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> async def async_test_function( \n arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n",
      "1": "<IND> async def async_test_function( \n arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n",
      "2": "\n async def async_test_function( \n arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n",
      "3": "<DED> async def async_test_function( \n arg1: str, arg2: str, kwarg1: str = '', kwarg2: str = '' \n ): \n",
      "4": "<DED> async def async_test_function( \n arg1: str, arg2: str, kwarg1: str = \",\", kwarg2: str = \"\" \n ): \n"
    }
  },
  {
    "source_code": "                             annotations: SortedSet,\n                             links: List[Link] = None,\n                             groups: List[Group] = None,\n                             outer_type: Optional[type] = None,\n",
    "target_code": "                             annotations: SortedSet,\n                             links: Optional[List[Link]] = None,\n                             groups: Optional[List[Group]] = None,\n                             outer_type: Optional[type] = None,\n",
    "warning_line": "                             links: List[Link] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " links is declared to have type `List[Link]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 201,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "asyml/forte",
    "source_filename": "nlp/pipeline/data/data_pack.py",
    "target_filename": "nlp/pipeline/data/data_pack.py",
    "source_changeid": "396341db25766e8991f63bdf817bcecf7af53846^",
    "target_changeid": "396341db25766e8991f63bdf817bcecf7af53846",
    "predictions": [
      "annotations: SortedSet, \n links: Optional[List[Link]] = None, \n groups: Optional[List[Group]] = None, \n outer_type: Optional[type] = None, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "annotations: SortedSet, \n links: Optional[List[Link]] = None, \n groups: Optional[List[Group]] = None, \n outer_type: Optional[type] = None, \n",
      "1": "annotations: SortedSet, \n links: List[Link], \n groups: List[Group] = None, \n outer_type: Optional[type] = None, \n",
      "2": "annotations: SortedSet, \n links: SortedSet, \n groups: SortedSet = None, \n outer_type: Optional[type] = None, \n",
      "3": "annotations: SortedSet, \n links: Optional[List[Link]] = None, \n groups: Optional[List[Group]] = None, \n outer_type: Optional[type] = None, <IND>",
      "4": "annotations: SortedSet, \n links: Optional[List[Link]] = None, \n groups: Optional[List[Group]] = None, \n outer_type: Optional[type] = None, <DED>"
    }
  },
  {
    "source_code": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: LabelSegmenter = None,\n                  speakers: List[str] = None, lazy: bool = True,\n",
    "target_code": "                  utterance_filter: Callable[[Utterance], bool] = None,\n                  label_segmenter: Optional[LabelSegmenter] = None,\n                  speakers: List[str] = None, lazy: bool = True,\n",
    "warning_line": "                  label_segmenter: LabelSegmenter = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " label_segmenter is declared to have type `LabelSegmenter` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 238,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "persephone-tools/persephone",
    "source_filename": "persephone/corpus.py",
    "target_filename": "persephone/corpus.py",
    "source_changeid": "e0567f8f99719ca7091b55a5258ee9d844d742cf^",
    "target_changeid": "e0567f8f99719ca7091b55a5258ee9d844d742cf",
    "predictions": [
      "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: Optional[LabelSegmenter] = None, \n speakers: Optional[List[str]] = None, lazy: bool = True, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: Optional[LabelSegmenter] = None, \n speakers: Optional[List[str]] = None, lazy: bool = True, \n",
      "1": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: LabelSegmenter, \n speakers: List[str] = None, lazy: bool = True, \n",
      "2": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: LabelSegmenter = \"\", \n speakers: List[str] = None, lazy: bool = True, \n",
      "3": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter=LabelSegmenter, \n speakers: List[str] = None, lazy: bool = True, \n",
      "4": "utterance_filter: Callable[[Utterance], bool] = None, \n label_segmenter: Optional[LabelSegmenter] = None, \n speakers: Optional[List[str]] = None, lazy: bool = True, <IND>"
    }
  },
  {
    "source_code": "\n    def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None,\n                 parent:Optional[CardDF]=None, rec_len:int=None, size={1,None}):\n        <IND>",
    "target_code": "\n    def __init__(self, fid:str, rec_len:int, sfid:str=None, name:str=None, desc:str=None,\n                 parent:Optional[CardDF]=None, size={1,None}):\n        <IND>",
    "warning_line": "                 parent:Optional[CardDF]=None, rec_len:int=None, size={1,None}):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " rec_len is declared to have type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 687,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "osmocom/pysim",
    "source_filename": "pySim/filesystem.py",
    "target_filename": "pySim/filesystem.py",
    "source_changeid": "1e45657e0f177388379f37e8557ac1cfdbac32a5^",
    "target_changeid": "1e45657e0f177388379f37e8557ac1cfdbac32a5",
    "predictions": [
      "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent: Optional[CardDF]=None, rec_len: Optional[int]=None, size= { 1,None } ): \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent: Optional[CardDF]=None, rec_len: Optional[int]=None, size= { 1,None } ): \n <IND>",
      "1": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent:Optional[CardDF]=None, rec_len:int=None, size= { 1,None } ): \n <IND>",
      "2": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent=None, rec_len=None, size= { 1,None } ): \n <IND>",
      "3": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent=Optional[CardDF]=None, rec_len:int=None, size= { 1,None } ): \n <IND>",
      "4": "\n def __init__(self, fid:str, sfid:str=None, name:str=None, desc:str=None, \n parent=None, rec_len:int=None, size= { 1,None } ): \n <IND>"
    }
  },
  {
    "source_code": "        self,\n        gw: \"Gateway\" = None,\n        dev_info: SubDeviceInfo = None,\n        model_info: Optional[Dict] = None,\n",
    "target_code": "        self,\n        gw: \"Gateway\",\n        dev_info: SubDeviceInfo,\n        model_info: Optional[Dict] = None,\n",
    "warning_line": "        dev_info: SubDeviceInfo = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " dev_info is declared to have type `SubDeviceInfo` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 35,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "rytilahti/python-miio",
    "source_filename": "miio/gateway/devices/subdevice.py",
    "target_filename": "miio/gateway/devices/subdevice.py",
    "source_changeid": "6453bfee512150e3f062670e890533fcd67067ea^",
    "target_changeid": "6453bfee512150e3f062670e890533fcd67067ea",
    "predictions": [
      "self, \n gw: Optional[\"Gateway\"] = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self, \n gw: Optional[\"Gateway\"] = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "1": "self, \n gw: \"Gateway\", \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "2": "self, \n gw: \"Gateway\" = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "3": "self, \n gw: Optional[\"Gateway\") = None, \n dev_info: Optional[SubDeviceInfo] = None, \n model_info: Optional[Dict] = None, \n",
      "4": "self, \n gw: \"Gateway\", \n dev_info: SubDeviceInfo, \n model_info: Optional[Dict] = None, \n"
    }
  },
  {
    "source_code": "                summarise_result: bool = False,\n                cat_vars_start_idx: Sequence[int] = None,\n                cat_vars_enc_dim: Sequence[int] = None,\n                **kwargs) -> Explanation:\n",
    "target_code": "                summarise_result: bool = False,\n                cat_vars_start_idx: Optional[Sequence[int]] = None,\n                cat_vars_enc_dim: Optional[Sequence[int]] = None,\n                **kwargs) -> Explanation:\n",
    "warning_line": "                cat_vars_start_idx: Sequence[int] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " cat_vars_start_idx is declared to have type `Sequence[int]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 783,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "SeldonIO/alibi",
    "source_filename": "alibi/explainers/shap_wrappers.py",
    "target_filename": "alibi/explainers/shap_wrappers.py",
    "source_changeid": "dcf6282c677d0cab48f62e23f707f4ad05497d60^",
    "target_changeid": "dcf6282c677d0cab48f62e23f707f4ad05497d60",
    "predictions": [
      "summarise_result: bool = False, \n cat_vars_start_idx: Optional[Sequence[int]] = None, \n cat_vars_enc_dim: Optional[Sequence[int]] = None, \n **kwargs) -> Explanation: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "summarise_result: bool = False, \n cat_vars_start_idx: Optional[Sequence[int]] = None, \n cat_vars_enc_dim: Optional[Sequence[int]] = None, \n **kwargs) -> Explanation: \n",
      "1": "summarisese_result: bool = False, \n cat_vars_start_idx: Optional[Sequence[int]] = None, \n cat_vars_enc_dim: Optional[Sequence[int]] = None, \n **kwargs) -> Explanation: \n",
      "2": "summarise_result: bool = False, \n cat_vars_start_idx: Optional[Sequence[int]] = None, \n cat_vars_enc_dim: Optional[Sequence[int]] = None, \n **kwargs) -> Explanation: <IND>",
      "3": "summarise_result: bool = False, \n cat_vars_start_idx: Optional[Sequence[int]] = None, \n cat_vars_enc_dim: Optional[Sequence[int]] = None, <IND> **kwargs) -> Explanation: \n",
      "4": "summarise_result: bool = False, \n cat_vars_start_idx: Sequence[str, int] = (), \n cat_vars_enc_dim: Sequence[str, int] = (), \n **kwargs) -> Explanation: \n"
    }
  },
  {
    "source_code": "        classifier_weights: Union[list, np.ndarray, None] = None,\n        channel_index: int = Deprecated,\n        channels_first: bool = False,\n",
    "target_code": "        classifier_weights: Union[list, np.ndarray, None] = None,\n        channel_index=Deprecated,\n        channels_first: bool = False,\n",
    "warning_line": "        channel_index: int = Deprecated,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " channel_index is declared to have type `int` but is used as type `art.utils._Deprecated`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 52,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Trusted-AI/adversarial-robustness-toolbox",
    "source_filename": "art/estimators/classification/ensemble.py",
    "target_filename": "art/estimators/classification/ensemble.py",
    "source_changeid": "e9e70152a0070f2bb6b5e77c3c5f5f3fc6176c0c^",
    "target_changeid": "e9e70152a0070f2bb6b5e77c3c5f5f3fc6176c0c",
    "predictions": [
      "classifier_weights: Union[list, np.ndarray, None] = None, \n channel_index=Deprecated, \n channels_first: bool = False, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "classifier_weights: Union[list, np.ndarray, None] = None, \n channel_index=Deprecated, \n channels_first: bool = False, \n",
      "1": "classifier_weights: Union[list, np.ndarray, None] = None, \n channel_index = Deprecated, \n channels_first: bool = False, \n",
      "2": "classifier_weights: Union[list, np.ndarray, None] = None, \n channel_index=Deprecated, \n channels_first: bool = False, <IND>",
      "3": "classifier_weights: Union[list, np.ndarray, None] = None, \n channel_index=Deprecated, \n channels_first: bool = False, <DED>",
      "4": "classifier_weights: Union[list, np.ndarray, None] = None, <DED> channel_index=Deprecated, \n channels_first: bool = False, \n"
    }
  },
  {
    "source_code": "        amount=None,\n        account=None,\n        time_in_force=None,\n        local_vars_configuration=None,\n",
    "target_code": "        amount=None,\n        account='normal',\n        time_in_force='gtc',\n        local_vars_configuration=None,\n",
    "warning_line": "        account=None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " account is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 59,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "gateio/gateapi-python",
    "source_filename": "gate_api/models/spot_price_put_order.py",
    "target_filename": "gate_api/models/spot_price_put_order.py",
    "source_changeid": "42ffacad340a2a27583abe48b1f68cf043bbdd3d^",
    "target_changeid": "42ffacad340a2a27583abe48b1f68cf043bbdd3d",
    "predictions": [
      "amount=None, \n account_in_force=None, \n local_vars_configuration=None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "amount=None, \n account_in_force=None, \n local_vars_configuration=None, \n",
      "1": "amount=None, \n time_in_force=None, \n local_vars_configuration=None, \n",
      "2": "amount=None, \n account_id=None, \n time_in_force=None, \n local_vars_configuration=None, \n",
      "3": "amount=None, \n account=str(None), \n time_in_force=None, \n local_vars_configuration=None, \n",
      "4": "amount=None, \n account=str, \n time_in_force=None, \n local_vars_configuration=None, \n"
    }
  },
  {
    "source_code": "\n    <DED><DED>def run(self, host: str = None, port: int = None, *args, **kwargs):\n        <IND>host = host or self.config.HOST\n",
    "target_code": "\n    <DED><DED>def run(self, host: Optional[str] = None, port: Optional[int] = None,\n            *args, **kwargs) -> None:\n        <IND>host = host or self.config.HOST\n",
    "warning_line": "    def run(self, host: str = None, port: int = None, *args, **kwargs):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " host is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 49,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "nonebot/nonebot2",
    "source_filename": "none/__init__.py",
    "target_filename": "none/__init__.py",
    "source_changeid": "0046ebacacb8205987a579d4c9c8681d89f081cd^",
    "target_changeid": "0046ebacacb8205987a579d4c9c8681d89f081cd",
    "predictions": [
      "\n <DED> <DED> def run(self, host: Optional[str] = None, port: Optional[int] = None, \n *args, **kwargs) -> None: \n <IND> host = host or self.config.HOST \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> <DED> def run(self, host: Optional[str] = None, port: Optional[int] = None, \n *args, **kwargs) -> None: \n <IND> host = host or self.config.HOST \n",
      "1": "\n <DED> <DED> def run(self, host: Optional[str] = None, port: Optional[int] = None, <DED> *args, **kwargs) -> None: \n <IND> host = host or self.config.HOST \n",
      "2": "\n <DED> <DED> def run(self, host: Optional[str] = None, port: Optional[int] = None, <IND> *args, **kwargs) -> None: \n <IND> host = host or self.config.HOST \n",
      "3": "\n <DED> <DED> def run(self, host: Optional[str] = None, port: Optional[int] = None, \n *args, **kwargs): \n <IND> host = host or self.config.HOST \n",
      "4": "\n <DED> <DED> def run(self, host: Optional[str] = None, port: Optional[int] = None, <DED> *args, **kwargs): \n <IND> host = host or self.config.HOST \n"
    }
  },
  {
    "source_code": "        <IND>def __init__(self, component: str, begin: int, end: int,\n                     tid: str = None):\n            <IND>super().__init__(component, begin, end, tid)\n",
    "target_code": "        <IND>def __init__(self, component: str, begin: int, end: int,\n                     tid: Optional[str] = None):\n            <IND>super().__init__(component, begin, end, tid)\n",
    "warning_line": "                     tid: str = None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tid is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 39,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "asyml/forte",
    "source_filename": "nlp/pipeline/data/readers/ontonotes_reader.py",
    "target_filename": "nlp/pipeline/data/readers/ontonotes_reader.py",
    "source_changeid": "396341db25766e8991f63bdf817bcecf7af53846^",
    "target_changeid": "396341db25766e8991f63bdf817bcecf7af53846",
    "predictions": [
      "<IND> def __init__(self, component: str, begin: int, end: int, \n tid: Optional[str] = None): \n <IND> super().__init__(component, begin, end, tid) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> def __init__(self, component: str, begin: int, end: int, \n tid: Optional[str] = None): \n <IND> super().__init__(component, begin, end, tid) \n",
      "1": "<IND> def __init__(self, component: str, begin: int, end: int, \n tid: Optional[str] = None) -> None: \n <IND> super().__init__(component, begin, end, tid) \n",
      "2": "<IND> def __init__(self, component: Optional[str] = None, begin: int, end: int, \n tid: Optional[str] = None): \n <IND> super().__init__(component, begin, end, tid) \n",
      "3": "<DED> def __init__(self, component: str, begin: int, end: int, \n tid: Optional[str] = None): \n <IND> super().__init__(component, begin, end, tid) \n",
      "4": "<IND> def __init__(self, component: str, begin: int, end: int, \n tid: Optional[str] = None) -> bool: \n <IND> super().__init__(component, begin, end, tid) \n"
    }
  },
  {
    "source_code": "                 coeffs: Sequence[IntOrFQ],\n                 modulus_coeffs: Sequence[IntOrFQ] = None) -> None:\n        <IND>if self.field_modulus is None:\n",
    "target_code": "                 coeffs: Sequence[IntOrFQ],\n                 modulus_coeffs: Sequence[IntOrFQ] = ()) -> None:\n        <IND>if self.field_modulus is None:\n",
    "warning_line": "                 modulus_coeffs: Sequence[IntOrFQ] = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " modulus_coeffs is declared to have type `Sequence[typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 204,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ethereum/py_ecc",
    "source_filename": "py_ecc/fields/field_elements.py",
    "target_filename": "py_ecc/fields/field_elements.py",
    "source_changeid": "3d7d64f4a1f446acb00b183b7877e5c0c8458fd5^",
    "target_changeid": "3d7d64f4a1f446acb00b183b7877e5c0c8458fd5",
    "predictions": [
      "coeffs: Sequence[IntOrFQ], \n modulus_coeffs: Sequence[IntOrFQ] = ()) -> None: \n <IND> if self.field_modulus is None: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "coeffs: Sequence[IntOrFQ], \n modulus_coeffs: Sequence[IntOrFQ] = ()) -> None: \n <IND> if self.field_modulus is None: \n",
      "1": "coeffs: Sequence[IntOrFQ], \n modulus_coeffs: Optional[Sequence[IntOrFQ]] = None) -> None: \n <IND> if self.field_modulus is None: \n",
      "2": "coeffs: Sequence[IntOrFQ], \n modulus_coeffs: Sequence[IntOrFQ] = []) -> None: \n <IND> if self.field_modulus is None: \n",
      "3": "coeffs: Sequence[IntOrFQ], \n modulus_coeffs: Sequence[IntOrFQ] = None) -> None: \n <IND> if self.field_modulus is None: \n",
      "4": "coeffs: Sequence[IntOrFQ], \n modulus_coeffs: Sequence[[IntOrFQ]] = ()) -> None: \n <IND> if self.field_modulus is None: \n"
    }
  },
  {
    "source_code": "        quality: int = 50,\n        channel_index: int = Deprecated,\n        channels_first: bool = False,\n",
    "target_code": "        quality: int = 50,\n        channel_index=Deprecated,\n        channels_first: bool = False,\n",
    "warning_line": "        channel_index: int = Deprecated,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " channel_index is declared to have type `int` but is used as type `art.utils._Deprecated`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 62,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Trusted-AI/adversarial-robustness-toolbox",
    "source_filename": "art/defences/preprocessor/jpeg_compression.py",
    "target_filename": "art/defences/preprocessor/jpeg_compression.py",
    "source_changeid": "e9e70152a0070f2bb6b5e77c3c5f5f3fc6176c0c^",
    "target_changeid": "e9e70152a0070f2bb6b5e77c3c5f5f3fc6176c0c",
    "predictions": [
      "quality: int = 50, \n channel_index=Deprecated, \n channels_first: bool = False, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "quality: int = 50, \n channel_index=Deprecated, \n channels_first: bool = False, \n",
      "1": "quality: int = 50, \n channel_index = Deprecated, \n channels_first: bool = False, \n",
      "2": "quality: int = 50, \n channel_index=Deprecated, \n channels_first: bool = False, <IND>",
      "3": "quality: int = 50, \n channel_index=Deprecated, \n channels_first: bool = False, <DED>",
      "4": "quality: int = 50, <DED> channel_index=Deprecated, \n channels_first: bool = False, \n"
    }
  },
  {
    "source_code": "\n    def __init__(self, bin_paths: None = None, env: Mapping[str, str] = None) -> None:\n        <IND>self._bin_paths = bin_paths\n",
    "target_code": "\n    def __init__(\n        self, bin_paths: None = None, env: Optional[Mapping[str, str]] = None\n    ) -> None:\n        <IND>self._bin_paths = bin_paths\n",
    "warning_line": "    def __init__(self, bin_paths: None = None, env: Mapping[str, str] = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " env is declared to have type `Mapping[str, str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 56,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "theacodes/nox",
    "source_filename": "nox/virtualenv.py",
    "target_filename": "nox/virtualenv.py",
    "source_changeid": "4ea20511bb6362bd4dd7a35e7943e9c1f67b2d62^",
    "target_changeid": "4ea20511bb6362bd4dd7a35e7943e9c1f67b2d62",
    "predictions": [
      "\n def __init__(self, bin_paths: Optional[None] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def __init__(self, bin_paths: Optional[None] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "1": "\n def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "2": "\n def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "3": "\n def __init__(self, bin_paths: Optional[Mapping[str, str]] = None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n",
      "4": "\n def __init__(self, bin_paths: None, env: Optional[Mapping[str, str]] = None) -> None: \n <IND> self._bin_paths = bin_paths \n"
    }
  },
  {
    "source_code": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Dict[str, Any] = None,\n                 positional_bindings: List[Any] = None) -> None:\n        <IND>self.query_string = query_string\n",
    "target_code": "    def __init__(self, query_string: str, allow_literals: bool = True,\n                 named_bindings: Optional[Dict[str, Any]] = None,\n                 positional_bindings: Optional[List[Any]] = None) -> None:\n        <IND>self.query_string = query_string\n",
    "warning_line": "                 named_bindings: Dict[str, Any] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " named_bindings is declared to have type `Dict[str, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 105,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "talkiq/gcloud-aio",
    "source_filename": "datastore/gcloud/aio/datastore/query.py",
    "target_filename": "datastore/gcloud/aio/datastore/query.py",
    "source_changeid": "82af90a9877490b01daff1af609a39a2525d2db2^",
    "target_changeid": "82af90a9877490b01daff1af609a39a2525d2db2",
    "predictions": [
      "def __init__(self, query_string: str, allow_literals: bool = True, \n named_bindings: Optional[Dict[str, Any]] = None, \n positional_bindings: Optional[List[Any]] = None) -> None: \n <IND> self.query_string = query_string \n"
    ],
    "correct": true,
    "top_five": {
      "0": "def __init__(self, query_string: str, allow_literals: bool = True, \n named_bindings: Optional[Dict[str, Any]] = None, \n positional_bindings: Optional[List[Any]] = None) -> None: \n <IND> self.query_string = query_string \n",
      "1": "def __init__(self, query_string: str, allow_literals: bool = True, \n named_bindings: Optional[Dict[str, Any]] = None, \n positional_bindings: Optional[List[Any]] = None) -> None: \n <DED> self.query_string = query_string \n",
      "2": "def __init__(self, query_string: str, allow_literals: bool = True, \n named_bindings: Optional[Dict[str, Any]] = None, \n positional_bindings: Optional[List[Any]] = None) -> None: \n \n self.query_string = query_string \n",
      "3": "def __init__(self, query_string: str, allow_literals: bool = True, \n named_bindings: Dict[str, Any] = (), \n positional_bindings: List[Any] = ()) -> None: \n <IND> self.query_string = query_string \n",
      "4": "def __init__(self, query_string: str, allow_literals: bool = True, \n named_bindings: Dict[str, Any] = [], \n positional_bindings: List[Any] = []) -> None: \n <IND> self.query_string = query_string \n"
    }
  },
  {
    "source_code": "        job: Dict,\n        region: str = None,\n        location: Optional[str] = None,\n",
    "target_code": "        job: Dict,\n        region: Optional[str] = None,\n        location: Optional[str] = None,\n",
    "warning_line": "        region: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " region is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1956,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "apache/airflow",
    "source_filename": "airflow/providers/google/cloud/operators/dataproc.py",
    "target_filename": "airflow/providers/google/cloud/operators/dataproc.py",
    "source_changeid": "174681911f96f17d41a4f560ca08d5e200944f7f^",
    "target_changeid": "174681911f96f17d41a4f560ca08d5e200944f7f",
    "predictions": [
      "job: Dict, \n region: Optional[str] = None, \n location: Optional[str] = None, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "job: Dict, \n region: Optional[str] = None, \n location: Optional[str] = None, \n",
      "1": "job: Dict, \n region: str, \n location: Optional[str] = None, \n",
      "2": "job: Dict, \n region: Optional[str] = None, \n location: Optional[str] = None, <IND>",
      "3": "job: Dict, <IND> region: Optional[str] = None, \n location: Optional[str] = None, \n",
      "4": "job: Dict, \n region: Optional[str] = None, \n location: Optional[str] = None, <DED>"
    }
  },
  {
    "source_code": "               units: Tuple = (128, 64),\n               activation: Callable = \"tanh\",\n               dropout_rate: float = 0.0,\n",
    "target_code": "               units: Tuple = (128, 64),\n               activation: Callable = activations.tanh,\n               dropout_rate: float = 0.0,\n",
    "warning_line": "               activation: Callable = \"tanh\",",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " activation is declared to have type `typing.Callable[..., typing.Any]` but is used as type `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 573,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "deepchem/deepchem",
    "source_filename": "deepchem/models/layers.py",
    "target_filename": "deepchem/models/layers.py",
    "source_changeid": "475c85998693fdc3b960e4caf9fe25472578c63f^",
    "target_changeid": "475c85998693fdc3b960e4caf9fe25472578c63f",
    "predictions": [
      "units: Tuple = (128, 64), \n activation: Callable = activations.tanh, \n dropout_rate: float = 0.0, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "units: Tuple = (128, 64), \n activation: Callable = activations.tanh, \n dropout_rate: float = 0.0, \n",
      "1": "units: Tuple = (128, 64), \n activation: Callable = activation.tanh, \n dropout_rate: float = 0.0, \n",
      "2": "units: Tuple = (128, 64), \n activation: Optional[Callable] = \"tanh\", \n dropout_rate: float = 0.0, \n",
      "3": "units: Tuple = (128, 64), \n activation: Callable = activations.tanh \n dropout_rate: float = 0.0, \n",
      "4": "units: Tuple = (128, 64), \n activation: Callable = activations.tanh, \n dropout_rate: float = 0.0, <IND>"
    }
  },
  {
    "source_code": "        initial_presence=None,\n        intents: type_hints.NotRequired[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=1_000,\n        proxy_auth=None,\n",
    "target_code": "        initial_presence=None,\n        intents: type_hints.Nullable[GatewayIntent] = None,\n        json_deserialize=json.loads,\n        json_serialize=json.dumps,\n        large_threshold=250,\n        proxy_auth=None,\n",
    "warning_line": "        intents: type_hints.NotRequired[GatewayIntent] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " intents is declared to have type `typing.Union[GatewayIntent, hikari.internal_utilities.unspecified.Unspecified]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 210,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "hikari-py/hikari",
    "source_filename": "hikari/net/gateway.py",
    "target_filename": "hikari/net/gateway.py",
    "source_changeid": "3891970b5751f1ca98710447199236a3867a9703^",
    "target_changeid": "3891970b5751f1ca98710447199236a3867a9703",
    "predictions": [
      "initial_presence=None, \n intents: typing.Optional[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "initial_presence=None, \n intents: typing.Optional[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "1": "initial_presence=None, \n intents: typing.Optional[type_hints.NotRequired[GatewayIntent]] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "2": "initial_presence=None, \n intents: type_hints.NotRequired[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "3": "initial_presence=None, \n intents=type_hints.NotRequired[GatewayIntent] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n",
      "4": "initial_presence=None, \n intents: typing.Optional[Type_hints.NotRequired[GatewayIntent]] = None, \n json_deserialize=json.loads, \n json_serialize=json.dumps, \n large_threshold=1_000, \n proxy_auth=None, \n"
    }
  },
  {
    "source_code": "<DED>def move_fs(src_fs, dst_fs, workers=0):\n    # type: (Union[Text, FS], Union[Text, FS]) -> None\n    <IND>",
    "target_code": "<DED>def move_fs(src_fs, dst_fs, workers=0):\n    # type: (Union[Text, FS], Union[Text, FS], int) -> None\n    <IND>",
    "warning_line": "def move_fs(src_fs, dst_fs, workers=0):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " workers is declared to have type `Union[FS, str]` but is used as type `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 18,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PyFilesystem/pyfilesystem2",
    "source_filename": "fs/move.py",
    "target_filename": "fs/move.py",
    "source_changeid": "ed8af089c52b3100f3c07f1ca9cc73ad0160b14f^",
    "target_changeid": "ed8af089c52b3100f3c07f1ca9cc73ad0160b14f",
    "predictions": [
      "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (FS, FS) -> None \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (FS, FS) -> None \n <IND>",
      "1": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (Union[Text, FS], Union[Text, FS]) -> None \n <IND>",
      "2": "<DED> def move_fs(src_fs, dst_fs, union=0): \n # type: (Union[Text, FS], Union[Text, FS]) -> None \n <IND>",
      "3": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (Union[FS], Union[FS]) -> None \n <IND>",
      "4": "<DED> def move_fs(src_fs, dst_fs, workers=0): \n # type: (FS, FS) -> None \n \n"
    }
  },
  {
    "source_code": "    <DED>async def async_instance_method(\n        self, arg1: str, arg2: str, kwarg1: str = None, kwarg2: str = None\n    ):\n",
    "target_code": "    <DED>async def async_instance_method(\n        self, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"\n    ):\n",
    "warning_line": "        self, arg1: str, arg2: str, kwarg1: str = None, kwarg2: str = None",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " kwarg2 is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 47,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "facebook/TestSlide",
    "source_filename": "tests/mock_callable_testslide.py",
    "target_filename": "tests/mock_callable_testslide.py",
    "source_changeid": "97c39d89c2a047a3396be659645bd89dab01d859^",
    "target_changeid": "97c39d89c2a047a3396be659645bd89dab01d859",
    "predictions": [
      "<DED> async def async_instance_method( \n self, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> async def async_instance_method( \n self, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n",
      "1": "<IND> async def async_instance_method( \n self, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n",
      "2": "\n async def async_instance_method( \n self, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\" \n ): \n",
      "3": "<DED> async def async_instance_method( \n self, arg1: str, arg2: str, kwarg1: str = \",\", kwarg2: str = \"\" \n ): \n",
      "4": "<DED> async def async_instance_method( \n self, arg1: str, arg2: str, kwarg1: str = '', kwarg2: str = '' \n ): \n"
    }
  },
  {
    "source_code": "                                https: bool = False,\n                                ssl_key: str = None,\n                                ssl_cert: str = None):\n\n",
    "target_code": "                                https: bool = False,\n                                ssl_key: Optional[str] = None,\n                                ssl_cert: Optional[str] = None) -> None:\n\n",
    "warning_line": "                                ssl_key: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " ssl_key is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 68,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "deepmipt/DeepPavlov",
    "source_filename": "deeppavlov/utils/ms_bot_framework/server.py",
    "target_filename": "deeppavlov/utils/ms_bot_framework/server.py",
    "source_changeid": "0f32759c67ea961737a6538fd37426f564bae925^",
    "target_changeid": "0f32759c67ea961737a6538fd37426f564bae925",
    "predictions": [
      "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n \n",
      "1": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None) -> None: \n \n",
      "2": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n <IND>",
      "3": "https: bool = False, \n str_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n \n",
      "4": "https: bool = False, \n ssl_key: Optional[str] = None, \n ssl_cert: Optional[str] = None): \n <DED>"
    }
  },
  {
    "source_code": "# global queue\nCHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0\n\n",
    "target_code": "# global queue\nCHANNEL_IDENTIFIER_GLOBAL_QUEUE = typing.ChannelID(0)\n\n",
    "warning_line": "CHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " CHANNEL_IDENTIFIER_GLOBAL_QUEUE is declared to have type `typing.ChannelID` but is used as type `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 14,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/mediated_transfer/events.py",
    "target_filename": "raiden/transfer/mediated_transfer/events.py",
    "source_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82^",
    "target_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82",
    "predictions": [
      "# global queue \n CHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0 \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# global queue \n CHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0 \n \n",
      "1": "# global queue \n CHANNEL_IDENTIFIER_CHANNEL_INTERNAL_QUEUE: typing.Int = 0 \n \n",
      "2": "# global queue \n CHANNEL_IDENTIFIER_CHANNEL_QUEUE: typing.ChannelID = 0 \n \n",
      "3": "# global queue \n CHANNEL_IDENTIFIER_INTERNAL_QUEUE: typing.Int = 0 \n \n",
      "4": "# global queue \n CHANNEL_IDENTIFIER_GLOBAL_QUEUE: typing.ChannelID = 0, \n \n"
    }
  },
  {
    "source_code": "\n        _loader: Callable = None\n        if isinstance(load, str):\n            <IND>if \"/\" in load:\n                <IND>_loader = partial(loader, load)\n            <DED>else:\n",
    "target_code": "\n        if isinstance(load, str):\n            <IND>if \"/\" in load:\n                <IND>_loader: Callable = partial(loader, load)\n            <DED>else:\n",
    "warning_line": "        _loader: Callable = None",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " _loader is declared to have type `typing.Callable[..., typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 113,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ClearcodeHQ/pytest-postgresql",
    "source_filename": "src/pytest_postgresql/janitor.py",
    "target_filename": "src/pytest_postgresql/janitor.py",
    "source_changeid": "0a12849075a281010183becd1bbcce3b537a476f^",
    "target_changeid": "0a12849075a281010183becd1bbcce3b537a476f",
    "predictions": [
      "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n",
      "1": "\n _loader: Callable = None \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n",
      "2": "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <IND> else: \n",
      "3": "\n _loader: Callable = [] \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n \n else: \n",
      "4": "\n _loader: Callable = '' \n if isinstance(load, str): \n <IND> if \"/\" in load: \n <IND> _loader = partial(loader, load) \n <DED> else: \n"
    }
  },
  {
    "source_code": "    scale_factor: float,\n    fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit],\n    fold_method_args: Tuple[Any] = (),\n    **kwargs,\n",
    "target_code": "    scale_factor: float,\n    fold_method: Callable[..., Circuit],\n    fold_method_args: Optional[Tuple[Any]] = None,\n    **kwargs,\n",
    "warning_line": "    fold_method_args: Tuple[Any] = (),",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " fold_method_args is declared to have type `Tuple[typing.Any]` but is used as type `Tuple[]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 789,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "unitaryfund/mitiq",
    "source_filename": "mitiq/zne/scaling.py",
    "target_filename": "mitiq/zne/scaling.py",
    "source_changeid": "bac97a396e5570f4884b62ba9094466a3bb881cc^",
    "target_changeid": "bac97a396e5570f4884b62ba9094466a3bb881cc",
    "predictions": [
      "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any] = (), \n **kwargs, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any] = (), \n **kwargs, \n",
      "1": "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Optional[Tuple[Any]] = (), \n **kwargs, \n",
      "2": "scale_factor: float, \n fold_method: Optional[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Optional[Tuple[Any]] = (), \n **kwargs, \n",
      "3": "scale_factor: float, \n fold_method: Callable[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any, Any] = (), \n **kwargs, \n",
      "4": "scale_factor: float, \n fold_method: Tuple[[Circuit, float, Tuple[Any]], Circuit], \n fold_method_args: Tuple[Any] = (), \n **kwargs, \n"
    }
  },
  {
    "source_code": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]\n        return categories\n",
    "target_code": "        all_classes = self.objc_classes()\n        categories: List[ObjcCategory] = [c for c in all_classes if isinstance(c, ObjcCategory)]\n        return categories\n",
    "warning_line": "        categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory]",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " categories is declared to have type `List[ObjcCategory]` but is used as type `List[ObjcClass]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 89,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "datatheorem/strongarm",
    "source_filename": "strongarm/macho/macho_analyzer.py",
    "target_filename": "strongarm/macho/macho_analyzer.py",
    "source_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8^",
    "target_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "predictions": [
      "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory] \n return categories \n"
    ],
    "correct": false,
    "top_five": {
      "0": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if type(c) == ObjcCategory] \n return categories \n",
      "1": "all_classes = self.objc_classes() \n categories: List[List[ObjcCategory]] = [c for c in all_classes if type(c) == ObjcCategory] \n return categories \n",
      "2": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if ObjcCategory] \n return categories \n",
      "3": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if objcCategory] \n return categories \n",
      "4": "all_classes = self.objc_classes() \n categories: List[ObjcCategory] = [c for c in all_classes if c == ObjcCategory] \n return categories \n"
    }
  },
  {
    "source_code": "        self,\n        keys: typing.Union[Field, type] = None,\n        values: typing.Union[Field, type] = None,\n        **kwargs\n",
    "target_code": "        self,\n        keys: typing.Optional[typing.Union[Field, type]] = None,\n        values: typing.Optional[typing.Union[Field, type]] = None,\n        **kwargs\n",
    "warning_line": "        keys: typing.Union[Field, type] = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " keys is declared to have type `typing.Union[typing.Type[typing.Any], Field]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1449,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "marshmallow-code/marshmallow",
    "source_filename": "src/marshmallow/fields.py",
    "target_filename": "src/marshmallow/fields.py",
    "source_changeid": "43db1072f94ae6af40cbedc058f1c02f3cedb379^",
    "target_changeid": "43db1072f94ae6af40cbedc058f1c02f3cedb379",
    "predictions": [
      "self, \n keys: typing.Optional[typing.Union[Field, type]] = None, \n values: typing.Optional[typing.Union[Field, type]] = None, \n **kwargs \n"
    ],
    "correct": true,
    "top_five": {
      "0": "self, \n keys: typing.Optional[typing.Union[Field, type]] = None, \n values: typing.Optional[typing.Union[Field, type]] = None, \n **kwargs \n",
      "1": "self, \n keys: typing.Optional[typing.Union[Field, type], Field]] = None, \n values: typing.Optional[typing.Union[Field, type]] = None, \n **kwargs \n",
      "2": "self, \n keys: typing.Optional[typing.Union[Field, type]] = None, \n values: typing.Optional[typing.Union[Field, type], Field]] = None, \n **kwargs \n",
      "3": "self, \n keys: typing.Optional[typing.Union[Field, type], Field]] = None, \n values: typing.Optional[typing.Union[Field, type], Field]] = None, \n **kwargs \n",
      "4": "self, \n keys: typing.Optional[typing.Union[Field, type]] = None, \n values: typing.Optional[typing.Union[Field, type]] = None, \n **kwargs <IND>"
    }
  },
  {
    "source_code": "               accumulator: _T,\n               sort_key: interfaces.renderers.ColumnSortKey = None) -> _T:\n        <IND>\"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
    "target_code": "               accumulator: _T,\n               sort_key: typing.Optional[interfaces.renderers.ColumnSortKey] = None) -> _T:\n        <IND>\"\"\"Visits all the nodes in a tree, calling function on each one\"\"\"\n",
    "warning_line": "               sort_key: interfaces.renderers.ColumnSortKey = None) -> _T:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " sort_key is declared to have type `interfaces.renderers.ColumnSortKey` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 293,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "volatilityfoundation/volatility3",
    "source_filename": "volatility/framework/renderers/__init__.py",
    "target_filename": "volatility/framework/renderers/__init__.py",
    "source_changeid": "7a52ac9debc6e0463a52ecc1c5cacc5dbb40a0d1^",
    "target_changeid": "7a52ac9debc6e0463a52ecc1c5cacc5dbb40a0d1",
    "predictions": [
      "accumulator: _T, \n sort_key: Optional[interfaces.renderers.ColumnSortKey] = None) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n"
    ],
    "correct": false,
    "top_five": {
      "0": "accumulator: _T, \n sort_key: Optional[interfaces.renderers.ColumnSortKey] = None) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "1": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = ()) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "2": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = \"\") -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "3": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = []) -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n",
      "4": "accumulator: _T, \n sort_key: interfaces.renderers.ColumnSortKey = \"\") -> _T: \n <IND> \"\"\"Visits all the nodes in a tree, calling function on each one\"\"\" \n"
    }
  },
  {
    "source_code": "\n    tags = [{'Key': key, 'Value': value} for (key, value) in tags.items()]\n\n",
    "target_code": "\n    tags_aws = [{'Key': key, 'Value': value} for (key, value) in tags.items()]\n\n",
    "warning_line": "    tags = [{'Key': key, 'Value': value} for (key, value) in tags.items()]",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `typing.List[typing.Dict[str, typing.Any]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 143,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "atlassian-labs/peerd",
    "source_filename": "peerd/aws.py",
    "target_filename": "peerd/aws.py",
    "source_changeid": "fc06a7e476bbcd5a177b171811af38b4ad171964^",
    "target_changeid": "fc06a7e476bbcd5a177b171811af38b4ad171964",
    "predictions": [
      "\n tags = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n tags = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n",
      "1": "\n tags = [ { 'Key': key, 'Value': value } for (key, value) in tags[str]] \n \n",
      "2": "\n labels = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n",
      "3": "\n tag = [ { 'Key': key, 'Value': value } for (key, value) in tags.items()] \n \n",
      "4": "\n tags = [ { 'Key': key, 'Value': value } for (key, value in tags.items()] \n \n"
    }
  },
  {
    "source_code": "            # Don't create a new selection_pool if we are not subbing anything\n            <IND>selection_pool: List[Any] = pool\n\n",
    "target_code": "            # Don't create a new selection_pool if we are not subbing anything\n            <IND>selection_pool = list(pool)\n\n",
    "warning_line": "            selection_pool: List[Any] = pool",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " selection_pool is declared to have type `List[typing.Any]` but is used as type `Sequence[typing.Any]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 456,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "libp2p/py-libp2p",
    "source_filename": "libp2p/pubsub/gossipsub.py",
    "target_filename": "libp2p/pubsub/gossipsub.py",
    "source_changeid": "b2f496d081db5176636449d585dbbdba7f71061d^",
    "target_changeid": "b2f496d081db5176636449d585dbbdba7f71061d",
    "predictions": [
      "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Any] = pool \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Any] = pool \n \n",
      "1": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: Optional[List[Any]] = pool \n \n",
      "2": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Sequence[Any]] = pool \n \n",
      "3": "# Don't create new selection_pool if we are not subbing anything \n <IND> selection_pool: List[Any] = pool \n \n",
      "4": "# Don't create a new selection_pool if we are not subbing anything \n <IND> selection_pool: Sequence[Any] = pool \n \n"
    }
  },
  {
    "source_code": "    <DED>async def _download(self, bucket: str, object_name: str, *,\n                        params: dict = None, timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
    "target_code": "    <DED>async def _download(self, bucket: str, object_name: str, *,\n                        params: Optional[Dict[str, str]] = None,\n                        timeout: int = 10,\n                        session: Optional[Session] = None) -> bytes:\n",
    "warning_line": "                        params: dict = None, timeout: int = 10,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " params is declared to have type `Dict[typing.Any, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 293,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "talkiq/gcloud-aio",
    "source_filename": "storage/gcloud/aio/storage/storage.py",
    "target_filename": "storage/gcloud/aio/storage/storage.py",
    "source_changeid": "82af90a9877490b01daff1af609a39a2525d2db2^",
    "target_changeid": "82af90a9877490b01daff1af609a39a2525d2db2",
    "predictions": [
      "<DED> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "1": "<DED> async def _download(self, bucket: str, object_name: str, *, <DED> params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "2": "<IND> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "3": "<DED> async def _download(self, bucket: str, object_name: str, *, \n params: Optional[dict] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n",
      "4": "<DED> async def _download(self, bucket: str, object_name: str, *, <IND> params: Optional[Dict[str, str]] = None, timeout: int = 10, \n session: Optional[Session] = None) -> bytes: \n"
    }
  },
  {
    "source_code": "            )\n            embeddings = cached_path(\n                f\"{base_path}{embeddings}/{model}_s{size}.zip\", cache_dir=cache_dir\n",
    "target_code": "            )\n            embeddings_path = cached_path(\n                f\"{base_path}{embeddings}/{model}_s{size}.zip\", cache_dir=cache_dir\n",
    "warning_line": "            embeddings = cached_path(",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " embeddings is declared to have type `str` but is used as type `Path`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 2090,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "flairNLP/flair",
    "source_filename": "flair/embeddings/token.py",
    "target_filename": "flair/embeddings/token.py",
    "source_changeid": "0b834f5167d11f06037398fcbe1554f244167e18^",
    "target_changeid": "0b834f5167d11f06037398fcbe1554f244167e18",
    "predictions": [
      ") \n embeddings_path = cached_path( \n f\" { base_path } { embeddings } / { model } _s { size }.zip\", cache_dir=cache_dir \n"
    ],
    "correct": true,
    "top_five": {
      "0": ") \n embeddings_path = cached_path( \n f\" { base_path } { embeddings } / { model } _s { size }.zip\", cache_dir=cache_dir \n",
      "1": ") \n embeddingspath = cached_path( \n f\" { base_path } { embeddings } / { model } _s { size }.zip\", cache_dir=cache_dir \n",
      "2": ") \n embeddings_path = cached_path( \n f\" { base_path } { embeddings } / { model \\ _s { size }.zip\", cache_dir=cache_dir \n",
      "3": ") \n embeddings_path = cached_path( \n embeddings_path = cached_path( \n f\" { base_path } { embeddings } / { model } _s { size }.zip\", cache_dir=cache_dir \n",
      "4": ") \n embeddings_path=cached_path( \n f\" { base_path } { embeddings } / { model } _s { size }.zip\", cache_dir=cache_dir \n"
    }
  },
  {
    "source_code": "\n    def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None):\n        <IND>super().__init__()\n",
    "target_code": "\n    def __init__(self, container, silent, lookups: FirmwareUpdateCheckerLookup, callback) -> None:\n        <IND>super().__init__()\n",
    "warning_line": "    def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " lookups is declared to have type `FirmwareUpdateCheckerLookup` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 27,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Cura",
    "source_filename": "plugins/FirmwareUpdateChecker/FirmwareUpdateCheckerJob.py",
    "target_filename": "plugins/FirmwareUpdateChecker/FirmwareUpdateCheckerJob.py",
    "source_changeid": "f2b50c748c1aea35e61de119fb3a08a28afdb295^",
    "target_changeid": "f2b50c748c1aea35e61de119fb3a08a28afdb295",
    "predictions": [
      "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None): \n <IND> super().__init__() \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None): \n <IND> super().__init__() \n",
      "1": "\n def __init__(self, container=None, silent=False, lookups=FirmwareUpdateCheckerLookup=None, callback=None): \n <IND> super().__init__() \n",
      "2": "\n def __init__(self, container=None, silent=False, lookups=FirmwareUpdateCheckerLookup, callback=None): \n <IND> super().__init__() \n",
      "3": "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None): \n <DED> super().__init__() \n",
      "4": "\n def __init__(self, container=None, silent=False, lookups:FirmwareUpdateCheckerLookup=None, callback=None) -> None: \n <IND> super().__init__() \n"
    }
  },
  {
    "source_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = None) -> None:\n        <IND>super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
    "target_code": "                 selectors: List['ObjcSelector'],\n                 protocols: List['ObjcProtocol'] = []) -> None:\n        <IND>super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols)\n",
    "warning_line": "                 protocols: List['ObjcProtocol'] = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " protocols is declared to have type `List[ObjcProtocol]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 42,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "datatheorem/strongarm",
    "source_filename": "strongarm/macho/objc_runtime_data_parser.py",
    "target_filename": "strongarm/macho/objc_runtime_data_parser.py",
    "source_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8^",
    "target_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "predictions": [
      "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "1": "selectors: List['ObjcSelector'], \n protocols: List['ObjcProtocol'] = []) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "2": "selectors: List['ObjcSelector'], \n protocols: List['ObjcProtocol'] = ()) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "3": "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <DED> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocols) \n",
      "4": "selectors: List['ObjcSelector'], \n protocols: Optional[List['ObjcProtocol']] = None) -> None: \n <IND> super(ObjcCategory, self).__init__(raw_struct, name, selectors, protocol) \n"
    }
  },
  {
    "source_code": "        gzip: bool = False,\n        acl_policy: str = None,\n        **kwargs,\n",
    "target_code": "        gzip: bool = False,\n        acl_policy: Optional[str] = None,\n        **kwargs,\n",
    "warning_line": "        acl_policy: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " acl_policy is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 82,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "apache/airflow",
    "source_filename": "airflow/providers/amazon/aws/transfers/ftp_to_s3.py",
    "target_filename": "airflow/providers/amazon/aws/transfers/ftp_to_s3.py",
    "source_changeid": "463e3b2b25ee5c116313160c64bb8e2644e1fef3^",
    "target_changeid": "463e3b2b25ee5c116313160c64bb8e2644e1fef3",
    "predictions": [
      "gzip: bool = False, \n acl_policy: Optional[str] = None, \n **kwargs, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "gzip: bool = False, \n acl_policy: Optional[str] = None, \n **kwargs, \n",
      "1": "gzip: bool = False, \n acl_policy: str = \"\", \n **kwargs, \n",
      "2": "gzip: bool = False, \n acl_policy: Optional[str] = None, \n **kwargs, <IND>",
      "3": "gzip: bool = False, \n acl_policy: Optional[str] = None, <IND> **kwargs, \n",
      "4": "gzip: bool = False, \n acl_policy: Optional[str] = None, \n **kwargs, <DED>"
    }
  },
  {
    "source_code": "    <DED>@classmethod\n    def class_method(cls, arg1: str, arg2: str, kwarg1: str = None, kwarg2: str = None):\n        <IND>return \"original response\"\n",
    "target_code": "    <DED>@classmethod\n    def class_method(cls, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"):\n        <IND>return \"original response\"\n",
    "warning_line": "    def class_method(cls, arg1: str, arg2: str, kwarg1: str = None, kwarg2: str = None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " kwarg2 is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 62,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "facebook/TestSlide",
    "source_filename": "tests/mock_callable_testslide.py",
    "target_filename": "tests/mock_callable_testslide.py",
    "source_changeid": "97c39d89c2a047a3396be659645bd89dab01d859^",
    "target_changeid": "97c39d89c2a047a3396be659645bd89dab01d859",
    "predictions": [
      "<DED> @classmethod \n def class_method(cls, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"): \n <IND> return \"original response\" \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> @classmethod \n def class_method(cls, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"): \n <IND> return \"original response\" \n",
      "1": "<IND> @classmethod \n def class_method(cls, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"): \n <IND> return \"original response\" \n",
      "2": "\n @classmethod \n def class_method(cls, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"): \n <IND> return \"original response\" \n",
      "3": "<DED> @classmethod \n def class_method(cls, arg1: str, arg2: str, kwarg1: str = \",\", kwarg2: str = \"\"): \n <IND> return \"original response\" \n",
      "4": "<DED> @classmethod \n def class_method(cls, arg1: str, arg2: str, kwarg1: str = \"\", kwarg2: str = \"\"): \n <DED> return \"original response\" \n"
    }
  },
  {
    "source_code": "            # Turn schema_field_updates into a dict keyed on field names\n            <IND>schema_fields_updates = {field[\"name\"]: field for field in deepcopy(schema_fields_updates)}\n\n",
    "target_code": "            # Turn schema_field_updates into a dict keyed on field names\n            <IND>schema_fields_updates_dict = {field[\"name\"]: field for field in deepcopy(schema_fields_updates)}\n\n",
    "warning_line": "            schema_fields_updates = {field[\"name\"]: field for field in deepcopy(schema_fields_updates)}",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " schema_fields_updates is declared to have type `List[Dict[str, typing.Any]]` but is used as type `Dict[typing.Any, Dict[str, typing.Any]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1422,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "apache/airflow",
    "source_filename": "airflow/providers/google/cloud/hooks/bigquery.py",
    "target_filename": "airflow/providers/google/cloud/hooks/bigquery.py",
    "source_changeid": "c6dbb3f8856be75ff2619476ab3ca587a52e033a^",
    "target_changeid": "c6dbb3f8856be75ff2619476ab3ca587a52e033a",
    "predictions": [
      "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n",
      "1": "# Turn schema_field_updates into dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n",
      "2": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates_number = { field[\"name\"]: field for field in deepcopy(schema_fields_updates) } \n \n",
      "3": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = [] \n field for field in deepcopy(schema_fields_updates)] \n \n",
      "4": "# Turn schema_field_updates into a dict keyed on field names \n <IND> schema_fields_updates = { field[\"name\"]: field in deepcopy(schema_fields_updates) } \n \n"
    }
  },
  {
    "source_code": "\n        start_cmd = shlex.split(start_cmd)\n        arguments = [f'\\t\\t<string>{arg}</string>' for arg in start_cmd]\n\n",
    "target_code": "\n        start_cmd_list = shlex.split(start_cmd)\n        arguments = [f'\\t\\t<string>{arg}</string>' for arg in start_cmd_list]\n\n",
    "warning_line": "        start_cmd = shlex.split(start_cmd)",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " start_cmd is declared to have type `str` but is used as type `typing.List[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 185,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "samschott/maestral",
    "source_filename": "maestral/utils/autostart.py",
    "target_filename": "maestral/utils/autostart.py",
    "source_changeid": "da644e1218754c2c247d16544d76b292d48f381c^",
    "target_changeid": "da644e1218754c2c247d16544d76b292d48f381c",
    "predictions": [
      "\n start_cmd = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n start_cmd = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "1": "\n start_cmd = str(split(start_cmd)) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "2": "\n start_cmd_split = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "3": "\n start_cmd_str = shlex.split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n",
      "4": "\n start_cmd=split(start_cmd) \n arguments = [f' \\ t \\ tstring> { arg } /string>' for arg in start_cmd] \n \n"
    }
  },
  {
    "source_code": "\nAER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str]] = {\n    'coal': ('col', 'woc', 'pc'),\n",
    "target_code": "\nAER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str, ...]] = {\n    'coal': ('col', 'woc', 'pc'),\n",
    "warning_line": "AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str]] = {",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " AER_FUEL_TYPE_STRINGS is declared to have type `Dict[str, Tuple[str]]` but is used as type `Dict[str, Union[Tuple[str], Tuple[str, str], Tuple[str, str, str]]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 382,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "catalyst-cooperative/pudl",
    "source_filename": "src/pudl/constants.py",
    "target_filename": "src/pudl/constants.py",
    "source_changeid": "4a23cb1d6b846a9647a0804f332b4777427ac4e6^",
    "target_changeid": "4a23cb1d6b846a9647a0804f332b4777427ac4e6",
    "predictions": [
      "\n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str,...]] = { \n 'coal': ('col', 'woc', 'pc'), \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str,...]] = { \n 'coal': ('col', 'woc', 'pc'), \n",
      "1": "\n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str, str]] = { \n 'coal': ('col', 'woc', 'pc'), \n",
      "2": "\n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str]] = { \n 'coal': ('col', 'woc', 'pc'), \n",
      "3": "\n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str,...]] = { \n 'coal': ('col', 'woc', 'pc'), \n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str,...]] = { \n",
      "4": "\n AER_FUEL_TYPE_STRINGS: Dict[str, Tuple[str,...]] = { \n 'coal': ('col', 'woc', 'pc'), \n 'coal': ('col', 'woc', 'pc'), \n"
    }
  },
  {
    "source_code": "\n<DED>def batch_start(identifier: str, batch_type: str, tags: dict=None):\n    <IND>return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
    "target_code": "\n<DED>def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]={}\n        ) -> 'utils.irc.IRCParsedLine':\n    <IND>return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type],\n",
    "warning_line": "def batch_start(identifier: str, batch_type: str, tags: dict=None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 84,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jesopo/bitbot",
    "source_filename": "src/utils/irc/protocol.py",
    "target_filename": "src/utils/irc/protocol.py",
    "source_changeid": "577fae7ceabfd2a43b798e02a67c518c23ed33bd^",
    "target_changeid": "577fae7ceabfd2a43b798e02a67c518c23ed33bd",
    "predictions": [
      "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "1": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "2": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Dict[str, str]= { } ) -> utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "3": "\n <DED> def batch_start(identifier: str, batch_type: str, tags: typing.Optional[typing.Dict[str, str]]= { } ) -> utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n",
      "4": "\n <DED> def batch_start(identifier: str, batch_type: str, \n tags: typing.Dict[str, str]= { } ): \n <IND> return utils.irc.IRCParsedLine(\"BATCH\", [\"+%s\" % identifier, batch_type], \n"
    }
  },
  {
    "source_code": "    def object(self,\n               symbol_name: str = None,\n               type_name: str = None,\n               offset: int = None,\n",
    "target_code": "    def object(self,\n               symbol_name: str,\n               type_name: str,\n               offset: int = None,\n",
    "warning_line": "               symbol_name: str = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " symbol_name is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 107,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "volatilityfoundation/volatility3",
    "source_filename": "volatility/framework/interfaces/context.py",
    "target_filename": "volatility/framework/interfaces/context.py",
    "source_changeid": "7a52ac9debc6e0463a52ecc1c5cacc5dbb40a0d1^",
    "target_changeid": "7a52ac9debc6e0463a52ecc1c5cacc5dbb40a0d1",
    "predictions": [
      "def object(self, \n symbol_name: Optional[str] = None, \n type_name: Optional[str] = None, \n offset: int = None, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "def object(self, \n symbol_name: Optional[str] = None, \n type_name: Optional[str] = None, \n offset: int = None, \n",
      "1": "def object(self, \n symbol_name: str, \n type_name: str, \n offset: int = None, \n",
      "2": "def object(self, \n symbol_name: str, \n type_name: Optional[str] = None, \n offset: int = None, \n",
      "3": "def object(self, \n symbol_name: typing.Optional[str] = None, \n type_name: typing.Optional[str] = None, \n offset: int = None, \n",
      "4": "def object(self, \n symbol_name: str = '', \n type_name: str = '', \n offset: int = None, \n"
    }
  },
  {
    "source_code": "\n        test: FlairDataset = DataPairDataset(\n            test_file,\n",
    "target_code": "\n        test = DataPairDataset(\n            test_file,\n",
    "warning_line": "        test: FlairDataset = DataPairDataset(",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " test is declared to have type `FlairDataset` but is used as type `typing.Optional[DataPairDataset]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 269,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "flairNLP/flair",
    "source_filename": "flair/datasets/text_text.py",
    "target_filename": "flair/datasets/text_text.py",
    "source_changeid": "700f11ccd1f1c429daeab8512f42dad30a01401f^",
    "target_changeid": "700f11ccd1f1c429daeab8512f42dad30a01401f",
    "predictions": [
      "\n test: DataPairDataset = DataPairDataset( \n test_file, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n test: DataPairDataset = DataPairDataset( \n test_file, \n",
      "1": "\n test: DataPairDataset( \n test_file, \n",
      "2": "\n test = DataPairDataset( \n test_file, \n",
      "3": "\n test: Optional[FlairDataset] = DataPairDataset( \n test_file, \n",
      "4": "\n test_file = DataPairDataset( \n test_file, \n"
    }
  },
  {
    "source_code": "\n    def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None:\n        <IND>",
    "target_code": "\n    def __init__(self, subscribe: Optional[Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None:\n        <IND>",
    "warning_line": "    def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " subscribe is declared to have type `typing.Callable[[typing.Observer[typing.Any], Optional[typing.Scheduler]], typing.Disposable]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 18,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ReactiveX/RxPY",
    "source_filename": "rx/core/observable/observable.py",
    "target_filename": "rx/core/observable/observable.py",
    "source_changeid": "cd3d5a5b833a0df3ecd91116c0243ebaa762578c^",
    "target_changeid": "cd3d5a5b833a0df3ecd91116c0243ebaa762578c",
    "predictions": [
      "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None: \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable] = None) -> None: \n <IND>",
      "1": "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler], typing.Disposable]] = None) -> None: \n <IND>",
      "2": "\n def __init__(self, subscribe: Optional[Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None: \n <IND>",
      "3": "\n def __init__(self, subscribe: Callable[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]) -> None: \n <IND>",
      "4": "\n def __init__(self, subscribe: Callable[[[typing.Observer, Optional[typing.Scheduler]], typing.Disposable]] = None) -> None: \n <IND>"
    }
  },
  {
    "source_code": "\n  def __init__(self, id: str = None, iv: str = None, cookie: str = None) -> None:\n    <IND>self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'='))\n",
    "target_code": "\n  def __init__(self, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None:\n    <IND>self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'='))\n",
    "warning_line": "  def __init__(self, id: str = None, iv: str = None, cookie: str = None) -> None:",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " cookie is declared to have type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 421,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "torproject/stem",
    "source_filename": "stem/descriptor/hidden_service.py",
    "target_filename": "stem/descriptor/hidden_service.py",
    "source_changeid": "076f89dfb4fd4a156ae32fde8c78c531385162e8^",
    "target_changeid": "076f89dfb4fd4a156ae32fde8c78c531385162e8",
    "predictions": [
      "\n def __init__(self, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None: \n <IND> self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'=')) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n def __init__(self, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None: \n <IND> self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'=')) \n",
      "1": "\n def __init__(self, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None: \n <DED> self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'=')) \n",
      "2": "\n def __init__(self, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None: \n \n self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'=')) \n",
      "3": "\n def __init__(self, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None: \n <IND> self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'=')) \n \n",
      "4": "\n def __init__( <DED>, id: Optional[str] = None, iv: Optional[str] = None, cookie: Optional[str] = None) -> None: \n <IND> self.id = stem.util.str_tools._to_unicode(id if id else base64.b64encode(os.urandom(8)).rstrip(b'=')) \n"
    }
  },
  {
    "source_code": "    <DED>def add_background_rectangle(\n        self, color: Colors = BLACK, opacity: float = 0.75, **kwargs\n    ):\n",
    "target_code": "    <DED>def add_background_rectangle(\n        self, color: Optional[Colors] = None, opacity: float = 0.75, **kwargs\n    ):\n",
    "warning_line": "        self, color: Colors = BLACK, opacity: float = 0.75, **kwargs",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " color is declared to have type `Colors` but is used as type `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1635,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ManimCommunity/manim",
    "source_filename": "manim/mobject/mobject.py",
    "target_filename": "manim/mobject/mobject.py",
    "source_changeid": "a4c1c4f15a752d7c40a09516c1950f1ea7386948^",
    "target_changeid": "a4c1c4f15a752d7c40a09516c1950f1ea7386948",
    "predictions": [
      "<DED> def add_background_rectangle( \n self, color: Colors[str] = BLACK, opacity: float = 0.75, **kwargs \n ): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def add_background_rectangle( \n self, color: Colors[str] = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "1": "<DED> def add_background_rectangle( \n self, color: Colors[0] = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "2": "<DED> def add_background_rectangle( \n self, color: Colors = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "3": "<DED> def add_background_rectangle( \n self, color: Colors.color = BLACK, opacity: float = 0.75, **kwargs \n ): \n",
      "4": "<DED> def add_background_rectangle( \n self, color: Colors = 'Black', opacity: float = 0.75, **kwargs \n ): \n"
    }
  },
  {
    "source_code": "    <DED>def add_tagfile(self, path, timestamp=None):\n        # type: (Text, datetime.datetime) -> None\n        <IND>\"\"\"Add tag files to our research object.\"\"\"\n",
    "target_code": "    <DED>def add_tagfile(self, path, timestamp=None):\n        # type: (Text, Optional[datetime.datetime]) -> None\n        <IND>\"\"\"Add tag files to our research object.\"\"\"\n",
    "warning_line": "    def add_tagfile(self, path, timestamp=None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " timestamp is declared to have type `datetime.datetime` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1064,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "common-workflow-language/cwltool",
    "source_filename": "cwltool/provenance.py",
    "target_filename": "cwltool/provenance.py",
    "source_changeid": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c^",
    "target_changeid": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c",
    "predictions": [
      "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, Datetime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, Datetime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "1": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, datetime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "2": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, DateTime.datetime) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "3": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text) -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n",
      "4": "<DED> def add_tagfile(self, path, timestamp=None): \n # type: (Text, 'datetime.datetime') -> None \n <IND> \"\"\"Add tag files to our research object.\"\"\" \n"
    }
  },
  {
    "source_code": "\n        signer_key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key))\n        op = RevokeSponsorship.revoke_signer_sponsorship(account_id, signer_key, source)\n        return self.append_operation(op)\n",
    "target_code": "\n        key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key))\n        op = RevokeSponsorship.revoke_signer_sponsorship(account_id, key, source)\n        return self.append_operation(op)\n",
    "warning_line": "        signer_key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key))",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " signer_key is declared to have type `Union[bytes, str]` but is used as type `SignerKey`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 942,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "StellarCN/py-stellar-base",
    "source_filename": "stellar_sdk/transaction_builder.py",
    "target_filename": "stellar_sdk/transaction_builder.py",
    "source_changeid": "fb330563ff2269540bfbfd662fa535080d1cc1f6^",
    "target_changeid": "fb330563ff2269540bfbfd662fa535080d1cc1f6",
    "predictions": [
      "\n key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key)) \n op = RevokeSponsorship.revoke_signer_sponsorship(account_id, key, source) \n return self.append_operation(op) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key)) \n op = RevokeSponsorship.revoke_signer_sponsorship(account_id, key, source) \n return self.append_operation(op) \n",
      "1": "\n op = RevokeSponsorship.revoke_signer_sponsorship(account_id, signer_key, source) \n return self.append_operation(op) \n",
      "2": "\n signer_key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key)) \n op = RevokeSponsorship.revoke_signer_sponsorship(account_id, signer_key, source) \n return self.append_operation(op) \n",
      "3": "\n signer_key__ = SignerKey.pre_auth_tx(hex_to_bytes(signer_key)) \n op = RevokeSponsorship.revoke_signer_sponsorship(account_id, signer_key__, source) \n return self.append_operation(op) \n",
      "4": "\n key = SignerKey.pre_auth_tx(hex_to_bytes(signer_key)) \n op = RevokeSponsorship.revoke_signer_sponsorship(account_id, key, source) \n return self.append_operation(op) \n \n"
    }
  },
  {
    "source_code": "    <DED>@classmethod\n    def init(cls, path: PathLike = None, mkdir: bool = True, odbt: Type[GitCmdObjectDB] = GitCmdObjectDB,\n             expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
    "target_code": "    <DED>@classmethod\n    def init(cls, path: Union[PathLike, None] = None, mkdir: bool = True, odbt: Type[GitCmdObjectDB] = GitCmdObjectDB,\n             expand_vars: bool = True, **kwargs: Any) -> 'Repo':\n",
    "warning_line": "    def init(cls, path: PathLike = None, mkdir: bool = True, odbt: Type[GitCmdObjectDB] = GitCmdObjectDB,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " path is declared to have type `Union[os.PathLike[typing.Any], str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 979,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "gitpython-developers/GitPython",
    "source_filename": "git/repo/base.py",
    "target_filename": "git/repo/base.py",
    "source_changeid": "2e2fe186d09272c3cb6c96467fff362deb90994f^",
    "target_changeid": "2e2fe186d09272c3cb6c96467fff362deb90994f",
    "predictions": [
      "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[str, str] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[str, str] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "1": "<DED> @classmethod \n def init(cls, path: Union[PathLike, None] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "2": "<DED> @classmethod \n def init(cls, path: Union[PathLike, None], None] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "3": "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n",
      "4": "<DED> @classmethod \n def init(cls, path: Union[str, str] = None, mkdir: bool = True, odbt: Union[GitCmdObjectDB] = GitCmdObjectDB, \n expand_vars: bool = True, **kwargs: Any) -> 'Repo': \n"
    }
  },
  {
    "source_code": "\n    <DED>def start(self, caller_frame: types.FrameType = None):\n        <IND>",
    "target_code": "\n    <DED>def start(self, caller_frame: types.FrameType | None = None):\n        <IND>",
    "warning_line": "    def start(self, caller_frame: types.FrameType = None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " caller_frame is declared to have type `types.FrameType` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 101,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "joerick/pyinstrument",
    "source_filename": "pyinstrument/profiler.py",
    "target_filename": "pyinstrument/profiler.py",
    "source_changeid": "12b65ffb01e65c5fbcfb08abee26da56c745c919^",
    "target_changeid": "12b65ffb01e65c5fbcfb08abee26da56c745c919",
    "predictions": [
      "\n <DED> def start(self, caller_frame: options.FrameType = None): \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def start(self, caller_frame: options.FrameType = None): \n <IND>",
      "1": "\n <DED> def start(self, caller_frame: typing.Optional[types.FrameType] = None): \n <IND>",
      "2": "\n <DED> def start(self, caller_frame: types.FrameType): \n <IND>",
      "3": "\n <DED> def start(self, caller_frame: calls.FrameType): \n <IND>",
      "4": "\n <DED> def start(self, caller_frame: types.FrameType = \"\"): \n <IND>"
    }
  },
  {
    "source_code": "                 orcid,                  # type: str\n                 run_uuid=None           # type: uuid.UUID\n                ):  # type: (...) -> None\n",
    "target_code": "                 orcid,                  # type: str\n                 run_uuid=None           # type: Optional[uuid.UUID]\n                ):  # type: (...) -> None\n",
    "warning_line": "                 run_uuid=None           # type: uuid.UUID",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " run_uuid is declared to have type `uuid.UUID` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 317,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "common-workflow-language/cwltool",
    "source_filename": "cwltool/provenance.py",
    "target_filename": "cwltool/provenance.py",
    "source_changeid": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c^",
    "target_changeid": "a9078408aafdee0e0f7c27954fb80ef1a0c39e9c",
    "predictions": [
      "orcid, # type: str \n run_uuid=None # type: Optional[uuid.UUID] \n ): # type: (...) -> None \n"
    ],
    "correct": true,
    "top_five": {
      "0": "orcid, # type: str \n run_uuid=None # type: Optional[uuid.UUID] \n ): # type: (...) -> None \n",
      "1": "orcid, # type: str \n run_uuid = None # type: Optional[uuid.UUID] \n ): # type: (...) -> None \n",
      "2": "orcid, # type: str \n run_uuid=None # type: Optional[Uuid.UUID] \n ): # type: (...) -> None \n",
      "3": "orcid, # type: str \n run_uuid=None # type: Optional[UUID] \n ): # type: (...) -> None \n",
      "4": "orcid, # type: str \n run_uuid: Optional[uuid.UUID] \n ): # type: (...) -> None \n"
    }
  },
  {
    "source_code": "      description: str = '',\n      param_type: TypeMeta = None,\n      default = None):\n",
    "target_code": "      description: str = '',\n      param_type = None,\n      default = None):\n",
    "warning_line": "      param_type: TypeMeta = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " param_type is declared to have type `TypeMeta` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 82,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "kubeflow/pipelines",
    "source_filename": "sdk/python/kfp/dsl/_metadata.py",
    "target_filename": "sdk/python/kfp/dsl/_metadata.py",
    "source_changeid": "c01315a89da6a0eee4a12d3bb1c095c28931aee3^",
    "target_changeid": "c01315a89da6a0eee4a12d3bb1c095c28931aee3",
    "predictions": [
      "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): \n",
      "1": "description: str = '', \n param_type: TypeMeta, \n default = None): \n",
      "2": "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): <IND>",
      "3": "description: str = '', \n param_type: Optional[typeMeta] = None, \n default = None): \n",
      "4": "description: str = '', \n param_type: Optional[TypeMeta] = None, \n default = None): <DED>"
    }
  },
  {
    "source_code": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID = None,\n    ) -> bool:\n",
    "target_code": "            participant2: typing.Address,\n            channel_identifier: typing.ChannelID,\n    ) -> bool:\n",
    "warning_line": "            channel_identifier: typing.ChannelID = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " channel_identifier is declared to have type `typing.ChannelID` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 471,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/network/proxies/token_network.py",
    "target_filename": "raiden/network/proxies/token_network.py",
    "source_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82^",
    "target_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82",
    "predictions": [
      "participant2: typing.Address, \n channel_identifier: typing.Optional[typing.ChannelID] = None, \n ) -> bool: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "participant2: typing.Address, \n channel_identifier: typing.Optional[typing.ChannelID] = None, \n ) -> bool: \n",
      "1": "participant2: typing.Address, \n channel_identifier: typing.ChannelID, \n ) -> bool: \n",
      "2": "participant2: typing.Address, \n channel_identifier: typing.ChannelID = None, \n ) -> bool: \n",
      "3": "participant2: typing.Address, \n channel_identifier: typing.Optional[typing.ChannelID] = None, \n ) -> bool: <IND>",
      "4": "participant2: typing.Address, \n channel_identifier: typing.ChannelID = \"\", \n ) -> bool: \n"
    }
  },
  {
    "source_code": "        self,\n        delivery_tag: int = None,\n        multiple: bool = False,\n",
    "target_code": "        self,\n        delivery_tag: int,\n        multiple: bool = False,\n",
    "warning_line": "        delivery_tag: int = None,",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " delivery_tag is declared to have type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 123,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "mosquito/aiormq",
    "source_filename": "aiormq/abc.py",
    "target_filename": "aiormq/abc.py",
    "source_changeid": "91909de532777c494df33a4843410b1981ca8794^",
    "target_changeid": "91909de532777c494df33a4843410b1981ca8794",
    "predictions": [
      "self, \n delivery_tag: Optional[int] = None, \n multiple: bool = False, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self, \n delivery_tag: Optional[int] = None, \n multiple: bool = False, \n",
      "1": "self, \n delivery_tag: int, \n multiple: bool = False, \n",
      "2": "self, \n delivery_tag: bool = False, \n multiple: bool = False, \n",
      "3": "self, \n delivery_tag: typing.Optional[int] = None, \n multiple: bool = False, \n",
      "4": "self, \n delivery_tag: Optional[Int] = None, \n multiple: bool = False, \n"
    }
  },
  {
    "source_code": "        self.lines.append(line)\n    <DED>def message(self, target: str, message: str, tags: dict=None):\n        <IND>self._add_line(utils.irc.protocol.message(target, message, tags))\n    <DED>def notice(self, target: str, message: str, tags: dict=None):\n        <IND>self._add_line(utils.irc.protocol.notice(target, message, tags))\n",
    "target_code": "        self.lines.append(line)\n    <DED>def message(self, target: str, message: str, tags: dict={}):\n        <IND>self._add_line(utils.irc.protocol.message(target, message, tags))\n    <DED>def notice(self, target: str, message: str, tags: dict={}):\n        <IND>self._add_line(utils.irc.protocol.notice(target, message, tags))\n",
    "warning_line": "    def notice(self, target: str, message: str, tags: dict=None):",
    "linter_report": {
      "rule_id": "Incompatible variable type [9]",
      "message": " tags is declared to have type `typing.Dict[typing.Any, typing.Any]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 334,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jesopo/bitbot",
    "source_filename": "src/utils/irc/__init__.py",
    "target_filename": "src/utils/irc/__init__.py",
    "source_changeid": "577fae7ceabfd2a43b798e02a67c518c23ed33bd^",
    "target_changeid": "577fae7ceabfd2a43b798e02a67c518c23ed33bd",
    "predictions": [
      "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=[str]) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=[str]) \n",
      "1": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.",
      "2": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Dict[str, str]= { } ): \n <IND> self._add_line(utils.irc.",
      "3": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=true) \n \n",
      "4": "self.lines.append(line) \n <DED> def message(self, target: str, message: str, tags: typing.Optional[typing.Dict[str, str]]= { } ): \n <IND> self._add_line(utils.irc.protocol.message(target, message, tags)) \n <DED> def notice(self, target: str, message: str, tags: typing.Optional[typing.Dict[str]=true) \n self._add_line(utils."
    }
  },
  {
    "source_code": "    if spec and spec.has_location and spec.origin:\n        <IND>return ast.get_docstring(ast.parse(Path(spec.origin).read_text()))\n    <DED>return \"\"\n",
    "target_code": "    if spec and spec.has_location and spec.origin:\n        <IND>return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) or \"\"\n    <DED>return \"\"\n",
    "warning_line": "        return ast.get_docstring(ast.parse(Path(spec.origin).read_text()))",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `str` but got `tp.Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 61,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "xonsh/xonsh",
    "source_filename": "xonsh/xontribs_meta.py",
    "target_filename": "xonsh/xontribs_meta.py",
    "source_changeid": "4dc08232e615a75a524fbf96f17402a7a5b353a5^",
    "target_changeid": "4dc08232e615a75a524fbf96f17402a7a5b353a5",
    "predictions": [
      "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <DED> return \"\" \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <DED> return \"\" \n",
      "1": "if spec and spec.has_location and spec.origin: \n <IND> return str(ast.get_docstring(ast.parse(Path(spec.origin).read_text()))) \n <DED> return \"\" \n",
      "2": "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <IND> return \"\" \n",
      "3": "if spec and spec.has_location and spec.origin: \n <IND> return ast.get_docstring(ast.parse(Path(spec.origin).read_text())) \n <DED> return '' \n",
      "4": "if spec and spec.has_location and spec.origin: \n <IND> return str(ast.get_docstring(ast.parse(Path(spec.origin).read_text()))) \n <IND> return \"\" \n"
    }
  },
  {
    "source_code": "<DED>def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount:\n    <IND>return sum(\n        unlock.lock.amount\n        for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    )\n\n",
    "target_code": "<DED>def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount:\n    <IND>return TokenAmount(sum(\n        unlock.lock.amount\n        for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values()\n    ))\n\n",
    "warning_line": "    return sum(",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `TokenAmount` but got `typing.Union[PaymentWithFeeAmount, int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 837,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/channel.py",
    "target_filename": "raiden/transfer/channel.py",
    "source_changeid": "347822a32090ea30c59fe4dc437e17795bd69c22^",
    "target_changeid": "347822a32090ea30c59fe4dc437e17795bd69c22",
    "predictions": [
      "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount: \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount: \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "1": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount: \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "2": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount(TokenAmount): \n <IND> return sum( \n unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "3": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> PaymentWithFeeAmount: \n <IND> return sum( <DED> unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n",
      "4": "<DED> def get_amount_unclaimed_onchain(end_state: NettingChannelEndState) -> TokenAmount: \n <IND> return sum( <DED> unlock.lock.amount \n for unlock in end_state.secrethashes_to_onchain_unlockedlocks.values() \n ) \n \n"
    }
  },
  {
    "source_code": "<DED>def ULT(a: BitVec, b: BitVec) -> Bool:\n    <IND>annotations = a.annotations + b.annotations\n    Bool(z3.ULT(a, b), annotations)\n\n",
    "target_code": "<DED>def ULT(a: BitVec, b: BitVec) -> Bool:\n    <IND>\"\"\" Create an unsigned less than expression \"\"\"\n    annotations = a.annotations + b.annotations\n    return Bool(z3.ULT(a, b), annotations)\n\n",
    "warning_line": "    Bool(z3.ULT(a, b), annotations)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Bool` but got implicit return value of `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 83,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ConsenSys/mythril",
    "source_filename": "mythril/laser/smt/bitvec.py",
    "target_filename": "mythril/laser/smt/bitvec.py",
    "source_changeid": "c3c10f5128d700c131a8de8e5b3f7af8a8fb559d^",
    "target_changeid": "c3c10f5128d700c131a8de8e5b3f7af8a8fb559d",
    "predictions": [
      "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> return annotations = a.annotations + b.annotations \n Bool(z3.ULT(a, b), annotations) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> return annotations = a.annotations + b.annotations \n Bool(z3.ULT(a, b), annotations) \n \n",
      "1": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> assert a.annotations + b.annotations is not None \n annotations = a.annotations + b.annotations \n return Bool(z3.ULT(a, b), annotations) \n \n",
      "2": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> annotations = a.annotations + b.annotations \n return Bool(z3.ULT(a, b), annotations) \n \n",
      "3": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> assert a.annotations + b.annotations is not None \n annotations = a.annotations + b.annotations \n Bool(z3.ULT(a, b), annotations) \n \n",
      "4": "<DED> def ULT(a: BitVec, b: BitVec) -> Bool: \n <IND> return annotations = a.annotations + b.annotations \n \n"
    }
  },
  {
    "source_code": "    <IND>if ctx.singleton_mode:\n        <IND>return _compile_set_in_singleton_mode(ir_set, ctx=ctx)\n\n",
    "target_code": "    <IND>if ctx.singleton_mode:\n        <IND>_compile_set_in_singleton_mode(ir_set, ctx=ctx)\n\n",
    "warning_line": "        return _compile_set_in_singleton_mode(ir_set, ctx=ctx)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `None` but got `pgast.Base`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 80,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "edgedb/edgedb",
    "source_filename": "edb/pgsql/compiler/expr.py",
    "target_filename": "edb/pgsql/compiler/expr.py",
    "source_changeid": "e7b95b8a233ef94da244ffd74c4abfbe6d7548bb^",
    "target_changeid": "e7b95b8a233ef94da244ffd74c4abfbe6d7548bb",
    "predictions": [
      "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n",
      "1": "<DED> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n",
      "2": "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=pgast.Base(ctx=ctx)) \n \n",
      "3": "\n if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=ctx) \n \n",
      "4": "<IND> if ctx.singleton_mode: \n <IND> return _compile_set_in_singleton_mode(ir_set, ctx=pgast.Base(ctx)) \n \n"
    }
  },
  {
    "source_code": "\n    return base64.urlsafe_b64encode(os.urandom(length))[:length]\n\n",
    "target_code": "\n    return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8')\n\n",
    "warning_line": "    return base64.urlsafe_b64encode(os.urandom(length))[:length]",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `str` but got `bytes`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 619,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "oppia/oppia",
    "source_filename": "utils.py",
    "target_filename": "utils.py",
    "source_changeid": "72937725a323b0cc1ccec150c81b041abeacb575^",
    "target_changeid": "72937725a323b0cc1ccec150c81b041abeacb575",
    "predictions": [
      "\n return base64.urlsafe_b64encode(os.urandom(length))[:length] \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length] \n \n",
      "1": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8') \n \n",
      "2": "\n os.urandom = base64.urlsafe_b64encode(os.urandom(length))[:length] \n return str(base64.urlsafe_b64encode(os.urandom(length))[:length]) \n \n",
      "3": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length].decode('utf-8').decode('utf-8') \n \n",
      "4": "\n return base64.urlsafe_b64encode(os.urandom(length))[:length].decode(\"utf-8\") \n \n"
    }
  },
  {
    "source_code": "    def exchange_exchange_bindings(self) -> bool:\n        <IND>return self.server_capabilities.get(\"exchange_exchange_bindings\")\n\n",
    "target_code": "    def exchange_exchange_bindings(self) -> bool:\n        <IND>return bool(self.server_capabilities.get(\"exchange_exchange_bindings\"))\n\n",
    "warning_line": "        return self.server_capabilities.get(\"exchange_exchange_bindings\")",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got `typing.Union[None, bool, int, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 521,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "mosquito/aiormq",
    "source_filename": "aiormq/connection.py",
    "target_filename": "aiormq/connection.py",
    "source_changeid": "91909de532777c494df33a4843410b1981ca8794^",
    "target_changeid": "91909de532777c494df33a4843410b1981ca8794",
    "predictions": [
      "def exchange_exchange_bindings(self) -> typing.Union[\"exchange_exchange_bindings\"]: \n <IND> return bool(self.server_capabilities.get(\"exchange_exchange_bindings\")) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "def exchange_exchange_bindings(self) -> typing.Union[\"exchange_exchange_bindings\"]: \n <IND> return bool(self.server_capabilities.get(\"exchange_exchange_bindings\")) \n \n",
      "1": "def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]: \n <IND> return bool(self.server_capabilities.get(\"exchange_exchange_bindings\")) \n \n",
      "2": "def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]: \n <IND> return self.server_capabilities.get(\"exchange_exchange_bindings\") \n \n",
      "3": "def exchange_exchange_bindings(self) -> bool: \n <IND> return typing.Union[\"exchange_exchange_bindings\"] \n \n",
      "4": "def exchange_exchange_bindings(self) -> typing.Union[bool, int, str]: \n <IND> return self.server_capabilities.get(\"exchange_exchange_bindings\"); \n \n"
    }
  },
  {
    "source_code": "        self._log_after_defer_job(job=job)\n        return job.id\n",
    "target_code": "        self._log_after_defer_job(job=job)\n        assert job.id  # for mypy\n        return job.id\n",
    "warning_line": "        return job.id",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `int` but got `Optional[int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 156,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "procrastinate-org/procrastinate",
    "source_filename": "procrastinate/jobs.py",
    "target_filename": "procrastinate/jobs.py",
    "source_changeid": "2f87ff44527a91cc7d58f608a42f7be767815727^",
    "target_changeid": "2f87ff44527a91cc7d58f608a42f7be767815727",
    "predictions": [
      "self._log_after_defer_job(job=job) \n assert isinstance(job.id) \n return assert isinstance(job.id) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self._log_after_defer_job(job=job) \n assert isinstance(job.id) \n return assert isinstance(job.id) \n",
      "1": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.id \n",
      "2": "self._log_after_defer_job(job=job) \n return (Optional[job.id]) \n",
      "3": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return job.id \n",
      "4": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.isinstance(job.id) \n"
    }
  },
  {
    "source_code": "    <IND>htype_overwrite.update({\"compression\": compression})\n    return _set_compression\n\n",
    "target_code": "    <IND>htype_overwrite.update({\"compression\": compression})\n    return htype_overwrite\n\n",
    "warning_line": "    return _set_compression",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `typing.Dict[typing.Any, typing.Any]` but got `typing.Callable(_set_compression)[[Named(htype_overwrite, typing.Dict[typing.Any, typing.Any]), Named(compression, str)], typing.Dict[typing.Any, typing.Any]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 145,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "activeloopai/Hub",
    "source_filename": "hub/core/meta/tensor_meta.py",
    "target_filename": "hub/core/meta/tensor_meta.py",
    "source_changeid": "25751187f23963c3bba63e0b8419e61af4757203^",
    "target_changeid": "25751187f23963c3bba63e0b8419e61af4757203",
    "predictions": [
      "<IND> htype_overwrite.update( { \"compression\": compression } ) \n return _set_compression \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n return _set_compression \n \n",
      "1": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n return [] \n \n",
      "2": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n assert isinstance(str, htype_overwrite) \n return _set_compression \n \n",
      "3": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n assert isinstance(str, str) \n return _set_compression \n \n",
      "4": "<IND> htype_overwrite.update( { \"compression\": compression } ) \n assert isinstance(htype_overwrite, dict) \n return _set_compression \n \n"
    }
  },
  {
    "source_code": "        self._check_values_type()\n        for dataset in self.values():\n            <IND>dataset.cleanup_cache_files()\n\n",
    "target_code": "        self._check_values_type()\n        return {k: dataset.cleanup_cache_files() for k, dataset in self.items()}\n\n",
    "warning_line": "            dataset.cleanup_cache_files()",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Dict[str, int]` but got implicit return value of `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 111,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "huggingface/datasets",
    "source_filename": "src/datasets/dataset_dict.py",
    "target_filename": "src/datasets/dataset_dict.py",
    "source_changeid": "49e517a3d21392291d771872204594f43cd09532^",
    "target_changeid": "49e517a3d21392291d771872204594f43cd09532",
    "predictions": [
      "self._check_values_type() \n for dataset in self.values(): \n <IND> dataset.cleanup_cache_files() \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self._check_values_type() \n for dataset in self.values(): \n <IND> dataset.cleanup_cache_files() \n \n",
      "1": "self._check_values_type() \n for dataset in self.values(): \n <IND> return dataset.cleanup_cache_files() \n \n",
      "2": "self._check_values_type() \n for dataset in self.values(): \n <IND> assert dataset.cleanup_cache_files() \n \n",
      "3": "self._check_values_type() \n for dataset in self.values(): \n <IND> assert dataset is not None \n dataset.cleanup_cache_files() \n \n",
      "4": "self._check_values_type() \n for dataset in self.values(): \n <IND> dataset.cleanup_cache_files() \n <DED>"
    }
  },
  {
    "source_code": "        <IND>\"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self._mem_slot\n\n",
    "target_code": "        <IND>\"\"\"The classical memory slot which will store the classified readout result.\"\"\"\n        return self.operands[2]\n\n",
    "warning_line": "        return self._mem_slot",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `MemorySlot` but got `Optional[MemorySlot]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 112,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Qiskit/qiskit-terra",
    "source_filename": "qiskit/pulse/instructions/acquire.py",
    "target_filename": "qiskit/pulse/instructions/acquire.py",
    "source_changeid": "1687c30fd63344f1ea50cb7b1774e26928678b23^",
    "target_changeid": "1687c30fd63344f1ea50cb7b1774e26928678b23",
    "predictions": [
      "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self._mem_slot \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self._mem_slot \n \n",
      "1": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n assert self.mem_slot is not None \n return self._mem_slot \n \n",
      "2": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n assert self._mem_slot is not None \n return self._mem_slot \n \n",
      "3": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self.mem_slot \n \n",
      "4": "<IND> \"\"\"The classical memory slot which will store the classified readout result.\"\"\" \n return self._mem_slot \n <DED>"
    }
  },
  {
    "source_code": "            <IND>modes.append(\"\")\n        <DED>return tuple(modes[:4])\n\n",
    "target_code": "            <IND>modes.append(\"\")\n        <DED>rA, rB, rC, rD = modes[:4]\n        return (rA, rB, rC, rD)\n\n",
    "warning_line": "        return tuple(modes[:4])",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Tuple[str, str, str, str]` but got `typing.Tuple[typing.Any, ...]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 321,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "lykoss/lykos",
    "source_filename": "src/context.py",
    "target_filename": "src/context.py",
    "source_changeid": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37^",
    "target_changeid": "f8560e10e9e8cc4b4a3b8e750865c4079f7c9b37",
    "predictions": [
      "<IND> modes.append(\"\") \n <DED> return tuple(modes[:4]) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> modes.append(\"\") \n <DED> return tuple(modes[:4]) \n \n",
      "1": "<IND> modes.append(\"\") \n <DED> if not tuple: \n <IND> return tuple(modes[:4]) \n \n",
      "2": "<IND> modes.append(\"\") \n <DED> if isinstance(modes[:4]): \n <IND> return tuple(modes[:4]) \n \n",
      "3": "<IND> modes.append(\"\") \n <DED> str = tuple(modes[:4]) \n \n",
      "4": "<IND> modes.append(\"\") \n <DED> return tuple([modes[:4]],...]) \n \n"
    }
  },
  {
    "source_code": "            return self.error.message.strip() + \":\\n\\n\" + user_code_error.to_string()\n        <DED>elif self.error_source == ErrorSource.FRAMEWORK_ERROR:\n            <IND>return self.error.to_string()\n        <DED>else:\n            <IND>check.failed(f\"Unexpected error setting: {self.error_source}\")\n\n",
    "target_code": "            return self.error.message.strip() + \":\\n\\n\" + user_code_error.to_string()\n        <DED>else:\n            <IND>return self.error.to_string()\n\n",
    "warning_line": "            check.failed(f\"Unexpected error setting: {self.error_source}\")",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `str` but got implicit return value of `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 107,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dagster-io/dagster",
    "source_filename": "python_modules/dagster/dagster/core/execution/plan/objects.py",
    "target_filename": "python_modules/dagster/dagster/core/execution/plan/objects.py",
    "source_changeid": "b57b91ea7666da41a3dbc610116aed500c647d84^",
    "target_changeid": "b57b91ea7666da41a3dbc610116aed500c647d84",
    "predictions": [
      "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return false \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return false \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "1": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return self.error.to_string() \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "2": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return False \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "3": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return str(self.error.to_string()) \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n",
      "4": "return self.error.message.strip() + \": \\ n \\ n\" + user_code_error.to_string() \n <DED> elif self.error_source == ErrorSource.FRAMEWORK_ERROR: \n <IND> return None \n <DED> else: \n <IND> check.failed(f\"Unexpected error setting: { self.error_source } \") \n \n"
    }
  },
  {
    "source_code": "            <IND>return True\n\n",
    "target_code": "            <IND>return True\n        <DED>return False\n\n",
    "warning_line": "            return True",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got implicit return value of `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 126,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Uranium",
    "source_filename": "plugins/Tools/CameraTool/CameraTool.py",
    "target_filename": "plugins/Tools/CameraTool/CameraTool.py",
    "source_changeid": "bc4fc9c74079be2cf20cb9e4564aa0a75a30cfce^",
    "target_changeid": "bc4fc9c74079be2cf20cb9e4564aa0a75a30cfce",
    "predictions": [
      "<IND> return True \n <DED> return False \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> return True \n <DED> return False \n \n",
      "1": "<IND> return True \n \n <IND> return False \n \n",
      "2": "<IND> return True \n \n <DED> return False \n \n",
      "3": "<IND> return True \n \n <DED> raise ValueError(f\"Unknown type\") \n \n",
      "4": "<IND> return True \n <DED> raise ValueError(f\"Unknown type\") \n \n"
    }
  },
  {
    "source_code": "\n    <DED>def get_underlay_def(self) -> 'UnderlayDefinition':\n        <IND>return self._underlay_def\n",
    "target_code": "\n    <DED>def get_underlay_def(self) -> Optional[\"UnderlayDefinition\"]:\n        <IND>return self._underlay_def\n",
    "warning_line": "        return self._underlay_def",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `UnderlayDefinition` but got `Optional[UnderlayDefinition]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 147,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "mozman/ezdxf",
    "source_filename": "src/ezdxf/entities/underlay.py",
    "target_filename": "src/ezdxf/entities/underlay.py",
    "source_changeid": "73c745cf3749bb4ab38f8a428d9c14c1b9bcc668^",
    "target_changeid": "73c745cf3749bb4ab38f8a428d9c14c1b9bcc668",
    "predictions": [
      "\n <DED> def get_underlay_def(self) -> Optional['UnderlayDefinition']: \n <IND> return self._underlay_def \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def get_underlay_def(self) -> Optional['UnderlayDefinition']: \n <IND> return self._underlay_def \n",
      "1": "\n <DED> def get_underlay_def(self) -> Optional[UnderlayDefinition]: \n <IND> return self._underlay_def \n",
      "2": "\n <DED> def get_underlay_def(self) -> Optional[\"UnderlayDefinition\"]: \n <IND> return self._underlay_def \n",
      "3": "\n <IND> def get_underlay_def(self) -> Optional['UnderlayDefinition']: \n <IND> return self._underlay_def \n",
      "4": "\n <DED> def get_underlay_def(self) -> Optional[[UnderlayDefinition]]: \n <IND> return self._underlay_def \n"
    }
  },
  {
    "source_code": "            <IND>return None\n        <DED>return workers[0]\n\n",
    "target_code": "            <IND>return None\n        <DED>return cast(\"MTurkWorker\", workers[0])\n\n",
    "warning_line": "        return workers[0]",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Optional[MTurkWorker]` but got `Worker`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 71,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "facebookresearch/Mephisto",
    "source_filename": "mephisto/abstractions/providers/mturk/mturk_worker.py",
    "target_filename": "mephisto/abstractions/providers/mturk/mturk_worker.py",
    "source_changeid": "4937db1184a2a8d9b30f0d20bef0bc0f098a5238^",
    "target_changeid": "4937db1184a2a8d9b30f0d20bef0bc0f098a5238",
    "predictions": [
      "<IND> return None \n <DED> return MTurkWorker(worker) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> return None \n <DED> return MTurkWorker(worker) \n \n",
      "1": "<IND> return None \n <DED> return Optional[MTurkWorker] \n \n",
      "2": "<IND> return None \n <DED> return MTurkWorker(workers[0]) \n \n",
      "3": "<IND> return None \n <DED> return Workers[0] \n \n",
      "4": "<IND> return None \n <DED> return MTurkWorker(workers) \n \n"
    }
  },
  {
    "source_code": "\n    return min(overflow_limit, distributable)\n\n",
    "target_code": "\n    return TokenAmount(min(overflow_limit, distributable))\n\n",
    "warning_line": "    return min(overflow_limit, distributable)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `TokenAmount` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 961,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/channel.py",
    "target_filename": "raiden/transfer/channel.py",
    "source_changeid": "347822a32090ea30c59fe4dc437e17795bd69c22^",
    "target_changeid": "347822a32090ea30c59fe4dc437e17795bd69c22",
    "predictions": [
      "\n return min(tokenAmount, overflow_limit) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n return min(tokenAmount, overflow_limit) \n \n",
      "1": "\n return min(int(overflow_limit), distributable) \n \n",
      "2": "\n return min(overflow_limit, distributable) \n \n",
      "3": "\n return min(token_amount, overflow_limit) \n \n",
      "4": "\n return min(overflow_limit, tokenAmount) \n \n"
    }
  },
  {
    "source_code": "            <IND>return float(Price) + float(ATR) * int(self.ce_multiplier)\n\n",
    "target_code": "            <IND>return float(Price) + float(ATR) * int(self.ce_multiplier)\n        <DED>raise ValueError(\"trade direction can't be NONE\")\n\n",
    "warning_line": "            return float(Price) + float(ATR) * int(self.ce_multiplier)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `float` but got implicit return value of `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 373,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ilcardella/TradingBot",
    "source_filename": "tradingbot/Strategies/WeightedAvgPeak.py",
    "target_filename": "tradingbot/Strategies/WeightedAvgPeak.py",
    "source_changeid": "d835f8b3955783b4b4ad5d4fbea44459b7fdd7fd^",
    "target_changeid": "d835f8b3955783b4b4ad5d4fbea44459b7fdd7fd",
    "predictions": [
      "<IND> return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n",
      "1": "<DED> return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n",
      "2": "\n return float(Price) + float(ATR) * int(self.ce_multiplier) \n \n",
      "3": "<IND> return Price + float(ATR) * int(self.ce_multiplier) \n \n",
      "4": "<IND> return price + float(ATR) * int(self.ce_multiplier) \n \n"
    }
  },
  {
    "source_code": "        self._log_after_defer_job(job=job)\n        return job.id\n",
    "target_code": "        self._log_after_defer_job(job=job)\n        assert job.id  # for mypy\n        return job.id\n",
    "warning_line": "        return job.id",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `int` but got `Optional[int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 164,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "procrastinate-org/procrastinate",
    "source_filename": "procrastinate/jobs.py",
    "target_filename": "procrastinate/jobs.py",
    "source_changeid": "2f87ff44527a91cc7d58f608a42f7be767815727^",
    "target_changeid": "2f87ff44527a91cc7d58f608a42f7be767815727",
    "predictions": [
      "self._log_after_defer_job(job=job) \n assert isinstance(job.id) \n return assert isinstance(job.id) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self._log_after_defer_job(job=job) \n assert isinstance(job.id) \n return assert isinstance(job.id) \n",
      "1": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.id \n",
      "2": "self._log_after_defer_job(job=job) \n return (Optional[job.id]) \n",
      "3": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return job.id \n",
      "4": "self._log_after_defer_job(job=job) \n assert job.id is not None \n return assert job.isinstance(job.id) \n"
    }
  },
  {
    "source_code": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> ValidKernelType:\n        <IND>return self._method_offset(context, vlayer, b\"\\\\SystemRoot\\\\system32\\\\nt\",\n",
    "target_code": "                             vlayer: layers.intel.Intel,\n                             progress_callback: constants.ProgressCallback = None) -> Optional[ValidKernelType]:\n        <IND>return self._method_offset(context, vlayer, b\"\\\\SystemRoot\\\\system32\\\\nt\",\n",
    "warning_line": "        return self._method_offset(context, vlayer, b\"\\\\SystemRoot\\\\system32\\\\nt\",",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Tuple[str, int, Dict[str, Union[None, bytes, int, str]]]` but got `Optional[Tuple[str, int, Dict[str, Union[None, bytes, int, str]]]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 243,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "volatilityfoundation/volatility3",
    "source_filename": "volatility3/framework/automagic/pdbscan.py",
    "target_filename": "volatility3/framework/automagic/pdbscan.py",
    "source_changeid": "0343c8f81e3aaf0cff5979dcbb686ad91a14bbb3^",
    "target_changeid": "0343c8f81e3aaf0cff5979dcbb686ad91a14bbb3",
    "predictions": [
      "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 } \\ nt\", \n"
    ],
    "correct": false,
    "top_five": {
      "0": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 } \\ nt\", \n",
      "1": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ \\ system32 \\ \\ nt\", \n",
      "2": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot } \\ system32 } \\ nt\", \n",
      "3": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot } \\ system32 \\ \\ nt\", \n",
      "4": "vlayer: layers.intel.Intel, \n progress_callback: constants.ProgressCallback = None) -> ValidKernelType: \n <IND> return self._method_offset(context, vlayer, b\" \\ \\ SystemRoot \\ } system32 } \\ nt\", \n"
    }
  },
  {
    "source_code": "\n    <IND>def __iter__(self) -> \"SuperclassesIterator\":\n        <IND>return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
    "target_code": "\n    <IND>def __iter__(self) -> \"SuperpropertiesIterator\":\n        <IND>return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)\n",
    "warning_line": "        return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `SuperclassesIterator` but got `SuperpropertiesIterator`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 197,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "althonos/pronto",
    "source_filename": "pronto/logic/lineage.py",
    "target_filename": "pronto/logic/lineage.py",
    "source_changeid": "7cafbe2e6864d747faa1b9e2cea87064ab3ea327^",
    "target_changeid": "7cafbe2e6864d747faa1b9e2cea87064ab3ea327",
    "predictions": [
      "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "1": "\n <IND> def __iter__(self) -> SuperclassesIterator: \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "2": "\n <IND> def __iter__(self) -> 'SuperclassesIterator': \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "3": "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> assert self.entity is not None \n return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n",
      "4": "\n <IND> def __iter__(self) -> \"SuperclassesIterator\": \n <IND> return SuperpropertiesIterator(self.entity, distance=self.distance, with_self=self.with_self) \n \n"
    }
  },
  {
    "source_code": "        <DED>for exe in ['python3', 'python']:\n            <IND>if shutil.which(exe) is not None:\n                <IND>return shutil.which(exe)\n\n",
    "target_code": "        <DED>for exe in ['python3', 'python']:\n            <IND>which = shutil.which(exe)\n            if which is not None:\n                <IND>return which\n\n",
    "warning_line": "                return shutil.which(exe)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `str` but got `typing.Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 130,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Shougo/denite.nvim",
    "source_filename": "rplugin/python3/denite/source/file/rec.py",
    "target_filename": "rplugin/python3/denite/source/file/rec.py",
    "source_changeid": "2aa4f02d3e4bec82d879c237a87e88d78f243c1d^",
    "target_changeid": "2aa4f02d3e4bec82d879c237a87e88d78f243c1d",
    "predictions": [
      "<DED> for exe in ['python3', 'python']: \n <IND> if str == None: \n <IND> return shutil.which(exe) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> for exe in ['python3', 'python']: \n <IND> if str == None: \n <IND> return shutil.which(exe) \n \n",
      "1": "<DED> for exe in ['python3', 'python']: \n <IND> return shutil.which(exe) \n \n",
      "2": "<DED> for exe in ['python3', 'python']: \n <IND> if shutil.which(exe) is not None and shutil.which(exe) is not None: \n <IND> return shutil.which(exe) \n \n",
      "3": "<DED> for exe in ['python3', 'python']: \n <IND> if exe is None and shutil.which(exe) is not None: \n <IND> return exe \n \n",
      "4": "<DED> for exe in ['python3', 'python']: \n <IND> if shutil.which(exe) is not None and shutil.which(exe) is None: \n <IND> return shutil.which(exe) \n \n"
    }
  },
  {
    "source_code": "\n        return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None\n\n",
    "target_code": "\n        return self._projects_pagination_mgr is not None and self._projects_pagination_mgr.links is not None and self._projects_pagination_mgr.links.next_page is not None\n\n",
    "warning_line": "        return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got `Optional[bool]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 122,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Cura",
    "source_filename": "plugins/DigitalLibrary/src/DigitalFactoryApiClient.py",
    "target_filename": "plugins/DigitalLibrary/src/DigitalFactoryApiClient.py",
    "source_changeid": "daa0826190ce7a606e54b944afeed8693f4997d9^",
    "target_changeid": "daa0826190ce7a606e54b944afeed8693f4997d9",
    "predictions": [
      "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is not None \n \n",
      "1": "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and self._projects_pagination_mgr.links.next_page is None \n \n",
      "2": "\n return bool(self._projects_pagination_mgr and self._projects_pagination_mgr.links) and bool(self._projects_pagination_mgr.links.next_page) is not None \n \n",
      "3": "\n return self._projects_pagination_mgr and self._projects_pagination_mgr.links and bool(self._projects_pagination_mgr.links.next_page) \n \n",
      "4": "\n return bool(self._projects_pagination_mgr and self._projects_pagination_mgr.links) and bool(self._projects_pagination_mgr.links.next_page is not None) \n \n"
    }
  },
  {
    "source_code": "\n    pat = re.compile(f\"{dollars}|{braces}|{parens}\")\n    return pat.match(text)\n\n",
    "target_code": "\n    pat = re.compile(f\"{dollars}|{braces}|{parens}\", flags=re.S)\n    return pat.search(text) is not None\n\n",
    "warning_line": "    return pat.match(text)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got `typing.Optional[typing.Match[str]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 367,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "bokeh/bokeh",
    "source_filename": "bokeh/embed/util.py",
    "target_filename": "bokeh/embed/util.py",
    "source_changeid": "e739f4af7f6af260bea9317fed564ecf87b36172^",
    "target_changeid": "e739f4af7f6af260bea9317fed564ecf87b36172",
    "predictions": [
      "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text) \n \n",
      "1": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return bool(pat.match(text)) \n \n",
      "2": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(Text) \n \n",
      "3": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text) \n <DED>",
      "4": "\n pat = re.compile(f\" { dollars } | { braces } | { parens } \") \n return pat.match(text, '') \n \n"
    }
  },
  {
    "source_code": "    <IND>if end_state.balance_proof:\n        <IND>return end_state.balance_proof.nonce + 1\n\n    # 0 must not be used since in the netting contract it represents null.\n    <DED>return 1\n\n",
    "target_code": "    <IND>if end_state.balance_proof:\n        <IND>return Nonce(end_state.balance_proof.nonce + 1)\n\n    # 0 must not be used since in the netting contract it represents null.\n    <DED>return Nonce(1)\n\n",
    "warning_line": "        return end_state.balance_proof.nonce + 1",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Nonce` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1029,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/channel.py",
    "target_filename": "raiden/transfer/channel.py",
    "source_changeid": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242^",
    "target_changeid": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242",
    "predictions": [
      "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "1": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "2": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n \n",
      "3": "<IND> if end_state.balance_proof: \n <IND> return Nonce(end_state.balance_proof.nonce) + 1 \n \n # 0 must not be used since in the netting contract it represents null. \n <DED> return 1 \n \n",
      "4": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <IND> return 1 \n \n"
    }
  },
  {
    "source_code": "    <DED><DED>def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        <IND>return self._intents is None or self._intents & intents\n\n",
    "target_code": "    <DED><DED>def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool:\n        <IND>return self._intents is None or (self._intents & intents) == intents\n\n",
    "warning_line": "        return self._intents is None or self._intents & intents",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got `typing.Union[bool, intents_.Intent]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 408,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "hikari-py/hikari",
    "source_filename": "hikari/impl/stateful_cache.py",
    "target_filename": "hikari/impl/stateful_cache.py",
    "source_changeid": "0fb0289a935c56f29b6b0bd970dfbab0a59f5362^",
    "target_changeid": "0fb0289a935c56f29b6b0bd970dfbab0a59f5362",
    "predictions": [
      "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return bool(self._intents is None or self._intents & intents) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return bool(self._intents is None or self._intents & intents) \n \n",
      "1": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return self._intents is None or self._intents & intents \n \n",
      "2": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> typing.Union[bool, intents_.Intent]: \n <IND> return self._intents is None or self._intents & intents \n \n",
      "3": "<DED> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> typing.Union[bool, intents_.Intent]: \n <IND> return bool(self._intents is None or self._intents & intents) \n \n",
      "4": "<IND> <DED> def _is_intent_enabled(self, intents: intents_.Intent, /) -> bool: \n <IND> return self._intents is None or self._intents & intents \n \n"
    }
  },
  {
    "source_code": "            <IND>raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        <DED>self.callback(self.Event.QUIT)\n\n",
    "target_code": "            <IND>raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\")\n        <DED>self.callback(self.Event.QUIT, None)\n        return False\n\n",
    "warning_line": "        self.callback(self.Event.QUIT)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got implicit return value of `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 70,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "P403n1x87/austin-tui",
    "source_filename": "austin_tui/view/austin.py",
    "target_filename": "austin_tui/view/austin.py",
    "source_changeid": "5dece896966240dead23475718028c7f0545ef8c^",
    "target_changeid": "5dece896966240dead23475718028c7f0545ef8c",
    "predictions": [
      "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUIT) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUIT) \n \n",
      "1": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> self.callback(self.Event.QUIT) \n \n",
      "2": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(quit) \n \n",
      "3": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUEST) \n \n",
      "4": "<IND> raise RuntimeError(\"AustinTUI requires a callback to handle quit events.\") \n <DED> assert self.Event.QUIT is not None \n self.callback(self.Event.QUT) \n \n"
    }
  },
  {
    "source_code": "    <IND>@classmethod\n    def all(cls) -> List[\"PostgresPartitioningMethod\"]:\n        <IND>return [choice for choice in cls]\n",
    "target_code": "    <IND>@classmethod\n    def all(cls) -> List[\"StrEnum\"]:\n        <IND>return [choice for choice in cls]\n",
    "warning_line": "        return [choice for choice in cls]",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `List[PostgresPartitioningMethod]` but got `List[StrEnum]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 11,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "SectorLabs/django-postgres-extra",
    "source_filename": "psqlextra/types.py",
    "target_filename": "psqlextra/types.py",
    "source_changeid": "9a1ed82f7c65b5056795c21001fa69faf17d9813^",
    "target_changeid": "9a1ed82f7c65b5056795c21001fa69faf17d9813",
    "predictions": [
      "<IND> @classmethod \n def all(cls) -> List[StrEnum]: \n <IND> return [choice for choice in cls] \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> @classmethod \n def all(cls) -> List[StrEnum]: \n <IND> return [choice for choice in cls] \n",
      "1": "<IND> @classmethod \n def all(cls) -> str: \n <IND> return [choice for choice in cls] \n",
      "2": "<IND> @classmethod \n def all(cls) -> List[\"PostgresPartitioningMethod\"]: \n <IND> return [choice for choice in cls] \n",
      "3": "<IND> @classmethod \n def all(cls) -> List[StrEnum[\"PostgresPartitioningMethod\"]: \n <IND> return [choice for choice in cls] \n",
      "4": "<IND> @classmethod \n def all(cls) -> str: \n <IND> return str([choice for choice in cls]) \n"
    }
  },
  {
    "source_code": "    <IND>if end_state.balance_proof:\n        <IND>return end_state.balance_proof.nonce + 1\n\n    # 0 must not be used since in the netting contract it represents null.\n    <DED>return 1\n\n",
    "target_code": "    <IND>if end_state.balance_proof:\n        <IND>return Nonce(end_state.balance_proof.nonce + 1)\n\n    # 0 must not be used since in the netting contract it represents null.\n    <DED>return Nonce(1)\n\n",
    "warning_line": "    return 1",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `Nonce` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1032,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/channel.py",
    "target_filename": "raiden/transfer/channel.py",
    "source_changeid": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242^",
    "target_changeid": "89c59ab76a7ab2b2e4bfa91ebb1971c44fee4242",
    "predictions": [
      "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "1": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n # 0 must not be used since in the netting contract it represents null \n <DED> return 1 \n \n",
      "2": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null. \n <DED> return 1 \n \n",
      "3": "<IND> if end_state.balance_proof: \n <IND> return nonce(end_state.balance_proof.nonce) + 1 \n # 0 must not be used since in the netting contract it represents null. \n <DED> return 1 \n \n",
      "4": "<IND> if end_state.balance_proof: \n <IND> return end_state.balance_proof.nonce(int) \n \n # 0 must not be used since in the netting contract it represents null \n \n"
    }
  },
  {
    "source_code": "    <DED>@property\n    def guild(self) -> _guilds.Guild:\n        <IND>return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
    "target_code": "    <DED>@property\n    def guild(self) -> typing.Union[_guilds.Guild, bases.UnknownObject[_guilds.Guild]]:\n        <IND>return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)\n",
    "warning_line": "        return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `_guilds.Guild` but got `typing.Union[bases.UnknownObject[_guilds.Guild], _guilds.Guild]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 133,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "hikari-py/hikari",
    "source_filename": "hikari/orm/models/roles.py",
    "target_filename": "hikari/orm/models/roles.py",
    "source_changeid": "cf143052e1228280ed895c06da9177611d8ea088^",
    "target_changeid": "cf143052e1228280ed895c06da9177611d8ea088",
    "predictions": [
      "<DED> @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "1": "<DED> @property \n def guild(self) -> typing.Union[_guilds.Guild], _guilds.Guild]: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "2": "<DED> @property \n def guild(self) -> typing.Union[_guilds.Guild, _guilds.Guild]: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "3": "<IND> @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n",
      "4": "\n @property \n def guild(self) -> _guilds.Guild: \n <IND> return self._fabric.state_registry.get_mandatory_guild_by_id(self.guild_id) \n"
    }
  },
  {
    "source_code": "        <IND>return capability in self.agreed_capabilities\n    <DED>def available_capability(self, capability: utils.irc.Capability) -> bool:\n        <IND>return capability.available(self.agreed_capabilities)\n",
    "target_code": "        <IND>return capability in self.agreed_capabilities\n    <DED>def available_capability(self, capability: utils.irc.Capability) -> str:\n        <IND>return capability.available(self.agreed_capabilities)\n",
    "warning_line": "        return capability.available(self.agreed_capabilities)",
    "linter_report": {
      "rule_id": "Incompatible return type [7]",
      "message": " Expected `bool` but got `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 292,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jesopo/bitbot",
    "source_filename": "src/IRCServer.py",
    "target_filename": "src/IRCServer.py",
    "source_changeid": "c3454f2bfe62d3ecd1a5f4c771ae60fa3addfafd^",
    "target_changeid": "c3454f2bfe62d3ecd1a5f4c771ae60fa3addfafd",
    "predictions": [
      "<IND> return capability in self.agreed_capabilities \n <DED> def available_capability(self, capability: utils.irc.Capability) -> str: \n <IND> return capability.available(self.agreed_capabilities) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> return capability in self.agreed_capabilities \n <DED> def available_capability(self, capability: utils.irc.Capability) -> str: \n <IND> return capability.available(self.agreed_capabilities) \n",
      "1": "<IND> return capability in self.agreed_capabilities \n <IND> def available_capability(self, capability: utils.irc.Capability) -> str: \n <IND> return capability.available(self.agreed_capabilities) \n",
      "2": "<IND> return capability in self.agreed_capabilities \n <DED> def available_capability(self, capability: utils.irc.Capability): \n <IND> return capability.available(self.agreed_capabilities) \n",
      "3": "<IND> return capability in self.agreed_capabilities \n \n <DED> def available_capability(self, capability: utils.irc.Capability) -> str: \n <IND> return capability.available(self.agreed_capabilities) \n",
      "4": "<IND> return capability in self.agreed_capabilities \n <DED> def available_capability(self, capability: utils.irc.Capability) || bool: \n <IND> return capability.available(self.agreed_capabilities) \n"
    }
  },
  {
    "source_code": "        if treegrid is not None:\n            <IND>self.render_treegrid(self.generate_treegrid(plugin, **kwargs))\n\n",
    "target_code": "        if treegrid is not None:\n            <IND>self.render_treegrid(treegrid)\n\n",
    "warning_line": "            self.render_treegrid(self.generate_treegrid(plugin, **kwargs))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `interfaces.renderers.TreeGrid` for 1st positional only parameter to call `Volshell.render_treegrid` but got `Optional[interfaces.renderers.TreeGrid]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 302,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "volatilityfoundation/volatility3",
    "source_filename": "volatility/cli/volshell/generic.py",
    "target_filename": "volatility/cli/volshell/generic.py",
    "source_changeid": "8e420cbe62b70d8b9ee2a2cad26399e0df24018e^",
    "target_changeid": "8e420cbe62b70d8b9ee2a2cad26399e0df24018e",
    "predictions": [
      "if treegrid is not None: \n <IND> self.render_treegrid(self.generate_treegrid(plugin, **kwargs)) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if treegrid is not None: \n <IND> self.render_treegrid(self.generate_treegrid(plugin, **kwargs)) \n \n",
      "1": "if treegrid is not None: \n <IND> self.render_treegrid(plugin, **kwargs) \n \n",
      "2": "if treegrid is not None: \n <IND> self.render_treegrid(self.generate_treegrid(plugin, kwargs)) \n \n",
      "3": "if treegrid is not None: \n <IND> self.render_treegrid(interfaces.renderers.TreeGrid) \n \n",
      "4": "if treegrid is not None: \n <IND> self.render_treegrid(interfaces.renderers.TreeGrid(plugin, **kwargs)) \n \n"
    }
  },
  {
    "source_code": "            current_commitment_signature=None,\n            current_htlc_signatures=[],\n        )\n",
    "target_code": "            current_commitment_signature=None,\n            current_htlc_signatures=b'',\n        )\n",
    "warning_line": "            current_htlc_signatures=[],",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `bytes` for 16th parameter `current_htlc_signatures` to call `LocalConfig.__init__` but got `List[Variable[_T]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 477,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "spesmilo/electrum",
    "source_filename": "electrum/lnpeer.py",
    "target_filename": "electrum/lnpeer.py",
    "source_changeid": "7b18c91b74bbebfe56ba547080ab29775e42feb2^",
    "target_changeid": "7b18c91b74bbebfe56ba547080ab29775e42feb2",
    "predictions": [
      "current_commitment_signature=None, \n current_htlc_signatures=bytes, \n ) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "current_commitment_signature=None, \n current_htlc_signatures=bytes, \n ) \n",
      "1": "current_commitment_signature=None, \n htlc_signatures=bytes, \n ) \n",
      "2": "current_commitment_signature=None, \n current_htlc_signatures= Bytes, \n ) \n",
      "3": "current_commitment_signature=None, \n current_htlc_signatures= bytes, \n ) \n",
      "4": "current_commitment_signature=None, \n current_htlc_signatures= Bytes([], \n ) \n"
    }
  },
  {
    "source_code": "        file_suffix='-human-v1',\n        step_metadata_keys=set([_QPOS, _QVEL, _ADROIT_BODY_POS]),\n    ),\n",
    "target_code": "        file_suffix='-human-v1',\n        step_metadata_keys=frozenset([_QPOS, _QVEL, _ADROIT_BODY_POS]),\n    ),\n",
    "warning_line": "        step_metadata_keys=set([_QPOS, _QVEL, _ADROIT_BODY_POS]),",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `frozenset[str]` for 5th parameter `step_metadata_keys` to call `BuilderConfig.__init__` but got `typing.Set[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 257,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/datasets",
    "source_filename": "tensorflow_datasets/d4rl/dataset_builder.py",
    "target_filename": "tensorflow_datasets/d4rl/dataset_builder.py",
    "source_changeid": "4dbf2d78a44eccfcdf46fb8e15681cda8c0b144f^",
    "target_changeid": "4dbf2d78a44eccfcdf46fb8e15681cda8c0b144f",
    "predictions": [
      "file_suffix='-human-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ADROIT_BODY_POS]), \n ), \n"
    ],
    "correct": true,
    "top_five": {
      "0": "file_suffix='-human-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ADROIT_BODY_POS]), \n ), \n",
      "1": "file_suffix='-human-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ADROIT_BODY_POS]), \n has_policy_metadata=True, \n",
      "2": "file_suffix='-human-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL], _ADROIT_BODY_POS]), \n ), \n",
      "3": "file_suffix='-human-v1', \n step_metadata_keys=frozenset([_QPOS], _QVEL, _ADROIT_BODY_POS]), \n ), \n",
      "4": "file_suffix='-human-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ADROIT_BODY_POS]), \n ) \n"
    }
  },
  {
    "source_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord = op_ord.split(',')\n    _parser.validate_op_order(op_ord)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord\n\n",
    "target_code": "    global _eval_global_dict, _eval_parse_order\n    op_ord_list = op_ord.split(',')\n    _parser.validate_op_order(op_ord_list)\n    _eval_global_dict = gd\n    _eval_parse_order = op_ord_list\n\n",
    "warning_line": "    _parser.validate_op_order(op_ord)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.List[str]` for 1st positional only parameter to call `_parser.validate_op_order` but got `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1205,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "pygae/galgebra",
    "source_filename": "galgebra/printer.py",
    "target_filename": "galgebra/printer.py",
    "source_changeid": "ceacd273cdb095122678af6b1239f2b7b18cd9f4^",
    "target_changeid": "ceacd273cdb095122678af6b1239f2b7b18cd9f4",
    "predictions": [
      "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n"
    ],
    "correct": false,
    "top_five": {
      "0": "global _eval_global_dict, _eval_parse_order \n op_ord = op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "1": "global _eval_global_dict, _eval_parse_order \n assert op_ord is not None \n op_ord = op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "2": "global _eval_global_dict, _eval_parse_order \n assert op_ord is not None \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n",
      "3": "global _eval_global_dict, _eval_parse_order \n assert op_ord is not None \n _eval_global_dict = gd \n assert op_ord is not None \n _eval_parse_order = op_ord \n",
      "4": "global _eval_global_dict, _eval_parse_order \n op_ord.split(',') \n _eval_global_dict = gd \n _eval_parse_order = op_ord \n"
    }
  },
  {
    "source_code": "        <DED><DED>obj = self._construct_class(context, config_path, args)\n        if obj is not None:\n            <IND>context.symbol_space.append(obj)\n",
    "target_code": "        <DED><DED>obj = self._construct_class(context, config_path, args)\n        if obj is not None and isinstance(obj, interfaces.symbols.SymbolTableInterface):\n            <IND>context.symbol_space.append(obj)\n",
    "warning_line": "            context.symbol_space.append(obj)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `interfaces.symbols.BaseSymbolTableInterface` for 1st positional only parameter to call `interfaces.symbols.SymbolSpaceInterface.append` but got `interfaces.objects.ObjectInterface`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 691,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "volatilityfoundation/volatility3",
    "source_filename": "volatility/framework/interfaces/configuration.py",
    "target_filename": "volatility/framework/interfaces/configuration.py",
    "source_changeid": "623180ddbda404addc5d46b5e29f93ae233ae446^",
    "target_changeid": "623180ddbda404addc5d46b5e29f93ae233ae446",
    "predictions": [
      "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and obj is not None: \n <IND> context.symbol_space.append(obj) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and obj is not None: \n <IND> context.symbol_space.append(obj) \n",
      "1": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None: \n <IND> context.symbol_space.append(obj) \n",
      "2": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and not None: \n <IND> context.symbol_space.append(obj) \n",
      "3": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None and obj.symbol_space is not None: \n <IND> context.symbol_space.append(obj) \n",
      "4": "<DED> <DED> obj = self._construct_class(context, config_path, args) \n if obj is not None: \n <IND> context.symbol_space.append(obj.SymbolSpaceInterface) \n"
    }
  },
  {
    "source_code": "        <IND>self.rows.append([\n            waypoint.number,\n            waypoint.waypoint.pretty_name,\n",
    "target_code": "        <IND>self.rows.append([\n            str(waypoint.number),\n            waypoint.waypoint.pretty_name,\n",
    "warning_line": "        self.rows.append([",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `List[str]` for 1st positional only parameter to call `list.append` but got `List[typing.Union[int, str]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 138,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dcs-liberation/dcs_liberation",
    "source_filename": "gen/kneeboard.py",
    "target_filename": "gen/kneeboard.py",
    "source_changeid": "db6b6602700abae7c8178c3a99211325a819c787^",
    "target_changeid": "db6b6602700abae7c8178c3a99211325a819c787",
    "predictions": [
      "<IND> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n",
      "1": "<DED> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n",
      "2": "<IND> self.rows.append([ \n waypoint.number, <DED> waypoint.waypoint.pretty_name, \n",
      "3": "\n self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n",
      "4": "<IND> self.rows.append([ \n waypoint.number, \n waypoint.waypoint.pretty_name, \n ]) \n"
    }
  },
  {
    "source_code": "# Pagesize in K.\n_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024\n\n",
    "target_code": "# Pagesize in K.\n_PAGESIZE = os.sysconf(os.sysconf_names['SC_PAGE_SIZE']) // 1024\n\n",
    "warning_line": "_PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Union[int, str]` for 1st positional only parameter to call `os.sysconf` but got `bytes`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 24,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "morganstanley/treadmill",
    "source_filename": "lib/python/treadmill/psmem.py",
    "target_filename": "lib/python/treadmill/psmem.py",
    "source_changeid": "8a18047886aa6c95e65434706cf141743491ce21^",
    "target_changeid": "8a18047886aa6c95e65434706cf141743491ce21",
    "predictions": [
      "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n \n",
      "1": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n <DED>",
      "2": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE')/ 1024 \n \n",
      "3": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE') / 1024 \n <IND>",
      "4": "# Pagesize in K. \n _PAGESIZE = os.sysconf(b'SC_PAGE_SIZE')/bytes \n \n"
    }
  },
  {
    "source_code": "            <DED><DED>if isinstance(field.type, type) and issubclass(field.type, Enum):\n                <IND>kwargs[\"choices\"] = list(field.type)\n                kwargs[\"type\"] = field.type\n                if field.default is not dataclasses.MISSING:\n",
    "target_code": "            <DED><DED>if isinstance(field.type, type) and issubclass(field.type, Enum):\n                <IND>kwargs[\"choices\"] = [x.value for x in field.type]\n                kwargs[\"type\"] = type(kwargs[\"choices\"][0])\n                if field.default is not dataclasses.MISSING:\n",
    "warning_line": "                kwargs[\"choices\"] = list(field.type)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Iterable[Variable[_T]]` for 1st positional only parameter to call `list.__init__` but got `typing.Type[typing.Any]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 97,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "huggingface/transformers",
    "source_filename": "src/transformers/hf_argparser.py",
    "target_filename": "src/transformers/hf_argparser.py",
    "source_changeid": "7c6d63298f27b4a386f4603262a4603a2a6bf057^",
    "target_changeid": "7c6d63298f27b4a386f4603262a4603a2a6bf057",
    "predictions": [
      "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = field.type \n if field.default is not dataclasses.MISSING: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = field.type \n if field.default is not dataclasses.MISSING: \n",
      "1": "<DED> <DED> if field.type isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = field.type \n if field.default is not dataclasses.MISSING: \n",
      "2": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = [field.type] \n if field.default is not dataclasses.MISSING: \n",
      "3": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = [] \n if field.default is not dataclasses.MISSING: \n",
      "4": "<DED> <DED> if isinstance(field.type, type) and issubclass(field.type, Enum): \n <IND> kwargs[\"choices\"] = args[\"type\"] \n if field.default is not dataclasses.MISSING: \n"
    }
  },
  {
    "source_code": "            friendly=flight.from_cp.captured,\n            departure_delay=flight.scheduled_in,\n            departure=departure_runway,\n",
    "target_code": "            friendly=flight.from_cp.captured,\n            # Set later.\n            departure_delay=timedelta(),\n            departure=departure_runway,\n",
    "warning_line": "            departure_delay=flight.scheduled_in,",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `timedelta` for 6th parameter `departure_delay` to call `FlightData.__init__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 671,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dcs-liberation/dcs_liberation",
    "source_filename": "gen/aircraft.py",
    "target_filename": "gen/aircraft.py",
    "source_changeid": "49aa79c612d8894f2728ed03a9df76f872458d63^",
    "target_changeid": "49aa79c612d8894f2728ed03a9df76f872458d63",
    "predictions": [
      "friendly=flight.from_cp.captured, \n departure_delay=Timedelta(flight.scheduled_in), \n departure=departure_runway, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "friendly=flight.from_cp.captured, \n departure_delay=Timedelta(flight.scheduled_in), \n departure=departure_runway, \n",
      "1": "friendly=flight.from_cp.captured, \n departure_delay=timedelta(flight.scheduled_in), \n departure=departure_runway, \n",
      "2": "friendly=flight.from_cp.captured, \n departure_delay=Timedelta(flight.scheduled_in), \n departure=timedelta(departure_runway), \n",
      "3": "friendly=flight.from_cp.captured, \n departure_delay=timedelta(flight.scheduled_in), \n departure=timedelta(departure_runway), \n",
      "4": "friendly=flight.from_cp.captured, \n departure_delay=int(flight.scheduled_in), \n departure=departure_runway, \n"
    }
  },
  {
    "source_code": "    snapshot = json.loads(raw_snapshot)\n    block_number = int(snapshot[\"block_number\"])\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
    "target_code": "    snapshot = json.loads(raw_snapshot)\n    block_number = BlockNumber(int(snapshot[\"block_number\"]))\n    snapshot[\"block_hash\"] = cache.get(block_number)\n",
    "warning_line": "    snapshot[\"block_hash\"] = cache.get(block_number)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `BlockNumber` for 1st positional only parameter to call `BlockHashCache.get` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 127,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/storage/migrations/v18_to_v19.py",
    "target_filename": "raiden/storage/migrations/v18_to_v19.py",
    "source_changeid": "aa66a4ee225f171c9f2f1d14c33a491507496b40^",
    "target_changeid": "aa66a4ee225f171c9f2f1d14c33a491507496b40",
    "predictions": [
      "snapshot = json.loads(raw_snapshot) \n block_number = BlockNumber(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "snapshot = json.loads(raw_snapshot) \n block_number = BlockNumber(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "1": "snapshot = json.loads(raw_snapshot) \n block_number = block_number(int(snapshot[\"block_number\"])) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "2": "snapshot = json.loads(raw_snapshot) \n block_number = block_number(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "3": "snapshot = json.loads(raw_snapshot) \n block_number = block_number_int(snapshot[\"block_number\"]) \n snapshot[\"block_hash\"] = cache.get(block_number) \n",
      "4": "snapshot = json.loads(raw_snapshot) \n block_number = snapshot[\"block_number\"] \n snapshot[\"block_hash\"] = cache.get(block_number) \n"
    }
  },
  {
    "source_code": "        <DED>elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE:\n            <IND>claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id)\n",
    "target_code": "        <DED>elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE:\n            <IND>assert self.claimable_balance_id is not None\n            claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id)\n",
    "warning_line": "            claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Union[bytes, str]` for 1st positional only parameter to call `binascii.unhexlify` but got `Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 319,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "StellarCN/py-stellar-base",
    "source_filename": "stellar_sdk/operation/revoke_sponsorship.py",
    "target_filename": "stellar_sdk/operation/revoke_sponsorship.py",
    "source_changeid": "fb330563ff2269540bfbfd662fa535080d1cc1f6^",
    "target_changeid": "fb330563ff2269540bfbfd662fa535080d1cc1f6",
    "predictions": [
      "<DED> elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE: \n <IND> assert self.claimable_balance_id is not None \n claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE: \n <IND> assert self.claimable_balance_id is not None \n claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id) \n",
      "1": "<DED> elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE: \n <IND> assert self.claimable_balance_balance_id is not None \n claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id) \n",
      "2": "<DED> elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE: \n <IND> assert isinstance(self.claimable_balance_id) \n claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id) \n",
      "3": "\n elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE: \n <IND> assert self.claimable_balance_id is not None \n claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id) \n",
      "4": "<IND> elif self.revoke_sponsorship_type == RevokeSponsorshipType.CLAIMABLE_BALANCE: \n <IND> assert self.claimable_balance_id is not None \n claimable_balance_bytes = binascii.unhexlify(self.claimable_balance_id) \n"
    }
  },
  {
    "source_code": "        <DED>if self.client.source == \"qobuz\":\n            <IND>if not self.__validate_qobuz_dl_info(dl_info):\n",
    "target_code": "        <DED>if self.client.source == \"qobuz\":\n            <IND>assert isinstance(dl_info, dict)  # for typing\n            if not self.__validate_qobuz_dl_info(dl_info):\n",
    "warning_line": "            if not self.__validate_qobuz_dl_info(dl_info):",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Dict[typing.Any, typing.Any]` for 1st positional only parameter to call `Track._Track__validate_qobuz_dl_info` but got `Union[typing.Dict[typing.Any, typing.Any], str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 205,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "nathom/streamrip",
    "source_filename": "streamrip/bases.py",
    "target_filename": "streamrip/bases.py",
    "source_changeid": "fc8f4cee83a04b396e2f172f23d39e345caf36f0^",
    "target_changeid": "fc8f4cee83a04b396e2f172f23d39e345caf36f0",
    "predictions": [
      "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n",
      "1": "<DED> if self.client.source == \"qobuz\": \n <IND> assert isinstance(dl_info, dict) \n if not self.__validate_qobuz_dl_info(dl_info): \n",
      "2": "<DED> if self.client.source == \"qobuz\": \n <IND> assert self.client.source is not None \n if not self.__validate_qobuz_dl_info(dl_info): \n",
      "3": "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n <IND> assert isinstance(dl_info, str) \n",
      "4": "<DED> if self.client.source == \"qobuz\": \n <IND> if not self.__validate_qobuz_dl_info(dl_info): \n <IND> assert isinstance(dl_info, dict) \n"
    }
  },
  {
    "source_code": "            if certinfo_ca_file:\n                <IND>extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n",
    "target_code": "            if certinfo_ca_file:\n                <IND>if not isinstance(certinfo_ca_file, str):\n                    <IND>raise TypeError(f\"Expected a str for certinfo_ca_file but received {certinfo_ca_file}\")\n                <DED>extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))\n",
    "warning_line": "                extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Union[os.PathLike[str], str]` for 1st positional only parameter to call `Path.__new__` but got `Union[bool, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 52,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "nabla-c0d3/sslyze",
    "source_filename": "sslyze/plugins/certificate_info/cli_connector.py",
    "target_filename": "sslyze/plugins/certificate_info/cli_connector.py",
    "source_changeid": "a9d97c83dc6145535154e7eadd6e5deb33171b7a^",
    "target_changeid": "a9d97c83dc6145535154e7eadd6e5deb33171b7a",
    "predictions": [
      "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n",
      "1": "if certinfo_ca_file: \n <IND> assert isinstance(certinfo_ca_file, str) \n extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n",
      "2": "if certinfo_ca_file: \n <IND> assert certinfo_ca_file is not None \n extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n",
      "3": "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n if certinfo_ca_file is not None: \n <IND> return \n",
      "4": "if certinfo_ca_file: \n <IND> extra_arguments = CertificateInfoExtraArguments(custom_ca_file=Path(certinfo_ca_file)) \n if certinfo_ca_file is not None: \n"
    }
  },
  {
    "source_code": "            <DED>elif \"block_number\" in statechange_data:\n                <IND>block_number = int(statechange_data[\"block_number\"])\n                data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
    "target_code": "            <DED>elif \"block_number\" in statechange_data:\n                <IND>block_number = BlockNumber(int(statechange_data[\"block_number\"]))\n                data[\"triggered_by_block_hash\"] = cache.get(block_number)\n",
    "warning_line": "                data[\"triggered_by_block_hash\"] = cache.get(block_number)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `BlockNumber` for 1st positional only parameter to call `BlockHashCache.get` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 116,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/storage/migrations/v18_to_v19.py",
    "target_filename": "raiden/storage/migrations/v18_to_v19.py",
    "source_changeid": "aa66a4ee225f171c9f2f1d14c33a491507496b40^",
    "target_changeid": "aa66a4ee225f171c9f2f1d14c33a491507496b40",
    "predictions": [
      "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = int(statechange_data[\"block_number\"]) \n data[\"triggered_by_block_hash\"] = cache.get(block_number) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = int(statechange_data[\"block_number\"]) \n data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "1": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = statechange_data[\"block_number\"] \n data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "2": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number_type = int(statechange_data[\"block_number\"]) \n data[\"triggered_by_block_hash\"] = cache.get(block_number_type) \n",
      "3": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = statechange_data[\"block_number\"] <DED> data[\"triggered_by_block_hash\"] = cache.get(block_number) \n",
      "4": "<DED> elif \"block_number\" in statechange_data: \n <IND> block_number = statechange_data[\"block_number\"] <IND> data[\"triggered_by_block_hash\"] = cache.get(block_number) \n"
    }
  },
  {
    "source_code": "                <IND>if not ignoreObjectAttribs:\n                    <IND>outfile.write(line.encode('utf8')+'\\n')\n                <DED>else:\n",
    "target_code": "                <IND>if not ignoreObjectAttribs:\n                    <IND>outfile.write(line+'\\n')\n                <DED>else:\n",
    "warning_line": "                    outfile.write(line.encode('utf8')+'\\n')",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `io.TextIOBase.write` but got `bytes`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 111,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "psychopy/psychopy",
    "source_filename": "psychopy/tests/test_app/test_builder/genComponsTemplate.py",
    "target_filename": "psychopy/tests/test_app/test_builder/genComponsTemplate.py",
    "source_changeid": "f120e91f49d9f6b0d7fe7f4de0e42f4fbf9295a3^",
    "target_changeid": "f120e91f49d9f6b0d7fe7f4de0e42f4fbf9295a3",
    "predictions": [
      "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <DED> else: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <DED> else: \n",
      "1": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(str(line.encode('utf8')+' \\ n')) \n <DED> else: \n",
      "2": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n').decode('utf8') \n <DED> else: \n",
      "3": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <IND> else: \n",
      "4": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n \n else: \n"
    }
  },
  {
    "source_code": "        <DED><DED>elif return_attention_mask and \"attention_mask\" not in processed_features:\n            <IND>processed_features[\"attention_mask\"] = [1] * len(required_input)\n\n",
    "target_code": "        <DED><DED>elif return_attention_mask and \"attention_mask\" not in processed_features:\n            <IND>processed_features[\"attention_mask\"] = np.ones(len(required_input), dtype=np.int32)\n\n",
    "warning_line": "            processed_features[\"attention_mask\"] = [1] * len(required_input)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `List[float]` for 2nd positional only parameter to call `dict.__setitem__` but got `List[int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 301,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "huggingface/transformers",
    "source_filename": "src/transformers/feature_extraction_sequence_utils.py",
    "target_filename": "src/transformers/feature_extraction_sequence_utils.py",
    "source_changeid": "1417978cd49181fd08837e7722c34dd5c8c113e3^",
    "target_changeid": "1417978cd49181fd08837e7722c34dd5c8c113e3",
    "predictions": [
      "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input) \n \n",
      "1": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [0] * len(required_input) \n \n",
      "2": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = len(required_input) \n \n",
      "3": "<IND> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input) \n \n",
      "4": "<DED> <DED> elif return_attention_mask and \"attention_mask\" not in processed_features: \n <IND> processed_features[\"attention_mask\"] = [1] * len(required_input, float) \n \n"
    }
  },
  {
    "source_code": "    <DED>import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p) # type: ignore\n    foo = importlib.util.module_from_spec(spec)\n",
    "target_code": "    <DED>import importlib.util\n    spec = importlib.util.spec_from_file_location(name, p); assert spec is not None\n    foo = importlib.util.module_from_spec(spec)\n",
    "warning_line": "    foo = importlib.util.module_from_spec(spec)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `importlib.machinery.ModuleSpec` for 1st positional only parameter to call `importlib.util.module_from_spec` but got `typing.Optional[importlib.machinery.ModuleSpec]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 65,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "karlicoss/promnesia",
    "source_filename": "tests/indexer_test.py",
    "target_filename": "tests/indexer_test.py",
    "source_changeid": "a88334bb03099d98e841be66c06b137cb9d2b063^",
    "target_changeid": "a88334bb03099d98e841be66c06b137cb9d2b063",
    "predictions": [
      "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) \n",
      "1": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) \n foo = importlib.util.module_from_spec(spec) \n",
      "2": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n if spec is None: \n <DED> foo = importlib.util.module_from_spec(spec) \n",
      "3": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) <IND>",
      "4": "<DED> import importlib.util \n spec = importlib.util.spec_from_file_location(name, p) # type: ignore \n foo = importlib.util.module_from_spec(spec) <DED>"
    }
  },
  {
    "source_code": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([None] + types,\n                             arg_kinds,\n",
    "target_code": "        arg_kinds = [ARG_POS] * (len(items) + 1)\n        signature = Callable([cast(Type, None)] + types,\n                             arg_kinds,\n",
    "warning_line": "        signature = Callable([None] + types,",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `List[Type]` for 1st positional only parameter to call `Callable.__init__` but got `List[None]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1099,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "python/mypy",
    "source_filename": "mypy/semanal.py",
    "target_filename": "mypy/semanal.py",
    "source_changeid": "994429cdad45d1d33891d9defcf5a9182a4881ce^",
    "target_changeid": "994429cdad45d1d33891d9defcf5a9182a4881ce",
    "predictions": [
      "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([Type] + types, \n arg_kinds, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([Type] + types, \n arg_kinds, \n",
      "1": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = List[Type]([] + types, \n arg_kinds, \n",
      "2": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([types] + types, \n arg_kinds, \n",
      "3": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([classes] + types, \n arg_kinds, \n",
      "4": "arg_kinds = [ARG_POS] * (len(items) + 1) \n signature = Callable([] + types, \n arg_kinds, \n"
    }
  },
  {
    "source_code": "\n        key_edit = ShowQRTextEdit(self)\n        key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \"\n",
    "target_code": "\n        key_edit = ShowQRTextEdit()\n        key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \"\n",
    "warning_line": "        key_edit = ShowQRTextEdit(self)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Optional[str]` for 1st positional only parameter to call `ShowQRTextEdit.__init__` but got `CosignerCard`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 93,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "electrumsv/electrumsv",
    "source_filename": "electrumsv/gui/qt/cosigners_view.py",
    "target_filename": "electrumsv/gui/qt/cosigners_view.py",
    "source_changeid": "c047094ed736db27426d43bf3042097b5567e6fe^",
    "target_changeid": "c047094ed736db27426d43bf3042097b5567e6fe",
    "predictions": [
      "\n key_edit = ShowQRTextEdit() \n key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \" \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n key_edit = ShowQRTextEdit() \n key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \" \n",
      "1": "\n key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \" \n",
      "2": "\n key_edit = ShowQRTextEdit(str(self)) \n key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \" \n",
      "3": "\n key_edit = ShowQRTextEdit(self) \n key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \" \n",
      "4": "\n key_edit = ShowQRTextEdit(str, self) \n key_edit.setPlaceholderText(_(\"Paste any extended public key for this cosigner here, or \" \n"
    }
  },
  {
    "source_code": "            <IND>return cst.Annotation(annotation=self._handle_Subscript(node))\n        <DED>else:\n            <IND>return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n\n",
    "target_code": "            <IND>return cst.Annotation(annotation=self._handle_Subscript(node))\n        <DED>elif isinstance(node, NAME_OR_ATTRIBUTE):\n            <IND>return cst.Annotation(annotation=self._handle_NameOrAttribute(node))\n        <DED>else:\n            <IND>raise ValueError(f\"Unexpected annotation node: {node}\")\n\n",
    "warning_line": "            return cst.Annotation(annotation=self._handle_NameOrAttribute(node))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Union[cst._nodes.expression.Attribute, cst._nodes.expression.Name]` for 1st positional only parameter to call `TypeCollector._handle_NameOrAttribute` but got `cst._nodes.expression.BaseExpression`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 237,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Instagram/LibCST",
    "source_filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "target_filename": "libcst/codemod/visitors/_apply_type_annotations.py",
    "source_changeid": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8^",
    "target_changeid": "3ccfc4adc82b8354c1c998b0abd1ded3d690a1e8",
    "predictions": [
      "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation(annotation=self._handle_NameOrAttribute(node)) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation(annotation=self._handle_NameOrAttribute(node)) \n \n",
      "1": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation(annotation=NameOrAttribute(node)) \n \n",
      "2": "<IND> return cst.Annotation((annotation=self._handle_Subscript(node))) \n <DED> else: \n <IND> return cst.Annotation((annotation=self._handle_NameOrAttribute(node))) \n \n",
      "3": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation([annotation=self._handle_NameOrAttribute(node)]) \n \n",
      "4": "<IND> return cst.Annotation(annotation=self._handle_Subscript(node)) \n <DED> else: \n <IND> return cst.Annotation((annotation=self._handle_NameOrAttribute(node))) \n \n"
    }
  },
  {
    "source_code": "                <IND>k.typecheck(kty)\n            <DED>if vty is None or vty == T.Array(T.Any()) or vty == T.Map(None):\n                <IND>vty = v.type\n",
    "target_code": "                <IND>k.typecheck(kty)\n            <DED>if vty is None or vty == T.Array(T.Any()) or vty == T.Map((T.Any(), T.Any())):\n                <IND>vty = v.type\n",
    "warning_line": "            if vty is None or vty == T.Array(T.Any()) or vty == T.Map(None):",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Tuple[T.Base, T.Base]` for 1st positional only parameter to call `T.Map.__init__` but got `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 445,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "chanzuckerberg/miniwdl",
    "source_filename": "WDL/Expr.py",
    "target_filename": "WDL/Expr.py",
    "source_changeid": "1b3f26c69b306c12226eaa02145072af0de12839^",
    "target_changeid": "1b3f26c69b306c12226eaa02145072af0de12839",
    "predictions": [
      "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()): \n <IND> vty = v.type \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()): \n <IND> vty = v.type \n",
      "1": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Equal(0)): \n <IND> vty = v.type \n",
      "2": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Any()): \n <IND> vty = v.type \n",
      "3": "<IND> k.typecheck(kty) \n <DED> if vty == None: \n <IND> vty = v.type \n",
      "4": "<IND> k.typecheck(kty) \n <DED> if vty is None or vty == T.Array(T.Any()) or vty == T.Map(Equal): \n <IND> vty = v.type \n"
    }
  },
  {
    "source_code": "        to_address=from_transfer.target,\n        amount=from_transfer.lock.amount,\n        previous_address=transfer.sender,\n",
    "target_code": "        to_address=from_transfer.target,\n        amount=PaymentAmount(from_transfer.lock.amount),  # FIXME: mypy; deprecated through #3863\n        previous_address=transfer.sender,\n",
    "warning_line": "        amount=from_transfer.lock.amount,",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `PaymentAmount` for 5th parameter `amount` to call `routing.get_best_routes` but got `raiden.utils.typing.PaymentWithFeeAmount`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 164,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/raiden_service.py",
    "target_filename": "raiden/raiden_service.py",
    "source_changeid": "99fbd1b7b94ee98f764e021c04d967333467a6e6^",
    "target_changeid": "99fbd1b7b94ee98f764e021c04d967333467a6e6",
    "predictions": [
      "to_address=from_transfer.target, \n amount=from_transfer.lock.amount, \n previous_address=transfer.sender, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount, \n previous_address=transfer.sender, \n",
      "1": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount, \n previous_address=from_transfer.sender, \n",
      "2": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount \n previous_address=transfer.sender, \n",
      "3": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount <DED> previous_address=transfer.sender, \n",
      "4": "to_address=from_transfer.target, \n amount=from_transfer.lock.amount <IND> previous_address=transfer.sender, \n"
    }
  },
  {
    "source_code": "            token_network_identifier=to_canonical_address(data['token_network_identifier']),\n            channel_identifier=int(data['channel_identifier']),\n            block_number=typing.BlockNumber(int(data['block_number'])),\n",
    "target_code": "            token_network_identifier=to_canonical_address(data['token_network_identifier']),\n            channel_identifier=typing.ChannelID(int(data['channel_identifier'])),\n            block_number=typing.BlockNumber(int(data['block_number'])),\n",
    "warning_line": "            channel_identifier=int(data['channel_identifier']),",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.ChannelID` for 3rd parameter `channel_identifier` to call `ContractReceiveRouteClosed.__init__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 998,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/state_change.py",
    "target_filename": "raiden/transfer/state_change.py",
    "source_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82^",
    "target_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82",
    "predictions": [
      "token_network_identifier=to_canonical_address(data['token_network_identifier']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n block_number=typing.BlockNumber(int(data['block_number'])), \n"
    ],
    "correct": true,
    "top_five": {
      "0": "token_network_identifier=to_canonical_address(data['token_network_identifier']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n block_number=typing.BlockNumber(int(data['block_number'])), \n",
      "1": "token_network_identifier=to_canonical_address(data['token_network_identifier']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier']))), \n block_number=typing.BlockNumber(int(data['block_number'])), \n",
      "2": "token_network_identifier=to_canonical_address(data['token_network_identifier']), <DED> channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n block_number=typing.BlockNumber(int(data['block_number'])), \n",
      "3": "token_network_identifier=to_canonical_address(data['token_network_identifier']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n block_number=typing.BlockNumber(int(data['block_number'])), <IND>",
      "4": "token_network_identifier=to_canonical_address(data['token_network_identifier']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n block_number=typing.BlockNumber(int(data['block_number'])), \n ), \n"
    }
  },
  {
    "source_code": "              headers: Optional[List[str]] = None) -> None:\n        <IND>table = tabulate(cells, headers=headers, numalign=\"right\")\n",
    "target_code": "              headers: Optional[List[str]] = None) -> None:\n        <IND>if headers is None:\n            <IND>headers = []\n        <DED>table = tabulate(cells, headers=headers, numalign=\"right\")\n",
    "warning_line": "        table = tabulate(cells, headers=headers, numalign=\"right\")",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Union[Dict[str, str], typing.Sequence[str], str]` for 2nd parameter `headers` to call `tabulate` but got `Optional[List[str]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 85,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dcs-liberation/dcs_liberation",
    "source_filename": "gen/kneeboard.py",
    "target_filename": "gen/kneeboard.py",
    "source_changeid": "db6b6602700abae7c8178c3a99211325a819c787^",
    "target_changeid": "db6b6602700abae7c8178c3a99211325a819c787",
    "predictions": [
      "headers: Optional[List[str]] = None) -> None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n"
    ],
    "correct": false,
    "top_five": {
      "0": "headers: Optional[List[str]] = None) -> None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "1": "headers: Optional[List[str]] = None) -> None: \n <IND> list = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "2": "headers: Optional[List[str]] = None) -> None: \n <IND> cell = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "3": "headers: List[str] = None) -> None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n",
      "4": "headers: Optional[List[str]] = None) -> None: \n <IND> if headers is None: \n <IND> table = tabulate(cells, headers=headers, numalign=\"right\") \n"
    }
  },
  {
    "source_code": "\n    io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write(\n        ('\\n'.join(messages) + '\\n').encode(\"utf-8\"))\n    os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))\n",
    "target_code": "\n    with open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\") as f:\n        <IND>f.write('\\n'.join(messages) + '\\n')\n    <DED>os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]))\n",
    "warning_line": "        ('\\n'.join(messages) + '\\n').encode(\"utf-8\"))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `io.TextIOBase.write` but got `bytes`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 419,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tribe29/checkmk",
    "source_filename": "cmk/base/plugins/agent_based/logwatch_ec.py",
    "target_filename": "cmk/base/plugins/agent_based/logwatch_ec.py",
    "source_changeid": "ba8be4ea9b9232e49d0fdb248113f391e159f8ee^",
    "target_changeid": "ba8be4ea9b9232e49d0fdb248113f391e159f8ee",
    "predictions": [
      "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n",
      "1": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\")).write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n",
      "2": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]) \n",
      "3": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\").write( \n'\\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:])) \n",
      "4": "\n io.open('%s/%s' % (spool_path, file_name), 'w', encoding=\"utf-8\")).write( \n (' \\ n'.join(messages) +'\\ n').encode(\"utf-8\") \n os.rename('%s/%s' % (spool_path, file_name), '%s/%s' % (spool_path, file_name[1:]) \n"
    }
  },
  {
    "source_code": "\n<DED><DED><DED>def build_namespace_package_module(name, path: str) -> nodes.Module:\n    <IND>return nodes.Module(name, doc=\"\", path=path, package=True)\n",
    "target_code": "\n<DED><DED><DED>def build_namespace_package_module(name: str, path: List[str]) -> nodes.Module:\n    <IND>return nodes.Module(name, doc=\"\", path=path, package=True)\n",
    "warning_line": "    return nodes.Module(name, doc=\"\", path=path, package=True)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Optional[List[str]]` for 3rd parameter `path` to call `nodes.scoped_nodes.Module.__init__` but got `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 267,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PyCQA/astroid",
    "source_filename": "astroid/builder.py",
    "target_filename": "astroid/builder.py",
    "source_changeid": "2c9c187b1c47adc4661246b922e3a41dc0756396^",
    "target_changeid": "2c9c187b1c47adc4661246b922e3a41dc0756396",
    "predictions": [
      "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "1": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: List[str]) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "2": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: typing.Optional[str]) -> nodes.Module: \n <IND> return nodes.Module(name, path=\"\", path=path, package=True) \n",
      "3": "\n <DED> <DED> <DED> def build_namespace_package_module(name, path: str) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n",
      "4": "\n <DED> <DED> <DED> def build_namespace_package_module(name, str) -> nodes.Module: \n <IND> return nodes.Module(name, doc=\"\", path=path, package=True) \n"
    }
  },
  {
    "source_code": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n        DERIVATION_DATA1, None, 0, None)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n        DERIVATION_DATA2, None, 0, None)\n\n",
    "target_code": "    line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32,\n        DERIVATION_DATA1, None, KeyInstanceFlag.NONE, None)\n    line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE,\n        DERIVATION_DATA2, None, KeyInstanceFlag.NONE, None)\n\n",
    "warning_line": "        DERIVATION_DATA2, None, 0, None)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `KeyInstanceFlag` for 7th positional only parameter to call `KeyInstanceRow.__init__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 280,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "electrumsv/electrumsv",
    "source_filename": "electrumsv/tests/test_wallet_database_tables.py",
    "target_filename": "electrumsv/tests/test_wallet_database_tables.py",
    "source_changeid": "9154a84d48a81ec19f6787cec6e9bf1a94a5e025^",
    "target_changeid": "9154a84d48a81ec19f6787cec6e9bf1a94a5e025",
    "predictions": [
      "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, 0) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, 0) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n",
      "1": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, None) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, None) \n \n",
      "2": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, None) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n",
      "3": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA2, None, KeyInstanceFlag.NONE) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, KeyInstanceFlag.NONE, None) \n",
      "4": "line1 = KeyInstanceRow(KEYINSTANCE_ID+1, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.BIP32, \n DERIVATION_DATA1, None, 0) \n line2 = KeyInstanceRow(KEYINSTANCE_ID+2, ACCOUNT_ID+1, MASTERKEY_ID+1, DerivationType.HARDWARE, \n DERIVATION_DATA2, None, 0) \n \n"
    }
  },
  {
    "source_code": "        if os.path.exists(pretrained_model_name_or_path)                and \"config.json\" in pretrained_model_name_or_path                and \"prediction_head\" in pretrained_model_name_or_path:\n            # a) FARM style\n            <IND>super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path)\n        <DED>else:\n",
    "target_code": "        if os.path.exists(pretrained_model_name_or_path)                and \"config.json\" in str(pretrained_model_name_or_path)                and \"prediction_head\" in str(pretrained_model_name_or_path):\n            # a) FARM style\n            <IND>super(QuestionAnsweringHead, cls).load(str(pretrained_model_name_or_path))\n        <DED>else:\n",
    "warning_line": "            super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `PredictionHead.load` but got `Union[Path, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 297,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "deepset-ai/haystack",
    "source_filename": "haystack/basics/modeling/prediction_head.py",
    "target_filename": "haystack/basics/modeling/prediction_head.py",
    "source_changeid": "9c409e00127fd21072b74779431277e8338dd71b^",
    "target_changeid": "9c409e00127fd21072b74779431277e8338dd71b",
    "predictions": [
      "if os.path.exists(pretrained_model_name_or_path) and \"config.json\" in pretrained_model_name_or_path and \"prediction_head\" in pretrained_model_name_or_path: \n # a) FARM style \n <IND> super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path) \n <DED> else: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if os.path.exists(pretrained_model_name_or_path) and \"config.json\" in pretrained_model_name_or_path and \"prediction_head\" in pretrained_model_name_or_path: \n # a) FARM style \n <IND> super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path) \n <DED> else: \n",
      "1": "if os.path.exists(pretrained_model_name_or_path) and \"config.json\" in pretrained_model_name_or_path and \"prediction_head\" in pretrained_model_name_or_path: \n # a) FARM style \n <IND> super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path) \n <DED> else: \n",
      "2": "if os.path.exists(pretrained_model_name_or_path) and \"config.json\" in pretrained_model_name_or_path and \"prediction_head\" in pretrained_model_name_or_path: \n # a) FARM style \n <IND> super(QuestionAnsweringHead, cls).load(Pretrained_model_name_or_path) \n <DED> else: \n",
      "3": "if os.path.exists(pretrained_model_name_or_path) and \"config.json\" in str(pretrained_model_name_or_path) and \"prediction_head\" in str(pretrained_model_name_or_path): \n # a) FARM style \n <IND> super(QuestionAnsweringHead, cls).load(pretrained_model_name_or_path) \n <DED> else: \n",
      "4": "if os.path.exists(pretrained_model_name_or_path) and \"config.json\" in pretrained_model_name_or_path and \"prediction_head\" in pretrained_model_name_or_path: \n # a) FARM style \n <IND> super(QuestionAnsweringHead, cls).load(Pretrained_model_name_or_path) \n <DED> else: \n"
    }
  },
  {
    "source_code": "        last_index = since_id\n        state[config.url_id] = scrapper_stat\n\n",
    "target_code": "        last_index = since_id\n        if config.url_id:\n            <IND>state[config.url_id] = scrapper_stat\n\n",
    "warning_line": "        state[config.url_id] = scrapper_stat",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `dict.__setitem__` but got `Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 69,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "obsei/obsei",
    "source_filename": "obsei/source/reddit_scrapper.py",
    "target_filename": "obsei/source/reddit_scrapper.py",
    "source_changeid": "f668a90b1ac8cebbbd72d4f02184bba3fa0ecd3c^",
    "target_changeid": "f668a90b1ac8cebbbd72d4f02184bba3fa0ecd3c",
    "predictions": [
      "last_index = since_id \n state[str] = scrapper_stat \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "last_index = since_id \n state[str] = scrapper_stat \n \n",
      "1": "last_index = since_id \n state[str, config.url_id] = scrapper_stat \n \n",
      "2": "last_index = since_id \n state[str_id] = scrapper_stat \n \n",
      "3": "last_index = since_id \n state[str] = config.url_id \n \n",
      "4": "last_index = since_id \n state[str] = dict.__setitem__(str) \n \n"
    }
  },
  {
    "source_code": "            if widget.handle_mouse(event, target):\n                <IND>self.select(i + widget.mouse_targets.index(target))\n",
    "target_code": "            if widget.handle_mouse(event, target):\n                <IND>assert isinstance(target, MouseTarget)\n                self.select(i + widget.mouse_targets.index(target))\n",
    "warning_line": "                self.select(i + widget.mouse_targets.index(target))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `MouseTarget` for 1st positional only parameter to call `list.index` but got `Optional[MouseTarget]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 956,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "bczsalba/pytermgui",
    "source_filename": "pytermgui/widgets/base.py",
    "target_filename": "pytermgui/widgets/base.py",
    "source_changeid": "591f99dcc2b7c2d07dde9a3c6fb3a574354a2a37^",
    "target_changeid": "591f99dcc2b7c2d07dde9a3c6fb3a574354a2a37",
    "predictions": [
      "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target)) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target)) \n",
      "1": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets[target]) \n",
      "2": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(event, target)) \n",
      "3": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target.target)) \n",
      "4": "if widget.handle_mouse(event, target): \n <IND> self.select(i + widget.mouse_targets.index(target.index)) \n"
    }
  },
  {
    "source_code": "            <IND>try:\n                <IND>rasa_nlu.components.fill_args(component.process_args(), context, self.config)\n                updates = component.context_provides.get(\"process\", [])\n",
    "target_code": "            <IND>try:\n                <IND>rasa_nlu.components.fill_args(component.process_args(), context, self.config.as_dict())\n                updates = component.context_provides.get(\"process\", [])\n",
    "warning_line": "                rasa_nlu.components.fill_args(component.process_args(), context, self.config)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Dict[str, typing.Any]` for 3rd positional only parameter to call `rasa_nlu.components.fill_args` but got `RasaNLUConfig`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 159,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "RasaHQ/rasa",
    "source_filename": "rasa_nlu/model.py",
    "target_filename": "rasa_nlu/model.py",
    "source_changeid": "f55804e5cc46f21d73e82374a57f71a48a24fb12^",
    "target_changeid": "f55804e5cc46f21d73e82374a57f71a48a24fb12",
    "predictions": [
      "<IND> try: \n <IND> rasa_nlu.components.fill_args(component.process_args(), context, self.config.as_dict()) \n updates = component.context_provides.get(\"process\", []) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> try: \n <IND> rasa_nlu.components.fill_args(component.process_args(), context, self.config.as_dict()) \n updates = component.context_provides.get(\"process\", []) \n",
      "1": "<IND> try: \n <IND> rasa_nlu.components.fill_args(component.process_args(), context, []) \n updates = component.context_provides.get(\"process\", []) \n",
      "2": "<IND> try: \n <IND> rasa_nlu.components.fill_args(component.process_args(), context, self.config._dict) \n updates = component.context_provides.get(\"process\", []) \n",
      "3": "<IND> try: \n <IND> rasa_nlu.components.fill_args(component.process_args(), context, self.config.str()) \n updates = component.context_provides.get(\"process\", []) \n",
      "4": "<IND> try: \n <IND> rasa_nlu.components.fill_args(component.process_args(), context, self.config.str(\"process\")) \n updates = component.context_provides.get(\"process\", []) \n"
    }
  },
  {
    "source_code": "        <IND>cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n            i2Ri1_dict, [i0, i1, i2], two_view_reports_dict\n        )\n",
    "target_code": "        <IND>cycle_error, max_rot_error, max_trans_error = compute_cycle_error(\n            i2Ri1_dict, (i0, i1, i2), two_view_reports_dict\n        )\n",
    "warning_line": "            i2Ri1_dict, [i0, i1, i2], two_view_reports_dict",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Tuple[int, int, int]` for 2nd positional only parameter to call `compute_cycle_error` but got `List[int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 201,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "borglab/gtsfm",
    "source_filename": "gtsfm/averaging/rotation/cycle_consistency.py",
    "target_filename": "gtsfm/averaging/rotation/cycle_consistency.py",
    "source_changeid": "26f76a40e21bd082123f275404efca964faa59b9^",
    "target_changeid": "26f76a40e21bd082123f275404efca964faa59b9",
    "predictions": [
      "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], two_view_reports_dict \n ) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], two_view_reports_dict \n ) \n",
      "1": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], list(two_view_reports_dict) \n ) \n",
      "2": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2] \n ) \n",
      "3": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, List[int, int], two_view_reports_dict \n ) \n",
      "4": "<IND> cycle_error, max_rot_error, max_trans_error = compute_cycle_error( \n i2Ri1_dict, [i0, i1, i2], list[two_view_reports_dict] \n ) \n"
    }
  },
  {
    "source_code": "            ir,\n            pretty=debug.flags.edgeql_compile,\n            expected_cardinality_one=True,\n",
    "target_code": "            ir,\n            pretty=bool(debug.flags.edgeql_compile),\n            expected_cardinality_one=True,\n",
    "warning_line": "            pretty=debug.flags.edgeql_compile,",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `bool` for 2nd parameter `pretty` to call `pg_compiler.compile_ir_to_sql` but got `debug.Flag`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 112,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "edgedb/edgedb",
    "source_filename": "edb/server/http_graphql_port/compiler.py",
    "target_filename": "edb/server/http_graphql_port/compiler.py",
    "source_changeid": "784f8eb8181cb7f0e01f16202f28f39af243612d^",
    "target_changeid": "784f8eb8181cb7f0e01f16202f28f39af243612d",
    "predictions": [
      "ir, \n pretty=debug.flags.edgeql_compile, \n expected_cardinality_one=True, \n"
    ],
    "correct": false,
    "top_five": {
      "0": "ir, \n pretty=debug.flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "1": "ir, \n pretty=debug.Flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "2": "ir, \n pretty=bool=debug.flags.edgeql_compile, \n expected_cardinality_one=True, \n",
      "3": "ir, \n pretty=bool(debug.flags.edgeql_compile), \n expected_cardinality_one=True, \n",
      "4": "ir, \n pretty=Debug.Flags.edgeql_compile, \n expected_cardinality_one=True, \n"
    }
  },
  {
    "source_code": "                    symbol=symbol,\n                    qty=str(-symbol_position),\n                    side=\"buy\",\n",
    "target_code": "                    symbol=symbol,\n                    qty=-symbol_position,\n                    side=\"buy\",\n",
    "warning_line": "                    qty=str(-symbol_position),",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `int` for 2nd parameter `qty` to call `Trader.submit_order` but got `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 241,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "amor71/LiuAlgoTrader",
    "source_filename": "liualgotrader/consumer.py",
    "target_filename": "liualgotrader/consumer.py",
    "source_changeid": "64ac5f544cd9fc7191ddc14a265e0f4ce1a89100^",
    "target_changeid": "64ac5f544cd9fc7191ddc14a265e0f4ce1a89100",
    "predictions": [
      "symbol=symbol, \n qty=int(-symbol_position), \n side=\"buy\", \n"
    ],
    "correct": false,
    "top_five": {
      "0": "symbol=symbol, \n qty=int(-symbol_position), \n side=\"buy\", \n",
      "1": "symbol=symbol, \n qty=Int(-symbol_position), \n side=\"buy\", \n",
      "2": "symbol=symbol, \n qty=int((-symbol_position)), \n side=\"buy\", \n",
      "3": "symbol=symbol, \n qty=int(symbol_position), \n side=\"buy\", \n",
      "4": "symbol=symbol, \n qty=int(str(-symbol_position)), \n side=\"buy\", \n"
    }
  },
  {
    "source_code": "\n        return self.broker.get_macd(market, Interval.DAY, None)\n\n",
    "target_code": "\n        return self.broker.get_macd(market, Interval.DAY, 30)\n\n",
    "warning_line": "        return self.broker.get_macd(market, Interval.DAY, None)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `int` for 3rd positional only parameter to call `Broker.get_macd` but got `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 47,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ilcardella/TradingBot",
    "source_filename": "tradingbot/Strategies/SimpleMACD.py",
    "target_filename": "tradingbot/Strategies/SimpleMACD.py",
    "source_changeid": "d835f8b3955783b4b4ad5d4fbea44459b7fdd7fd^",
    "target_changeid": "d835f8b3955783b4b4ad5d4fbea44459b7fdd7fd",
    "predictions": [
      "\n return self.broker.get_macd(market, Interval.DAY, []) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n return self.broker.get_macd(market, Interval.DAY, []) \n \n",
      "1": "\n return broker.get_macd(market, Interval.DAY, []) \n \n",
      "2": "\n return self.broker.get_macd(market, Interval.DAY, '') \n \n",
      "3": "\n return self.broker.get_macd(market, Interval.DAY, \"\") \n \n",
      "4": "\n return self.broker.get_macd(market, Interval.DAY, [0], None) \n \n"
    }
  },
  {
    "source_code": "    <DED>if link_view:\n        <IND>sources.append(rptrcls)\n",
    "target_code": "    <DED>if link_view:\n        <IND>assert rptrcls is not None\n        sources.append(rptrcls)\n",
    "warning_line": "        sources.append(rptrcls)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Union[s_pointers.Pointer, s_pointers.PseudoPointer, s_types.Type]` for 1st positional only parameter to call `list.append` but got `typing.Union[None, s_pointers.Pointer, s_pointers.PseudoPointer]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1156,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "edgedb/edgedb",
    "source_filename": "edb/edgeql/compiler/viewgen.py",
    "target_filename": "edb/edgeql/compiler/viewgen.py",
    "source_changeid": "b1eec7ed6a649a16127f66447b9df8026854e9b4^",
    "target_changeid": "b1eec7ed6a649a16127f66447b9df8026854e9b4",
    "predictions": [
      "<DED> if link_view: \n <IND> assert link_view is not None \n sources.append(rptrcls) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> if link_view: \n <IND> assert link_view is not None \n sources.append(rptrcls) \n",
      "1": "<DED> if link_view: \n <IND> assert isinstance(s_pointers.Pointer, s_pointers.PseudoPointer, s_types.Type) \n sources.append(rptrcls) \n",
      "2": "<DED> if link_view: \n <IND> assert isinstance(rptrcls, s_pointers.Pointer, s_pointers.PseudoPointer) \n sources.append(rptrcls) \n",
      "3": "<DED> if link_view: \n <IND> assert isinstance(s_pointers.Pointer, s_pointers.PseudoPointer) \n sources.append(rptrcls) \n",
      "4": "<DED> if link_view: \n <IND> assert isinstance(rptrcls, s_pointers.Pointer) \n sources.append(rptrcls) \n"
    }
  },
  {
    "source_code": "        log.info(f\"Saving model to {self.save_path}\")\n        self.save_path.parent.mkdir(parents=True, exist_ok=True)\n        save_pickle(self.ec_data, self.save_path)\n\n",
    "target_code": "        log.info(f\"Saving model to {self.save_path}\")\n        save_pickle(self.ec_data, self.save_path)\n\n\n",
    "warning_line": "        save_pickle(self.ec_data, self.save_path)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Dict[typing.Any, typing.Any]` for 1st positional only parameter to call `save_pickle` but got `List[typing.Any]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 86,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "deepmipt/DeepPavlov",
    "source_filename": "deeppavlov/skills/ecommerce_bot/bot.py",
    "target_filename": "deeppavlov/skills/ecommerce_bot/bot.py",
    "source_changeid": "1de404c11bc5f40b766e966573506921980ff524^",
    "target_changeid": "1de404c11bc5f40b766e966573506921980ff524",
    "predictions": [
      "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path)) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path)) \n \n",
      "1": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, List[save_path]) \n \n",
      "2": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path, [])) \n \n",
      "3": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, List[self.save_path]) \n \n",
      "4": "log.info(f\"Saving model to { self.save_path } \") \n self.save_path.parent.mkdir(parents=True, exist_ok=True) \n save_pickle(self.ec_data, list(self.save_path, List[str, str])) \n \n"
    }
  },
  {
    "source_code": "        <DED>self.owned_eth_tokens.extend(tokens)\n        self.query_ethereum_tokens(tokens, self.balances[S_ETH])\n        return {'per_account': self.balances, 'totals': self.totals}\n",
    "target_code": "        <DED>self.owned_eth_tokens.extend(tokens)\n        eth_balances = cast(EthBalances, self.balances[S_ETH])\n        self.query_ethereum_tokens(tokens, eth_balances)\n        return {'per_account': self.balances, 'totals': self.totals}\n",
    "warning_line": "        self.query_ethereum_tokens(tokens, self.balances[S_ETH])",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Dict[typing.EthAddress, Dict[Union[str, typing.EthToken, typing.NonEthTokenBlockchainAsset], FVal]]` for 2nd positional only parameter to call `Blockchain.query_ethereum_tokens` but got `Dict[Union[typing.BTCAddress, typing.EthAddress], Dict[Union[str, typing.EthToken, typing.FiatAsset, typing.NonEthTokenBlockchainAsset], FVal]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 131,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "rotki/rotki",
    "source_filename": "rotkehlchen/blockchain.py",
    "target_filename": "rotkehlchen/blockchain.py",
    "source_changeid": "b763072c34b7f9d444fc042c460c93b458c8c282^",
    "target_changeid": "b763072c34b7f9d444fc042c460c93b458c8c282",
    "predictions": [
      "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, self.balances[S_ETH]) \n return { 'per_account': self.balances[S_ETH] \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, self.balances[S_ETH]) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "1": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, tokens.balances[S_ETH]) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "2": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens, tokens) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "3": "<DED> self.owned_eth_tokens.extend(tokens) \n self.query_ethereum_tokens(tokens) \n return { 'per_account': self.balances, 'totals': self.totals } \n",
      "4": "<DED> self.owned_eth_tokens.extend(tokens) \n return { 'per_account': self.balances, 'totals': self.totals } \n"
    }
  },
  {
    "source_code": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=[3])],\n)\n",
    "target_code": "    detect=checkpoint.DETECT,\n    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=['3'])],\n)\n",
    "warning_line": "    trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=[3])],",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.List[typing.Union[cmk.base.api.agent_based.section_types.OIDEnd, cmk.base.snmp_utils.OIDSpec, str]]` for 2nd parameter `oids` to call `cmk.base.api.agent_based.section_types.SNMPTree.__init__` but got `typing.List[int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 23,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tribe29/checkmk",
    "source_filename": "cmk/base/plugins/agent_based/checkpoint_connections.py",
    "target_filename": "cmk/base/plugins/agent_based/checkpoint_connections.py",
    "source_changeid": "584089be5d0a9ff7e70015a4a54e4dc8e7b8eaaf^",
    "target_changeid": "584089be5d0a9ff7e70015a4a54e4dc8e7b8eaaf",
    "predictions": [
      "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int]]], \n ) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int]]], \n ) \n",
      "1": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\")], \n ) \n",
      "2": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\"], oids=typing.List[int]]], \n ) \n",
      "3": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\", oids=typing.List[int])], \n ) \n",
      "4": "detect=checkpoint.DETECT, \n trees=[SNMPTree(base=\".1.3.6.1.4.1.2620.1.1.25\"], oids=typing.List[int]], \n ) \n"
    }
  },
  {
    "source_code": "    fx = 10.0\n    img_height = 45.0\n    top_plane = form_top_clipping_plane(fx, img_height)\n",
    "target_code": "    fx = 10.0\n    img_height = 45\n    top_plane = form_top_clipping_plane(fx, img_height)\n",
    "warning_line": "    top_plane = form_top_clipping_plane(fx, img_height)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `int` for 2nd positional only parameter to call `form_top_clipping_plane` but got `float`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 210,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "argoai/argoverse-api",
    "source_filename": "tests/test_frustum_clipping.py",
    "target_filename": "tests/test_frustum_clipping.py",
    "source_changeid": "c8ff45fb6a50e0a6e1f1355a9ce9aafdfa8dfcf3^",
    "target_changeid": "c8ff45fb6a50e0a6e1f1355a9ce9aafdfa8dfcf3",
    "predictions": [
      "fx = 10.0 \n img_height = 40 \n top_plane = form_top_clipping_plane(fx, img_height) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "fx = 10.0 \n img_height = 40 \n top_plane = form_top_clipping_plane(fx, img_height) \n",
      "1": "fx = 10.0 \n img_height = 45 \n top_plane = form_top_clipping_plane(fx, img_height) \n",
      "2": "fx = 10.0 \n img_height = 45.0 \n top_plane = form_top_clipping_plane(fx, int(img_height)) \n",
      "3": "fx = 10.0 \n img_height = 40 \n top_plane = form_top_clipping_plane(fx, int(img_height)) \n",
      "4": "fx = 10.0 \n img_height = 45.0 \n top_plane = form_top_clipping_plane(fx, img_height) \n"
    }
  },
  {
    "source_code": "            for filename in filenames:\n                <IND>path = self._get_config_file_path(filename)\n",
    "target_code": "            for filename in filenames:\n                <IND>assert isinstance(filename, str)\n                path = self._get_config_file_path(filename)\n",
    "warning_line": "                path = self._get_config_file_path(filename)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Optional[str]` for 1st positional only parameter to call `Station._get_config_file_path` but got `List[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 356,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "QCoDeS/Qcodes",
    "source_filename": "qcodes/station.py",
    "target_filename": "qcodes/station.py",
    "source_changeid": "5981d9cc37ea0abbcecd0153a884fe8a80cd573e^",
    "target_changeid": "5981d9cc37ea0abbcecd0153a884fe8a80cd573e",
    "predictions": [
      "for filename in filenames: \n <IND> assert filename is not None \n path = self._get_config_file_path(filename) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "for filename in filenames: \n <IND> assert filename is not None \n path = self._get_config_file_path(filename) \n",
      "1": "for filename in filenames: \n <IND> assert filename is not None \n filename = self._get_config_file_path(filename) \n",
      "2": "for filename in filenames: \n <IND> assert filename is not None, filename = self._get_config_file_path(filename) \n assert filename is not None \n path = self._get_config_file_path(filename) \n",
      "3": "for filename in filenames: \n <IND> str = self._get_config_file_path(filename) \n",
      "4": "for filename in filenames: \n <IND> assert filename is not None, filename = self._get_config_file_path(filename) \n assert filename is not None \n return self._get_config_file_path(filename) \n"
    }
  },
  {
    "source_code": "    <IND>for ms in get_all_players(var, (\"mad scientist\",)):\n        <IND>pl = get_players(var)\n        target1, target2 = _get_targets(var, pl, ms)\n",
    "target_code": "    <IND>for ms in get_all_players(var, (\"mad scientist\",)):\n        <IND>pl = get_all_players(var)\n        target1, target2 = _get_targets(var, pl, ms)\n",
    "warning_line": "        target1, target2 = _get_targets(var, pl, ms)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Set[User]` for 2nd positional only parameter to call `_get_targets` but got `typing.List[User]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 88,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "lykoss/lykos",
    "source_filename": "src/roles/madscientist.py",
    "target_filename": "src/roles/madscientist.py",
    "source_changeid": "3b3870c9f365944134225c5b7364430c5bce0158^",
    "target_changeid": "3b3870c9f365944134225c5b7364430c5bce0158",
    "predictions": [
      "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, pl, ms) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, pl, ms) \n",
      "1": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, ms) \n",
      "2": "<DED> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, pl, ms) \n",
      "3": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = set(_get_targets(var, pl, ms)) \n",
      "4": "<IND> for ms in get_all_players(var, (\"mad scientist\",)): \n <IND> pl = get_players(var) \n target1, target2 = _get_targets(var, _get_targets(var, pl, ms) \n"
    }
  },
  {
    "source_code": "        for component in self.pipeline:\n            <IND>args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config)\n            updates = component.pipeline_init(*args)\n",
    "target_code": "        for component in self.pipeline:\n            <IND>args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config.as_dict())\n            updates = component.pipeline_init(*args)\n",
    "warning_line": "            args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Dict[str, typing.Any]` for 3rd positional only parameter to call `rasa_nlu.components.fill_args` but got `RasaNLUConfig`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 175,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "RasaHQ/rasa",
    "source_filename": "rasa_nlu/model.py",
    "target_filename": "rasa_nlu/model.py",
    "source_changeid": "f55804e5cc46f21d73e82374a57f71a48a24fb12^",
    "target_changeid": "f55804e5cc46f21d73e82374a57f71a48a24fb12",
    "predictions": [
      "for component in self.pipeline: \n <IND> args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config.as_dict()) \n updates = component.pipeline_init(*args) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "for component in self.pipeline: \n <IND> args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config.as_dict()) \n updates = component.pipeline_init(*args) \n",
      "1": "for component in self.pipeline: \n <IND> args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config.args) \n updates = component.pipeline_init(*args) \n",
      "2": "for component in self.pipeline: \n <IND> args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config._dict()) \n updates = component.pipeline_init(*args) \n",
      "3": "for component in self.pipeline: \n <IND> args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config._dict) \n updates = component.pipeline_init(*args) \n",
      "4": "for component in self.pipeline: \n <IND> args = rasa_nlu.components.fill_args(component.pipeline_init_args(), context, self.config.str()) \n updates = component.pipeline_init(*args) \n"
    }
  },
  {
    "source_code": "        file_suffix='_medium_expert-v1',\n        step_metadata_keys=set([_QPOS, _QVEL, _ACTION_LOG_PROBS]),\n    ),\n",
    "target_code": "        file_suffix='_medium_expert-v1',\n        step_metadata_keys=frozenset([_QPOS, _QVEL, _ACTION_LOG_PROBS]),\n    ),\n",
    "warning_line": "        step_metadata_keys=set([_QPOS, _QVEL, _ACTION_LOG_PROBS]),",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `frozenset[str]` for 5th parameter `step_metadata_keys` to call `BuilderConfig.__init__` but got `typing.Set[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 149,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/datasets",
    "source_filename": "tensorflow_datasets/d4rl/dataset_builder.py",
    "target_filename": "tensorflow_datasets/d4rl/dataset_builder.py",
    "source_changeid": "4dbf2d78a44eccfcdf46fb8e15681cda8c0b144f^",
    "target_changeid": "4dbf2d78a44eccfcdf46fb8e15681cda8c0b144f",
    "predictions": [
      "file_suffix='_medium_expert-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ACTION_LOG_PROBS]), \n ), \n"
    ],
    "correct": true,
    "top_five": {
      "0": "file_suffix='_medium_expert-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ACTION_LOG_PROBS]), \n ), \n",
      "1": "file_suffix='_medium_expert-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ACTION_LOG_PROBS]), \n has_policy_metadata=True, \n",
      "2": "file_suffix='_medium_expert-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL], _ACTION_LOG_PROBS]), \n ), \n",
      "3": "file_suffix='_medium_expert-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ACTION_LOG_PROBS]), \n ) \n",
      "4": "file_suffix='_medium_expert-v1', \n step_metadata_keys=frozenset([_QPOS, _QVEL, _ACTION_LOG_PROBS]), \n ), \n has_policy_metadata=True, \n"
    }
  },
  {
    "source_code": "        <IND>restored = cls(\n            expiration=int(data['expiration']),\n            balance_proof=data['balance_proof'],\n",
    "target_code": "        <IND>restored = cls(\n            expiration=BlockExpiration(int(data['expiration'])),\n            balance_proof=data['balance_proof'],\n",
    "warning_line": "            expiration=int(data['expiration']),",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `BlockExpiration` for 1st parameter `expiration` to call `ContractSendChannelUpdateTransfer.__init__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 231,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/events.py",
    "target_filename": "raiden/transfer/events.py",
    "source_changeid": "e349c2aa42059e125df2aba9bcf1bfc9e6668277^",
    "target_changeid": "e349c2aa42059e125df2aba9bcf1bfc9e6668277",
    "predictions": [
      "<IND> restored = cls( \n expiration=BlockExpiration(int(data['expiration'])), \n balance_proof=data['balance_proof'], \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> restored = cls( \n expiration=BlockExpiration(int(data['expiration'])), \n balance_proof=data['balance_proof'], \n",
      "1": "<DED> restored = cls( \n expiration=BlockExpiration(int(data['expiration'])), \n balance_proof=data['balance_proof'], \n",
      "2": "\n restored = cls( \n expiration=BlockExpiration(int(data['expiration'])), \n balance_proof=data['balance_proof'], \n",
      "3": "<IND> restored = cls( \n expiration=BlockExpiration(data['expiration']), \n balance_proof=data['balance_proof'], \n",
      "4": "<IND> restored = cls( \n expiration=Data['expiration'], \n balance_proof=data['balance_proof'], \n"
    }
  },
  {
    "source_code": "\n        <DED><DED>return Interpreter(self.pipeline, context=init_context, config=self.config)\n\n",
    "target_code": "\n        <DED><DED>return Interpreter(self.pipeline, context=init_context, config=self.config.as_dict())\n\n",
    "warning_line": "        return Interpreter(self.pipeline, context=init_context, config=self.config)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Dict[str, typing.Any]` for 3rd parameter `config` to call `Interpreter.__init__` but got `RasaNLUConfig`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 190,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "crownpku/Rasa_NLU_Chi",
    "source_filename": "rasa_nlu/model.py",
    "target_filename": "rasa_nlu/model.py",
    "source_changeid": "f55804e5cc46f21d73e82374a57f71a48a24fb12^",
    "target_changeid": "f55804e5cc46f21d73e82374a57f71a48a24fb12",
    "predictions": [
      "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config) \n \n",
      "1": "\n <DED> <DED> return Interpreter(self.pipeline, context=Init_context, config=self.config) \n \n",
      "2": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config, 0) \n \n",
      "3": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config) \n <DED>",
      "4": "\n <DED> <DED> return Interpreter(self.pipeline, context=init_context, config=self.config).decode() \n \n"
    }
  },
  {
    "source_code": "\n                        if isinstance(loss, Tuple):\n                            <IND>average_over += loss[1]\n",
    "target_code": "\n                        if isinstance(loss, tuple):\n                            <IND>average_over += loss[1]\n",
    "warning_line": "                        if isinstance(loss, Tuple):",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Union[typing.Type[typing.Any], typing.Tuple[typing.Type[typing.Any], ...]]` for 2nd positional only parameter to call `isinstance` but got `typing._SpecialForm`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 472,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "flairNLP/flair",
    "source_filename": "flair/trainers/trainer.py",
    "target_filename": "flair/trainers/trainer.py",
    "source_changeid": "61d62a046c45382bc4a016e1acd88959c95f3054^",
    "target_changeid": "61d62a046c45382bc4a016e1acd88959c95f3054",
    "predictions": [
      "\n if isinstance(loss, tuple): \n <IND> average_over += loss[1] \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n if isinstance(loss, tuple): \n <IND> average_over += loss[1] \n",
      "1": "\n if isinstance(loss, Tuple): \n <IND> average_over += loss[1] \n",
      "2": "\n if isinstance(loss, Optional[Tuple]): \n <IND> average_over += loss[1] \n",
      "3": "\n if isinstance(loss, Tuple): \n <IND> average_over += loss[1] \n",
      "4": "\n if isinstance(loss, tuple): \n <IND> average_over += tuple[1] \n"
    }
  },
  {
    "source_code": "        for idx, conf in enumerate(softmax):\n            <IND>label_probs.append(Label(idx, conf.item()))\n        <DED>return label_probs\n",
    "target_code": "        for idx, conf in enumerate(softmax):\n            <IND>label_probs.append(Label(str(idx), conf.item()))\n        <DED>return label_probs\n",
    "warning_line": "            label_probs.append(Label(idx, conf.item()))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `Label.__init__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 488,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "flairNLP/flair",
    "source_filename": "flair/models/diagnosis/distance_prediction_model.py",
    "target_filename": "flair/models/diagnosis/distance_prediction_model.py",
    "source_changeid": "4ac18961c3c85b54f0fb5c4f2ea82fc0a4471402^",
    "target_changeid": "4ac18961c3c85b54f0fb5c4f2ea82fc0a4471402",
    "predictions": [
      "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, conf.item())) \n <DED> return label_probs \n"
    ],
    "correct": false,
    "top_five": {
      "0": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, conf.item())) \n <DED> return label_probs \n",
      "1": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, str(conf.item()))) \n <DED> return label_probs \n",
      "2": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Str(Label(idx, conf.item()))) \n <DED> return label_probs \n",
      "3": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Label(idx, conf.item())) \n <IND> return label_probs \n",
      "4": "for idx, conf in enumerate(softmax): \n <IND> label_probs.append(Int(Label(idx, conf.item()))) \n <DED> return label_probs \n"
    }
  },
  {
    "source_code": "    <DED>else:\n        <IND>fallback_entry_point = next(entry_points)\n        run = fallback_entry_point.load()\n",
    "target_code": "    <DED>else:\n        <IND>fallback_entry_point = next(iter(entry_points))\n        run = fallback_entry_point.load()\n",
    "warning_line": "        fallback_entry_point = next(entry_points)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Iterator[Variable[_T]]` for 1st positional only parameter to call `next` but got `List[typing.Any]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 559,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "samschott/maestral",
    "source_filename": "maestral/cli.py",
    "target_filename": "maestral/cli.py",
    "source_changeid": "79e5f46885de75b022513de6598e8baf4ea66f97^",
    "target_changeid": "79e5f46885de75b022513de6598e8baf4ea66f97",
    "predictions": [
      "<DED> else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n",
      "1": "<DED> else: \n <IND> next() \n fallback_entry_point = next(entry_points) \n run = fallback_entry_point.load() \n",
      "2": "<DED> else: \n <IND> next(entry_point) \n run = fallback_entry_point.load() \n",
      "3": "<IND> else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n",
      "4": "\n else: \n <IND> next(entry_points) \n run = fallback_entry_point.load() \n"
    }
  },
  {
    "source_code": "                        self.degree - num_fanout_peers_in_topic,\n                        self.fanout[topic],\n                    )\n                    # Add the peers to fanout[topic]\n                    self.fanout[topic].Update(selected_peers)\n\n",
    "target_code": "                        self.degree - num_fanout_peers_in_topic,\n                        list(self.fanout[topic]),\n                    )\n                    # Add the peers to fanout[topic]\n                    self.fanout[topic].update(selected_peers)\n\n",
    "warning_line": "                        self.fanout[topic],",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `Sequence[ID]` for 3rd positional only parameter to call `GossipSub._get_in_topic_gossipsub_peers_from_minus` but got `Set[ID]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 473,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "libp2p/py-libp2p",
    "source_filename": "libp2p/pubsub/gossipsub.py",
    "target_filename": "libp2p/pubsub/gossipsub.py",
    "source_changeid": "b4bd997932ff5ee78a7f4f3c63e7e5cf1dddc397^",
    "target_changeid": "b4bd997932ff5ee78a7f4f3c63e7e5cf1dddc397",
    "predictions": [
      "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to fanout[topic], \n self.fanout[topic].Update(selected_peers) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to fanout[topic], \n self.fanout[topic].Update(selected_peers) \n \n",
      "1": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to fanout[topic] \n self.fanout[topic].Update(selected_peers) \n \n",
      "2": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic]: \n ) \n # Add the peers to fanout[topic] \n self.fanout[topic].Update(selected_peers) \n \n",
      "3": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to self.fanout[topic], \n self.fanout[topic].Update(selected_peers) \n \n",
      "4": "self.degree - num_fanout_peers_in_topic, \n self.fanout[topic], \n ) \n # Add the peers to self.fanout[topic].Update(selected_peers) \n \n"
    }
  },
  {
    "source_code": "\n                new = Or(new, key_argument != index_argument)\n\n",
    "target_code": "\n                new = Or(new, cast(Bool, key_argument != index_argument))\n\n",
    "warning_line": "                new = Or(new, key_argument != index_argument)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `mythril.laser.smt.bool.Bool` for 2nd positional only parameter to call `mythril.laser.smt.bool.Or` but got `bool`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1374,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ConsenSys/mythril",
    "source_filename": "mythril/laser/ethereum/instructions.py",
    "target_filename": "mythril/laser/ethereum/instructions.py",
    "source_changeid": "b2b21431cd255c33fed711aee2d1d749b3968474^",
    "target_changeid": "b2b21431cd255c33fed711aee2d1d749b3968474",
    "predictions": [
      "\n new = Or(new, key_argument!= index_argument) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n new = Or(new, key_argument!= index_argument) \n \n",
      "1": "\n assert key_argument is not None \n new = Or(new, key_argument!= index_argument) \n \n",
      "2": "\n bool = Or(new, key_argument!= index_argument) \n \n",
      "3": "\n new_argument = Or(new, key_argument!= index_argument) \n \n",
      "4": "\n or(new, key_argument!= index_argument) \n \n"
    }
  },
  {
    "source_code": "        file_suffix='-expert-v1',\n        step_metadata_keys=set(\n            [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]),\n        episode_metadata_keys=set([_ALGORITHM]),\n        has_policy_metadata=True,\n",
    "target_code": "        file_suffix='-expert-v1',\n        step_metadata_keys=frozenset(\n            [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]),\n        episode_metadata_keys=frozenset([_ALGORITHM]),\n        has_policy_metadata=True,\n",
    "warning_line": "        step_metadata_keys=set(",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `frozenset[str]` for 5th parameter `step_metadata_keys` to call `BuilderConfig.__init__` but got `typing.Set[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 275,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/datasets",
    "source_filename": "tensorflow_datasets/d4rl/dataset_builder.py",
    "target_filename": "tensorflow_datasets/d4rl/dataset_builder.py",
    "source_changeid": "4dbf2d78a44eccfcdf46fb8e15681cda8c0b144f^",
    "target_changeid": "4dbf2d78a44eccfcdf46fb8e15681cda8c0b144f",
    "predictions": [
      "file_suffix='-expert-v1', \n step_metadata_keys=frozenset( \n [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]), \n episode_metadata_keys=frozenset([_ALGORITHM]), \n has_policy_metadata=True, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "file_suffix='-expert-v1', \n step_metadata_keys=frozenset( \n [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]), \n episode_metadata_keys=frozenset([_ALGORITHM]), \n has_policy_metadata=True, \n",
      "1": "file_suffix='-expert-v1', \n step_metadata_keys=frozenset( \n [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]), \n episode_metadata_keys=frozenset([_ALGORITHM], \n has_policy_metadata=True, \n",
      "2": "file_suffix='-expert-v1', \n step_metadata_keys=frozenset( \n [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]), \n episode_metadata_keys=frozenset([_ALGORITHM]), \n has_policy_metadata=True, \n has_policy_metadata=True, \n",
      "3": "file_suffix='-expert-v1', \n step_metadata_keys=frozenset( \n [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]), \n episode_metadata_keys=frozenset([_ALGORITHM]), \n has_policy_metadata=True, \n ), \n",
      "4": "file_suffix='-expert-v1', \n step_metadata_keys=frozenset( <DED> [_QPOS, _QVEL, _ADROIT_BODY_POS, _ACTION_MEAN, _ACTION_LOG_STD]), \n episode_metadata_keys=frozenset([_ALGORITHM]), \n has_policy_metadata=True, \n"
    }
  },
  {
    "source_code": "                        <IND>physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        layer = context.memory[physical_layer]\n",
    "target_code": "                        <IND>physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path)\n                        if not isinstance(physical_layer, str):\n                            <IND>raise ValueError(\"Physical Layer configuration must be a string\")\n                        <DED>layer = context.memory[physical_layer]\n",
    "warning_line": "                        layer = context.memory[physical_layer]",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `interfaces.layers.Memory.__getitem__` but got `typing.Union[typing.List[typing.Union[bool, bytes, int, str]], bool, bytes, int, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 168,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "volatilityfoundation/volatility3",
    "source_filename": "volatility/framework/automagic/nlpdtbfinder.py",
    "target_filename": "volatility/framework/automagic/nlpdtbfinder.py",
    "source_changeid": "113c23a66d4bf391eb2e1d1e6bafaa7673e7ce55^",
    "target_changeid": "113c23a66d4bf391eb2e1d1e6bafaa7673e7ce55",
    "predictions": [
      "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n",
      "1": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert physical_layer is not None \n layer = context.memory[physical_layer] \n",
      "2": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, bool, bytes, int, str) \n layer = context.memory[physical_layer] \n",
      "3": "<IND> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n",
      "4": "<DED> physical_layer = requirement.requirements[\"memory_layer\"].config_value(context, sub_config_path) \n assert isinstance(physical_layer, str) \n layer = context.memory[physical_layer] \n"
    }
  },
  {
    "source_code": "    <DED>try:\n        <IND>SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ.get(\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"))\n    <DED>except (ValueError, TypeError):\n",
    "target_code": "    <DED>try:\n        <IND>SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(\n            os.environ.get(\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\", 1)\n        )\n    <DED>except (ValueError, TypeError):\n",
    "warning_line": "        SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ.get(\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Union[bytearray, bytes, str, typing.SupportsFloat, typing_extensions.SupportsIndex]` for 1st positional only parameter to call `float.__new__` but got `Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 63,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "smallwat3r/shhh",
    "source_filename": "shhh/config.py",
    "target_filename": "shhh/config.py",
    "source_changeid": "9687d92934b4256ef5dd0489c1b0b714466fa05a^",
    "target_changeid": "9687d92934b4256ef5dd0489c1b0b714466fa05a",
    "predictions": [
      "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"]) \n <DED> except (ValueError, TypeError): \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"]) \n <DED> except (ValueError, TypeError): \n",
      "1": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\") \n <DED> except (ValueError, TypeError): \n",
      "2": "<DED> try: \n <IND> assert isinstance(bytearray, str) \n SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\") \n <DED> except (ValueError, TypeError): \n",
      "3": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float((os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\")) \n <DED> except (ValueError, TypeError): \n",
      "4": "<DED> try: \n <IND> SHHH_DB_LIVENESS_SLEEP_INTERVAL = float(os.environ[\"SHHH_DB_LIVENESS_SLEEP_INTERVAL\"], float) \n <DED> except (ValueError, TypeError): \n"
    }
  },
  {
    "source_code": "        <IND>yaml.safe_dump(config_data, f)\n    <DED>shutil.move(path.with_suffix(\".\" + str(os.getpid())), path)\n\n",
    "target_code": "        <IND>yaml.safe_dump(config_data, f)\n    <DED>shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), path)\n\n",
    "warning_line": "    shutil.move(path.with_suffix(\".\" + str(os.getpid())), path)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `str` for 1st positional only parameter to call `shutil.move` but got `Path`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 40,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Flax-Network/flax-blockchain",
    "source_filename": "src/util/config.py",
    "target_filename": "src/util/config.py",
    "source_changeid": "05d6658eeb85d62859ca27fae2a150135066b2f3^",
    "target_changeid": "05d6658eeb85d62859ca27fae2a150135066b2f3",
    "predictions": [
      "<IND> yaml.safe_dump(config_data, f) \n <DED> shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), path) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> yaml.safe_dump(config_data, f) \n <DED> shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), path) \n \n",
      "1": "<IND> yaml.safe_dump(config_data, f) \n <DED> shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), str) \n \n",
      "2": "<IND> yaml.safe_dump(config_data, f) \n <IND> shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), path) \n \n",
      "3": "<IND> yaml.safe_dump(config_data, f) \n \n shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), path) \n \n",
      "4": "<IND> yaml.safe_dump(config_data, f) \n <DED> shutil.move(str(path.with_suffix(\".\" + str(os.getpid()))), os.path) \n \n"
    }
  },
  {
    "source_code": "                    <IND>self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i in range(len(texts)):\n                        <IND>if i == len(out):\n                            <IND>out.append(self._doc_to_out(None, only_cui, addl_info))\n                        <DED>elif out[i]['text'] != texts[i]:\n                            <IND>out.insert(i, self._doc_to_out(None, only_cui, addl_info))\n",
    "target_code": "                    <IND>self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\")\n                    for i, text in enumerate(texts):\n                        <IND>if i == len(out):\n                            <IND>out.append(self._doc_to_out(None, only_cui, addl_info))\n                        <DED>elif out[i]['text'] != text:\n                            <IND>out.insert(i, self._doc_to_out(None, only_cui, addl_info))\n",
    "warning_line": "                    for i in range(len(texts)):",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Union[Iterable[str], Iterable[typing.Tuple[typing.Any, ...]]]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 757,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "CogStack/MedCAT",
    "source_filename": "medcat/cat.py",
    "target_filename": "medcat/cat.py",
    "source_changeid": "ed2ec9365b688b0e890652e5410c2065075eb986^",
    "target_changeid": "ed2ec9365b688b0e890652e5410c2065075eb986",
    "predictions": [
      "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= out[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= out[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n",
      "1": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n",
      "2": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(str(len(out))): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)) \n",
      "3": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> if i == len(out): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui, addl_info)",
      "4": "<IND> self.log.warning(\"Found at least one failed batch and set output for enclosed texts to empty\") \n for i in range(len(out)): \n <IND> if i == len(out): \n <IND> out.append(self._doc_to_out(None, only_cui, addl_info)) \n <DED> elif out[i]['text']!= texts[i]: \n <IND> out.insert(i, self._doc_to_out(None, only_cui"
    }
  },
  {
    "source_code": "            expiration=int(data['expiration']),\n            channel_identifier=int(data['channel_identifier']),\n            token_network_identifier=to_canonical_address(data['token_network_identifier']),\n",
    "target_code": "            expiration=int(data['expiration']),\n            channel_identifier=typing.ChannelID(int(data['channel_identifier'])),\n            token_network_identifier=to_canonical_address(data['token_network_identifier']),\n",
    "warning_line": "            channel_identifier=int(data['channel_identifier']),",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.ChannelID` for 2nd parameter `channel_identifier` to call `ContractSendChannelUpdateTransfer.__init__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 181,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "raiden-network/raiden",
    "source_filename": "raiden/transfer/events.py",
    "target_filename": "raiden/transfer/events.py",
    "source_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82^",
    "target_changeid": "fa631411cdd181edf375f603d1ecec3d025f1c82",
    "predictions": [
      "expiration=int(data['expiration']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n token_network_identifier=to_canonical_address(data['token_network_identifier']), \n"
    ],
    "correct": true,
    "top_five": {
      "0": "expiration=int(data['expiration']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n token_network_identifier=to_canonical_address(data['token_network_identifier']), \n",
      "1": "expiration=int(data['expiration']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n token_network_identifier=to_canonical_address(data['token_network_identifier'])), \n",
      "2": "expiration=int(data['expiration']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n token_network_identifier=typing.TokenNetworkID(to_canonical_address(data['token_network_identifier'])), \n",
      "3": "expiration=int(data['expiration']), <DED> channel_identifier=typing.ChannelID(int(data['channel_identifier'])), \n token_network_identifier=to_canonical_address(data['token_network_identifier']), \n",
      "4": "expiration=int(data['expiration']), \n channel_identifier=typing.ChannelID(int(data['channel_identifier'])), <DED> token_network_identifier=to_canonical_address(data['token_network_identifier']), \n"
    }
  },
  {
    "source_code": "            xp = get_array_module(tensors)\n            scores = xp.zeros((len(docs), len(self.labels)))\n            return scores\n",
    "target_code": "            xp = get_array_module(tensors)\n            scores = xp.zeros((len(list(docs)), len(self.labels)))\n            return scores\n",
    "warning_line": "            scores = xp.zeros((len(docs), len(self.labels)))",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `typing.Sized` for 1st positional only parameter to call `len` but got `Iterable[spacy.tokens.doc.Doc]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 156,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "explosion/spaCy",
    "source_filename": "spacy/pipeline/textcat.py",
    "target_filename": "spacy/pipeline/textcat.py",
    "source_changeid": "657af5f91f88bb5a414ae133a99465dbc4f240be^",
    "target_changeid": "657af5f91f88bb5a414ae133a99465dbc4f240be",
    "predictions": [
      "xp = get_array_module(tensors) \n scores = xp.zeros((len(docs), len(self.labels))) \n return scores \n"
    ],
    "correct": false,
    "top_five": {
      "0": "xp = get_array_module(tensors) \n scores = xp.zeros((len(docs), len(self.labels))) \n return scores \n",
      "1": "xp = get_array_module(tensors) \n scores = xp.zeros((len(docs), len(self.labels.Tokens.doc.Doc))) \n return scores \n",
      "2": "xp = get_array_module(tensors) \n scores = xp.zeros((str(len(docs), str(len(self.labels)))) \n return scores \n",
      "3": "xp = get_array_module(tensors) \n scores = xp.zeros((str(len(docs), len(self.labels.Tokens.doc.Doc)))) \n return scores \n",
      "4": "xp = get_array_module(tensors) \n scores = xp.zeros((str(len(docs), str(len(self.labels.tokens.doc.Doc)))) \n return scores \n"
    }
  },
  {
    "source_code": "    <IND>rk = len(shape)\n    strides = [None, ] * rk\n    strides[0] = itemsize\n    for i in range(1, rk):\n        <IND>strides[i] = shape[i-1] * strides[i-1]\n    <DED>return tuple(strides)\n",
    "target_code": "    <IND>rk = len(shape)\n    strides = [itemsize, ]\n    for i in range(1, rk):\n        <IND>strides.append(shape[i-1] * strides[i-1])\n    <DED>return tuple(strides)\n",
    "warning_line": "    strides[0] = itemsize",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `None` for 2nd positional only parameter to call `list.__setitem__` but got `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 32,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "rpy2/rpy2",
    "source_filename": "rpy2/rinterface_lib/bufferprotocol.py",
    "target_filename": "rpy2/rinterface_lib/bufferprotocol.py",
    "source_changeid": "206272f376fc31ecca831db466678d42d5cc8cfd^",
    "target_changeid": "206272f376fc31ecca831db466678d42d5cc8cfd",
    "predictions": [
      "<IND> rk = len(shape) \n strides = [itemsize, ] \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> rk = len(shape) \n strides = [itemsize, ] \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "1": "<IND> rk = len(shape) \n strides = [itemsize, ] \n for i in range(1, rk): \n <IND> strides = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "2": "<IND> rk = len(shape) \n strides = [itemsize, ] * rk \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "3": "<IND> rk = len(shape) \n strides = [itemsize, ] * strides[0] \n for i in range(1, rk): \n <IND> strides[i] = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n",
      "4": "<IND> rk = len(shape) \n strides = [itemsize, ] * rk \n for i in range(1, rk): \n <IND> strides = shape[i-1] * strides[i-1] \n <DED> return tuple(strides) \n"
    }
  },
  {
    "source_code": "        initializer: InitializerApplicator = InitializerApplicator(),\n        regularizer: Optional[RegularizerApplicator] = None,\n    ) -> None:\n        <IND>super().__init__(vocab, regularizer)\n\n",
    "target_code": "        initializer: InitializerApplicator = InitializerApplicator(),\n        **kwargs\n    ) -> None:\n        <IND>super().__init__(vocab, **kwargs)\n\n",
    "warning_line": "        super().__init__(vocab, regularizer)",
    "linter_report": {
      "rule_id": "Incompatible parameter type [6]",
      "message": " Expected `allennlp.nn.regularizers.regularizer_applicator.RegularizerApplicator` for 2nd positional only parameter to call `Model.__init__` but got `Optional[allennlp.nn.regularizers.regularizer_applicator.RegularizerApplicator]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 79,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "allenai/allennlp",
    "source_filename": "allennlp/models/coreference_resolution/coref.py",
    "target_filename": "allennlp/models/coreference_resolution/coref.py",
    "source_changeid": "700abc65fd2172a2c6809dd9b72cf50fc2407772^",
    "target_changeid": "700abc65fd2172a2c6809dd9b72cf50fc2407772",
    "predictions": [
      "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, reg_applicator) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, reg_applicator) \n \n",
      "1": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, regex) \n \n",
      "2": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, reg_applicator) \n \n",
      "3": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, regularizer) \n \n",
      "4": "initializer: InitializerApplicator = InitializerApplicator(), \n regularizer: Optional[RegularizerApplicator] = None, \n ) -> None: \n <IND> super().__init__(vocab, regularizer) \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    name: ormar.String(max_length=40)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n",
    "warning_line": "    name: ormar.String(max_length=40)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.String($parameter$max_length = 40)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 27,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "docs_src/relations/docs002.py",
    "target_filename": "docs_src/relations/docs002.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "3": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n <DED>",
      "4": "<DED> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n"
    }
  },
  {
    "source_code": "\ndef rsafactor(d: int, e: int, N: int) -> [int]:\n    <IND>",
    "target_code": "\ndef rsafactor(d: int, e: int, N: int) -> list[int]:\n    <IND>",
    "warning_line": "def rsafactor(d: int, e: int, N: int) -> [int]:",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `[int]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 16,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "TheAlgorithms/Python",
    "source_filename": "ciphers/rsa_factorization.py",
    "target_filename": "ciphers/rsa_factorization.py",
    "source_changeid": "60895366c0f50844af2737130ed98c2510e90060^",
    "target_changeid": "60895366c0f50844af2737130ed98c2510e90060",
    "predictions": [
      "\n def rsafactor(d: int, e: int, N: int) -> str: \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n def rsafactor(d: int, e: int, N: int) -> str: \n <IND>",
      "1": "\n def rsafactor(d: int, e: int, N: int) -> List[int]: \n <IND>",
      "2": "\n def rsafactor(d: int, e: int, N: int): \n <IND>",
      "3": "\n def rsafactor(d: int, e: int, N: int) -> int: \n <IND>",
      "4": "\n def rsafactor(d: int, e: int, N: int) -> List[int]: \n <DED>"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    album: ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title: ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    album = ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title = ormar.String(max_length=100)\n\n",
    "warning_line": "    title: ormar.String(max_length=100)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.String($parameter$max_length = 100)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 43,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_foreign_keys.py",
    "target_filename": "tests/test_foreign_keys.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "2": "\n <DED> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "3": "\n \n id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "4": "<DED> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": " <DED><DED>@db_error_default(list())\n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List(Stream):\n  # Not the best combination of options, but it's only the usage needed\n",
    "target_code": " <DED><DED>@db_error_default(list())\n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List[Stream]:\n  # Not the best combination of options, but it's only the usage needed\n",
    "warning_line": "\tdef get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List(Stream):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.List(src.data.models.Stream)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 222,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "r-anime/holo",
    "source_filename": "src/data/database.py",
    "target_filename": "src/data/database.py",
    "source_changeid": "92dbaf41501b2e2ceb2138881ee1c437d97562bd^",
    "target_changeid": "92dbaf41501b2e2ceb2138881ee1c437d97562bd",
    "predictions": [
      "<DED> <DED> @db_error_default(list()) \n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List[Stream]: \n # Not the best combination of options, but it's only the usage needed \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> <DED> @db_error_default(list()) \n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List[Stream]: \n # Not the best combination of options, but it's only the usage needed \n",
      "1": "<DED> <DED> @db_error_default(list()) \n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List[Stream]: \n # Not the best combination of options, but it' \n",
      "2": "<DED> <DED> @db_error_default(list()) \n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List[Stream]: \n # Not the best combination of options, but it' <DED> only the usage needed \n",
      "3": "<DED> <DED> @db_error_default(list()) \n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> List[Stream]: \n # Not the best combination of options, but it' <IND> only the usage needed \n",
      "4": "<DED> <DED> @db_error_default(list()) \n def get_streams(self, service=None, show=None, active=True, unmatched=False, missing_name=False) -> str: \n # Not the best combination of options, but it's only the usage needed \n"
    }
  },
  {
    "source_code": "\n<DED>def array_to_json(array_like):  # type: (np.array or Iterable or int or float) -> str\n    <IND>",
    "target_code": "\n<DED>def array_to_json(array_like):\n    <IND>",
    "warning_line": "def array_to_json(array_like):  # type: (np.array or Iterable or int or float) -> str",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `\"numpy.array or typing.Iterable or int or float\"` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 61,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "aws/sagemaker-training-toolkit",
    "source_filename": "src/sagemaker_training/encoders.py",
    "target_filename": "src/sagemaker_training/encoders.py",
    "source_changeid": "8281b567dbf848c4482be78c4b009e9a619d081c^",
    "target_changeid": "8281b567dbf848c4482be78c4b009e9a619d081c",
    "predictions": [
      "\n <DED> def array_to_json(array_like): \n <IND>"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> def array_to_json(array_like): \n <IND>",
      "1": "\n <IND> def array_to_json(array_like): \n <IND>",
      "2": "\n <DED> def array_to_json(array_like): \n <DED>",
      "3": "\n <DED> def array_to_json(array_like): \n \n",
      "4": "\n \n def array_to_json(array_like): \n <IND>"
    }
  },
  {
    "source_code": "\ndef rectangular_kernel1d(kernel_size: int) -> (tf.Tensor, tf.Tensor):\n    <IND>",
    "target_code": "\ndef rectangular_kernel1d(kernel_size: int) -> tf.Tensor:\n    <IND>",
    "warning_line": "def rectangular_kernel1d(kernel_size: int) -> (tf.Tensor, tf.Tensor):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `(tensorflow.Tensor, tensorflow.Tensor)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 33,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "DeepRegNet/DeepReg",
    "source_filename": "deepreg/loss/util.py",
    "target_filename": "deepreg/loss/util.py",
    "source_changeid": "8ce52504574ad8e6f26ef354984f89bf70ab6863^",
    "target_changeid": "8ce52504574ad8e6f26ef354984f89bf70ab6863",
    "predictions": [
      "\n def rectangular_kernel1d(kernel_size: int) -> tf.Tensor: \n <IND>"
    ],
    "correct": true,
    "top_five": {
      "0": "\n def rectangular_kernel1d(kernel_size: int) -> tf.Tensor: \n <IND>",
      "1": "\n def rectangular_kernel1d(kernel_size: int) -> str(tf.Tensor, tf.Tensor): \n <IND>",
      "2": "\n def rectangular_kernel1d(kernel_size: tf.Tensor) -> tf.Tensor: \n <IND>",
      "3": "\n def rectangular_kernel1d(kernel_size: int) -> TENSOR: \n <IND>",
      "4": "\n def rectangular_kernel1d(kernel_size: int) -> tf.Tensor: \n <DED>"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    name: ormar.String(max_length=100)\n    completed: ormar.Boolean(default=False)\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n    completed= ormar.Boolean(default=False)\n",
    "warning_line": "    id: ormar.Integer(primary_key=True)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.Integer($parameter$primary_key = True)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 18,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "docs_src/models/docs002.py",
    "target_filename": "docs_src/models/docs002.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n",
      "3": "<DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n",
      "4": "<IND> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    name: ormar.String(max_length=100)\n    completed: ormar.Boolean(default=False)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n    completed= ormar.Boolean(default=False)\n\n",
    "warning_line": "    name: ormar.String(max_length=100)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.String($parameter$max_length = 100)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 16,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "docs_src/models/docs004.py",
    "target_filename": "docs_src/models/docs004.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n \n",
      "3": "<DED> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n \n",
      "4": "<IND> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n completed= ormar.Boolean(default=False) \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    name: ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n\n",
    "warning_line": "    name: ormar.String(max_length=100)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.String($parameter$max_length = 100)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 16,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "docs_src/fields/docs001.py",
    "target_filename": "docs_src/fields/docs001.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "3": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n <DED>",
      "4": "<DED> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": "        # order as it was added.\n        self.data = collections.OrderedDict()  # type: typing.Dict[RunKey: RunValue]\n\n",
    "target_code": "        # order as it was added.\n        self.data = collections.OrderedDict()  # type: typing.Dict[RunKey, RunValue]\n\n",
    "warning_line": "        self.data = collections.OrderedDict()  # type: typing.Dict[RunKey: RunValue]",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.Dict[slice($local_smac?runhistory?runhistory$RunKey, $local_smac?runhistory?runhistory$RunValue, None)]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 113,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "automl/SMAC3",
    "source_filename": "smac/runhistory/runhistory.py",
    "target_filename": "smac/runhistory/runhistory.py",
    "source_changeid": "ba29de1b2599373a369342d3a093a953133ee3d8^",
    "target_changeid": "ba29de1b2599373a369342d3a093a953133ee3d8",
    "predictions": [
      "# order as it was added. \n self.data = collections.OrderedDict() # type: typing.Dict[RunKey, RunValue] \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "# order as it was added. \n self.data = collections.OrderedDict() # type: typing.Dict[RunKey, RunValue] \n \n",
      "1": "# order as it was added. \n self.data = collections.OrderedDict() # type: typing.Dict[RunKey: RunValue] \n \n",
      "2": "# order as it was added. \n self.data = collections.OrderedDict() \n \n",
      "3": "# order as it was added. \n self.data = collections.OrderedDict(RunKey, RunValue) \n \n",
      "4": "# order as it was added. \n self.data = collections.OrderedDict() # type: str.Dict[RunKey: RunValue] \n \n"
    }
  },
  {
    "source_code": "\n  <DED>def ExecuteThroughput(\n      self,\n      concurrency_streams: List[List[str]]) -> (Dict[str, Any], Dict[str, str]):\n    <IND>",
    "target_code": "\n  <DED>def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str:\n    <IND>",
    "warning_line": "      concurrency_streams: List[List[str]]) -> (Dict[str, Any], Dict[str, str]):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `(typing.Dict[(str, typing.Any)], typing.Dict[(str, str)])` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 257,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "GoogleCloudPlatform/PerfKitBenchmarker",
    "source_filename": "perfkitbenchmarker/providers/aws/redshift.py",
    "target_filename": "perfkitbenchmarker/providers/aws/redshift.py",
    "source_changeid": "099e8fcc45c2590aece48c9e8a44bc8acfcda979^",
    "target_changeid": "099e8fcc45c2590aece48c9e8a44bc8acfcda979",
    "predictions": [
      "\n <DED> def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str: \n <IND>"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str: \n <IND>",
      "1": "\n <IND> def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str: \n <IND>",
      "2": "\n <DED> def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str: \n <DED>",
      "3": "\n <DED> def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str: \n \n",
      "4": "\n \n def ExecuteThroughput(self, concurrency_streams: List[List[str]]) -> str: \n <IND>"
    }
  },
  {
    "source_code": "\n<DED>class BaseExampleGenExecutor(\n    with_metaclass(abc.ABCMeta, base_beam_executor.BaseBeamExecutor)):\n  <IND>",
    "target_code": "\n<DED>class BaseExampleGenExecutor(base_beam_executor.BaseBeamExecutor, abc.ABC):\n  <IND>",
    "warning_line": "    with_metaclass(abc.ABCMeta, base_beam_executor.BaseBeamExecutor)):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `six.with_metaclass(abc.ABCMeta, tfx.dsl.components.base.base_beam_executor.BaseBeamExecutor)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 134,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/tfx",
    "source_filename": "tfx/components/example_gen/base_example_gen_executor.py",
    "target_filename": "tfx/components/example_gen/base_example_gen_executor.py",
    "source_changeid": "c1e0704b2a83232469f55598efcdb7808b6c909f^",
    "target_changeid": "c1e0704b2a83232469f55598efcdb7808b6c909f",
    "predictions": [
      "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base.base_beam_executor.BaseBeamExecutor): \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base.base_beam_executor.BaseBeamExecutor): \n <IND>",
      "1": "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base.BaseBeam_executor.BaseBeamExecutor): \n <IND>",
      "2": "\n <DED> class BaseExampleGenExecutor( \n tfx.dsl.components.base_beam_executor.BaseBeamExecutor): \n <IND>",
      "3": "\n <DED> class BaseExampleGenExecutor( \n with_metaclass(abc.ABC): \n <IND>",
      "4": "\n <DED> class BaseExampleGenExecutor( \n with_metaclass(abc.ABC, base_beam_executor.BaseBeamExecutor): \n <IND>"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    first_name: ormar.String(max_length=80)\n    last_name: ormar.String(max_length=80)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    first_name = ormar.String(max_length=80)\n    last_name = ormar.String(max_length=80)\n\n",
    "warning_line": "    id: ormar.Integer(primary_key=True)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.Integer($parameter$primary_key = True)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 21,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_many_to_many.py",
    "target_filename": "tests/test_many_to_many.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n first_name = ormar.String(max_length=80) \n last_name = ormar.String(max_length=80) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n first_name = ormar.String(max_length=80) \n last_name = ormar.String(max_length=80) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n first_name = ormar.String(max_length=80) \n last_name = ormar.String(max_length=80) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n first_name = ormar.String(max_length=80) \n last_name = ormar.String(max_length=80) \n \n",
      "3": "<DED> id = ormar.Integer(primary_key=True) \n first_name = ormar.String(max_length=80) \n last_name = ormar.String(max_length=80) \n \n",
      "4": "\n <DED> id = ormar.Integer(primary_key=True) \n first_name = ormar.String(max_length=80) \n last_name = ormar.String(max_length=80) \n <DED>"
    }
  },
  {
    "source_code": " <DED>@db_error_default(list())\n def get_services(self, enabled=True, disabled=False) -> List(Service):\n\t\t<IND>services = list()\n",
    "target_code": " <DED>@db_error_default(list())\n def get_services(self, enabled=True, disabled=False) -> List[Service]:\n\t\t<IND>services = list()\n",
    "warning_line": "\tdef get_services(self, enabled=True, disabled=False) -> List(Service):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.List(src.data.models.Service)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 182,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "r-anime/holo",
    "source_filename": "src/data/database.py",
    "target_filename": "src/data/database.py",
    "source_changeid": "92dbaf41501b2e2ceb2138881ee1c437d97562bd^",
    "target_changeid": "92dbaf41501b2e2ceb2138881ee1c437d97562bd",
    "predictions": [
      "<DED> @db_error_default(list()) \n def get_services(self, enabled=True, disabled=False) -> List[Service]: \n <IND> services = list() \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> @db_error_default(list()) \n def get_services(self, enabled=True, disabled=False) -> List[Service]: \n <IND> services = list() \n",
      "1": "<DED> @db_error_default(list()) \n def get_services(self, enabled=True, disabled=False) -> List(): \n <IND> services = list() \n",
      "2": "<IND> @db_error_default(list()) \n def get_services(self, enabled=True, disabled=False) -> List[Service]: \n <IND> services = list() \n",
      "3": "\n @db_error_default(list()) \n def get_services(self, enabled=True, disabled=False) -> List[Service]: \n <IND> services = list() \n",
      "4": "<DED> @db_error_default(list()) \n def get_services(self, enabled=True, disabled=False) -> str: \n <IND> services = list() \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    team: ormar.ForeignKey(Team)\n    email: ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    team = ormar.ForeignKey(Team)\n    email = ormar.String(max_length=100)\n\n",
    "warning_line": "    team: ormar.ForeignKey(Team)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.ForeignKey(tests.test_foreign_keys.Team)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 74,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_foreign_keys.py",
    "target_filename": "tests/test_foreign_keys.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n team = ormar.ForeignKey(Team) \n email = ormar.String(max_length=100) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n team = ormar.ForeignKey(Team) \n email = ormar.String(max_length=100) \n \n",
      "1": "\n <DED> id = ormar.Integer(primary_key=True) \n team= ormar.ForeignKey(Team) \n email = ormar.String(max_length=100) \n \n",
      "2": "\n <IND> id = ormar.Integer(primary_key=True) \n team = ormar.ForeignKey(Team) \n email = ormar.String(max_length=100) \n \n",
      "3": "\n \n id = ormar.Integer(primary_key=True) \n team = ormar.ForeignKey(Team) \n email = ormar.String(max_length=100) \n \n",
      "4": "<IND> <DED> id = ormar.Integer(primary_key=True) \n team = ormar.ForeignKey(Team) \n email = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    name: ormar.String(max_length=40)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n",
    "warning_line": "    id: ormar.Integer(primary_key=True)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.Integer($parameter$primary_key = True)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 26,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "docs_src/relations/docs002.py",
    "target_filename": "docs_src/relations/docs002.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "3": "<DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n \n",
      "4": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=40) \n <DED>"
    }
  },
  {
    "source_code": "        actor_update_interval: int = 8,\n        step_hooks: List[Callable[None, agent.Agent, int], Any] = [],\n        optimizer_step_hooks: List[Callable[None, agent.Agent, int], Any] = []\n    ):\n",
    "target_code": "        actor_update_interval: int = 8,\n        step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [],\n        optimizer_step_hooks: List[Callable[[None, agent.Agent, int], Any]] = []\n    ):\n",
    "warning_line": "        step_hooks: List[Callable[None, agent.Agent, int], Any] = [],",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.List[(typing.Callable[(None, pfrl.agent.Agent, int)], typing.Any)]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 721,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "pfnet/pfrl",
    "source_filename": "pfrl/agents/dqn.py",
    "target_filename": "pfrl/agents/dqn.py",
    "source_changeid": "ba52704df4f3503936a8fd4b7018c17fd987b4da^",
    "target_changeid": "ba52704df4f3503936a8fd4b7018c17fd987b4da",
    "predictions": [
      "actor_update_interval: int = 8, \n step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [], \n optimizer_step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [] \n ): \n"
    ],
    "correct": true,
    "top_five": {
      "0": "actor_update_interval: int = 8, \n step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [], \n optimizer_step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [] \n ): \n",
      "1": "actor_update_interval: int = 8, \n step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [], \n optimizer_step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [], \n ): \n",
      "2": "actor_update_interval: int = 8, \n step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [] \n optimizer_step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [] \n ): \n",
      "3": "actor_update_interval: int = 8, \n step_hooks: List[List[Callable[[None, agent.Agent, int], Any]] = [], \n optimizer_step_hooks: List[List[Callable[[None, agent.Agent, int], Any]] = [] \n ): \n",
      "4": "actor_update_interval: int = 8, \n step_hooks: List[Callable[[None, agent.Agent], int], Any]] = [], \n optimizer_step_hooks: List[Callable[[None, agent.Agent, int], Any]] = [] \n ): \n"
    }
  },
  {
    "source_code": "\n    <DED>def _process_legacy_project(self, instance) -> [None, Exception]:\n        <IND>validate(instance, \"legacy_project_config\")\n",
    "target_code": "\n    <DED>def _process_legacy_project(self, instance) -> Optional[Exception]:\n        <IND>validate(instance, \"legacy_project_config\")\n",
    "warning_line": "    def _process_legacy_project(self, instance) -> [None, Exception]:",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `[None, Exception]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 240,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "aws-ia/taskcat",
    "source_filename": "taskcat/config.py",
    "target_filename": "taskcat/config.py",
    "source_changeid": "5279c4e8be22a46e71e8b60b6d25de793e800741^",
    "target_changeid": "5279c4e8be22a46e71e8b60b6d25de793e800741",
    "predictions": [
      "\n <DED> def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n",
      "1": "\n <IND> def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n",
      "2": "\n <DED> def _process_legacy_project(self, instance) -> None: \n <DED> validate(instance, \"legacy_project_config\") \n",
      "3": "\n \n def _process_legacy_project(self, instance) -> None: \n <IND> validate(instance, \"legacy_project_config\") \n",
      "4": "\n <DED> def _process_legacy_project(self, instance): \n <IND> validate(instance, \"legacy_project_config\") \n"
    }
  },
  {
    "source_code": "      daemonset: V1DaemonSet,\n      namespace: str = k.DEFAULT_NAMESPACE) -> Optional(V1DaemonSet):\n    <IND>",
    "target_code": "      daemonset: V1DaemonSet,\n      namespace: str = k.DEFAULT_NAMESPACE) -> Optional[V1DaemonSet]:\n    <IND>",
    "warning_line": "      namespace: str = k.DEFAULT_NAMESPACE) -> Optional(V1DaemonSet):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.Optional(kubernetes.client.V1DaemonSet)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 899,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "google/caliban",
    "source_filename": "caliban/gke/cluster.py",
    "target_filename": "caliban/gke/cluster.py",
    "source_changeid": "4bf818763b94c83a0dc9efad566d5e15e1002f26^",
    "target_changeid": "4bf818763b94c83a0dc9efad566d5e15e1002f26",
    "predictions": [
      "daemonset: V1DaemonSet, \n namespace: str = k.DEFAULT_NAMESPACE) -> Optional[V1DaemonSet]: \n <IND>"
    ],
    "correct": true,
    "top_five": {
      "0": "daemonset: V1DaemonSet, \n namespace: str = k.DEFAULT_NAMESPACE) -> Optional[V1DaemonSet]: \n <IND>",
      "1": "daemonset: V1DaemonSet, \n namespace: str = k.DEFAULT_NAMESPACE) -> Optional[V1DaemonSet]: \n \n",
      "2": "daemonset: V1DaemonSet, \n namespace: str = k.DEFAULT_NAMESPACE) -> Optional[V1DaemonSet]: \n <DED>",
      "3": "daemonset: V1DaemonSet, \n namespace = k.DEFAULT_NAMESPACE) -> Optional[V1DaemonSet]: \n <IND>",
      "4": "daemonset: V1DaemonSet, \n namespace: str = k.DEFAULT_NAMESPACE) -> k.DEFAULT_NAMESPACE: \n <IND>"
    }
  },
  {
    "source_code": "\n        self._valid_max_freq: Dict[str: float] = {\"503\": 3699999995,\n                                                  \"508\": 8499999995,\n",
    "target_code": "\n        self._valid_max_freq: Dict[str, float] = {\"503\": 3699999995,\n                                                  \"508\": 8499999995,\n",
    "warning_line": "        self._valid_max_freq: Dict[str: float] = {\"503\": 3699999995,",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.Dict[slice(str, float, None)]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 391,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "QCoDeS/Qcodes",
    "source_filename": "qcodes/instrument_drivers/Keysight/N9030B.py",
    "target_filename": "qcodes/instrument_drivers/Keysight/N9030B.py",
    "source_changeid": "3287dcda724cad2853e432567d51c1d8d209b14e^",
    "target_changeid": "3287dcda724cad2853e432567d51c1d8d209b14e",
    "predictions": [
      "\n self._valid_max_freq: Dict[str, float] = { \"503\": 3699999995, \n \"508\": 8499999995, \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n self._valid_max_freq: Dict[str, float] = { \"503\": 3699999995, \n \"508\": 8499999995, \n",
      "1": "\n self._valid_max_freq: Dict[str, Float] = { \"503\": 3699999995, \n \"508\": 8499999995, \n",
      "2": "\n self._valid_max_freq: Dict[str, List[float]] = { \"503\": 3699999995, \n \"508\": 8499999995, \n",
      "3": "\n self._valid_max_freq: Dict[str, Optional[float]] = { \"503\": 3699999995, \n \"508\": 8499999995, \n",
      "4": "\n self._valid_max_freq: Dict[str, float, None] = { \"503\": 3699999995, \n \"508\": 8499999995, \n"
    }
  },
  {
    "source_code": "\nclass ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods,                ObjectDetectionDatasetStatisticsMethods)):\n\n",
    "target_code": "\n# class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods, \\\n# \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObjectDetectionDatasetStatisticsMethods)):\nclass ObjectDetectionDataset(object):\n\n",
    "warning_line": "class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods, \\",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `interface.implements(ObjectDetectionDatasetPreprocessMethods.ObjectDetectionDatasetPreprocessMethods, ObjectDetectionDatasetStatisticsMethods.ObjectDetectionDatasetStatisticsMethods)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 62,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "lozuwa/impy",
    "source_filename": "ObjectDetectionDataset.py",
    "target_filename": "ObjectDetectionDataset.py",
    "source_changeid": "eb7fa43ba86a2916ead5de602fdb3949c06749c8^",
    "target_changeid": "eb7fa43ba86a2916ead5de602fdb3949c06749c8",
    "predictions": [
      "\n class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods, ObjectDetectionDatasetStatisticsMethods)): \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods, ObjectDetectionDatasetStatisticsMethods)): \n \n",
      "1": "\n class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods.ObjectDetectionDatasetPreprocessMethods, ObjectDetectionDatasetStatisticsMethods)): \n \n",
      "2": "\n class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods.ObjectDetectionDatasetPreprocessMethods)): \n \n",
      "3": "\n class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods)): \n \n",
      "4": "\n class ObjectDetectionDataset(implements(ObjectDetectionDatasetPreprocessMethods, ObjectDetectionDatasetStatisticsMethods.ObjectDetectionDatasetStatisticsMethods)): \n \n"
    }
  },
  {
    "source_code": "        <DED>validate(self.parameters, \"overrides\")\n        self.regions = list(regions) if regions else []\n        self.auth: dict = auth\n        self.client_factory: [ClientFactory, None] = None\n        self.name: str = name\n",
    "target_code": "        <DED>validate(self.parameters, \"overrides\")\n        self.regions: set = set(regions) if regions else set()\n        self.auth: dict = auth\n        self.client_factory: ClientFactory = ClientFactory()\n        self.name: str = name\n",
    "warning_line": "        self.client_factory: [ClientFactory, None] = None",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `[taskcat.client_factory.ClientFactory, None]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 40,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "aws-ia/taskcat",
    "source_filename": "taskcat/_config_types.py",
    "target_filename": "taskcat/_config_types.py",
    "source_changeid": "5279c4e8be22a46e71e8b60b6d25de793e800741^",
    "target_changeid": "5279c4e8be22a46e71e8b60b6d25de793e800741",
    "predictions": [
      "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n",
      "1": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: Optional[ClientFactory, None] = None \n self.name: str = name \n",
      "2": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else None \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n",
      "3": "<DED> validate(self.parameters, \"overrides\") \n self.regions: list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: List[ClientFactory, None] = None \n self.name: str = name \n",
      "4": "<DED> validate(self.parameters, \"overrides\") \n self.regions = list(regions) if regions else [] \n self.auth: dict = auth \n self.client_factory: ClientFactory, None = None \n self.name: str = name \n"
    }
  },
  {
    "source_code": "    <DED>@staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: [str]) -> bool:\n        <IND>",
    "target_code": "    <DED>@staticmethod\n    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: List[str]) -> bool:\n        <IND>",
    "warning_line": "    def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: [str]) -> bool:",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `[str]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 76,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Cura",
    "source_filename": "plugins/Toolbox/src/CloudSync/SubscribedPackagesModel.py",
    "target_filename": "plugins/Toolbox/src/CloudSync/SubscribedPackagesModel.py",
    "source_changeid": "ea9a9d58b17e93eed22923001069fceafea8a798^",
    "target_changeid": "ea9a9d58b17e93eed22923001069fceafea8a798",
    "predictions": [
      "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: str) -> bool: \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: str) -> bool: \n <IND>",
      "1": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager) -> bool: \n <IND>",
      "2": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: Optional[str]) -> bool: \n <IND>",
      "3": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: List[str]) -> bool: \n <IND>",
      "4": "<DED> @staticmethod \n def _isAnyVersionCompatible(package_manager: PackageManager, api_versions: bool) -> bool: \n <IND>"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True, autoincrement=False)\n    name: ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True, autoincrement=False)\n    name = ormar.String(max_length=100)\n\n",
    "warning_line": "    id: ormar.Integer(primary_key=True, autoincrement=False)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.Integer($parameter$primary_key = True, $parameter$autoincrement = False)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 20,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_more_same_table_joins.py",
    "target_filename": "tests/test_more_same_table_joins.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True, autoincrement=False) \n name = ormar.String(max_length=100) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True, autoincrement=False) \n name = ormar.String(max_length=100) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True, autoincrement=False) \n name = ormar.String(max_length=100) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True, autoincrement=False) \n name = ormar.String(max_length=100) \n \n",
      "3": "<DED> id = ormar.Integer(primary_key=True, autoincrement=False) \n name = ormar.String(max_length=100) \n \n",
      "4": "<IND> <DED> id = ormar.Integer(primary_key=True, autoincrement=False) \n name = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": "        data_sum = data.sum()\n        summary: dict() = dict()\n\n",
    "target_code": "        data_sum = data.sum()\n        summary = dict()\n\n",
    "warning_line": "        summary: dict() = dict()",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `dict()` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 147,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "argoai/argoverse-api",
    "source_filename": "argoverse/evaluation/stereo/eval.py",
    "target_filename": "argoverse/evaluation/stereo/eval.py",
    "source_changeid": "b9f1b8f874c25d37f6154edecda510672289bd5c^",
    "target_changeid": "b9f1b8f874c25d37f6154edecda510672289bd5c",
    "predictions": [
      "data_sum = data.sum() \n summary: dict() \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "data_sum = data.sum() \n summary: dict() \n \n",
      "1": "data_sum = data.sum() \n summary = dict() \n \n",
      "2": "data_sum = data.sum() \n sum = dict() \n \n",
      "3": "data_sum = data.sum() \n summary: [] = dict() \n \n",
      "4": "data_sum = data.sum() \n summary=dict() \n \n"
    }
  },
  {
    "source_code": "\n\n\ndef generate_all_combinations(n: int, k: int) -> [[int]]:\n    <IND>",
    "target_code": "\nfrom typing import List\n\n\ndef generate_all_combinations(n: int, k: int) -> List[List[int]]:\n    <IND>",
    "warning_line": "def generate_all_combinations(n: int, k: int) -> [[int]]:",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `[[int]]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 8,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "TheAlgorithms/Python",
    "source_filename": "backtracking/all_combinations.py",
    "target_filename": "backtracking/all_combinations.py",
    "source_changeid": "25164bb6380ae760bed5fe3efc5f2fc3ec5c38a1^",
    "target_changeid": "25164bb6380ae760bed5fe3efc5f2fc3ec5c38a1",
    "predictions": [
      "\n \n \n def generate_all_combinations(n: int, k: int) -> List[int]: \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n \n \n def generate_all_combinations(n: int, k: int) -> List[int]: \n <IND>",
      "1": "\n \n \n def generate_all_combinations(n: int, k: int): \n <IND>",
      "2": "\n \n \n def generate_all_combinations(n: int, k: int) -> List[[int]]: \n <IND>",
      "3": "\n \n \n def generate_all_combinations(n: int, k: int) -> str: \n <IND>",
      "4": "\n \n <DED> def generate_all_combinations(n: int, k: int) -> List[int]: \n <IND>"
    }
  },
  {
    "source_code": "        # Stores cost for each configuration ID\n        self.cost_per_config = {}  # type: typing.Dict[int: float]\n        # runs_per_config maps the configuration ID to the number of runs for that configuration\n        # and is necessary for computing the moving average\n        self.runs_per_config = {}  # type: typing.Dict[int: int]\n\n",
    "target_code": "        # Stores cost for each configuration ID\n        self.cost_per_config = {}  # type: typing.Dict[int, float]\n        # runs_per_config maps the configuration ID to the number of runs for that configuration\n        # and is necessary for computing the moving average\n        self.runs_per_config = {}  # type: typing.Dict[int, int]\n\n",
    "warning_line": "        self.runs_per_config = {}  # type: typing.Dict[int: int]",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `typing.Dict[slice(int, int, None)]` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 127,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "automl/SMAC3",
    "source_filename": "smac/runhistory/runhistory.py",
    "target_filename": "smac/runhistory/runhistory.py",
    "source_changeid": "ba29de1b2599373a369342d3a093a953133ee3d8^",
    "target_changeid": "ba29de1b2599373a369342d3a093a953133ee3d8",
    "predictions": [
      "# Stores cost for each configuration ID \n self.cost_per_config = { } # type: typing.Dict[int, float] \n # runs_per_config maps the configuration ID to the number of runs for that configuration \n # and is necessary for computing the moving average \n self.runs_per_config = { } # type: typing.Dict[int, int] \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "# Stores cost for each configuration ID \n self.cost_per_config = { } # type: typing.Dict[int, float] \n # runs_per_config maps the configuration ID to the number of runs for that configuration \n # and is necessary for computing the moving average \n self.runs_per_config = { } # type: typing.Dict[int, int] \n \n",
      "1": "# Stores cost for each configuration ID \n self.cost_per_config = { } # type: typing.Dict[int, int] \n # runs_per_config maps the configuration ID to the number of runs for that configuration \n # and is necessary for computing the moving average \n self.runs_per_config = { } # type: typing.Dict[int, int] \n \n",
      "2": "# Stores cost for each configuration ID \n self.cost_per_config = { } # type: typing.Dict[int, int, float] \n # runs_per_config maps the configuration ID to the number of runs for that configuration \n # and is necessary for computing the moving average \n self.runs_per_config = { } # type: typing.Dict[int, int] \n \n",
      "3": "# Stores cost for each configuration ID \n self.cost_per_config = { } # type: typing.Dict[int] \n # runs_per_config maps the configuration ID to the number of runs for that configuration \n # and is necessary for computing the moving average \n self.runs_per_config = { } # type: typing.Dict[int, int] \n \n",
      "4": "# Stores cost for each configuration ID \n self.cost_per_config = { } # type: typing.Dict[int, Int] \n # runs_per_config maps the configuration ID to the number of runs for that configuration \n # and is necessary for computing the moving average \n self.runs_per_config = { } # type: typing.Dict[int, int] \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    name: ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n\n",
    "warning_line": "    name: ormar.String(max_length=100)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.String($parameter$max_length = 100)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 31,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_more_same_table_joins.py",
    "target_filename": "tests/test_more_same_table_joins.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "3": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n <DED>",
      "4": "<DED> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: ormar.Integer(primary_key=True)\n    text: ormar.String(max_length=500)\n    completed: ormar.Boolean(default=False)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    text = ormar.String(max_length=500)\n    completed= ormar.Boolean(default=False)\n\n",
    "warning_line": "    text: ormar.String(max_length=500)",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `ormar.String($parameter$max_length = 500)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 36,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_queryset_level_methods.py",
    "target_filename": "tests/test_queryset_level_methods.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n text = ormar.String(max_length=500) \n completed= ormar.Boolean(default=False) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n text = ormar.String(max_length=500) \n completed= ormar.Boolean(default=False) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n text = ormar.String(max_length=500) \n completed= ormar.Boolean(default=False) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n text = ormar.String(max_length=500) \n completed= ormar.Boolean(default=False) \n \n",
      "3": "<DED> id = ormar.Integer(primary_key=True) \n text = ormar.String(max_length=500) \n completed= ormar.Boolean(default=False) \n \n",
      "4": "<IND> <DED> id = ormar.Integer(primary_key=True) \n text = ormar.String(max_length=500) \n completed= ormar.Boolean(default=False) \n \n"
    }
  },
  {
    "source_code": "\n<DED><DED>class ServingBinary(six.with_metaclass(abc.ABCMeta, object)):\n  <IND>\"\"\"Base class for serving binaries.\"\"\"\n",
    "target_code": "\n<DED><DED>class ServingBinary(abc.ABC):\n  <IND>\"\"\"Base class for serving binaries.\"\"\"\n",
    "warning_line": "class ServingBinary(six.with_metaclass(abc.ABCMeta, object)):",
    "linter_report": {
      "rule_id": "Invalid type [31]",
      "message": " Expression `six.with_metaclass(abc.ABCMeta, object)` is not a valid type.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 55,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tensorflow/tfx",
    "source_filename": "tfx/components/infra_validator/serving_bins.py",
    "target_filename": "tfx/components/infra_validator/serving_bins.py",
    "source_changeid": "c1e0704b2a83232469f55598efcdb7808b6c909f^",
    "target_changeid": "c1e0704b2a83232469f55598efcdb7808b6c909f",
    "predictions": [
      "\n <DED> <DED> class ServingBinary(abc.ABC): \n <IND> \"\"\"Base class for serving binaries.\"\"\" \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> <DED> class ServingBinary(abc.ABC): \n <IND> \"\"\"Base class for serving binaries.\"\"\" \n",
      "1": "\n <IND> <DED> class ServingBinary(abc.ABC): \n <IND> \"\"\"Base class for serving binaries.\"\"\" \n",
      "2": "\n <DED> <IND> class ServingBinary(abc.ABC): \n <IND> \"\"\"Base class for serving binaries.\"\"\" \n",
      "3": "\n <DED> <DED> class ServingBinary(abc.ABC): \n <DED> \"\"\"Base class for serving binaries.\"\"\" \n",
      "4": "\n <DED> \n class ServingBinary(abc.ABC): \n <IND> \"\"\"Base class for serving binaries.\"\"\" \n"
    }
  },
  {
    "source_code": "\n    <DED>def fit(self, ts, component_index: Optional[int] = None):\n        <IND>super().fit(ts, component_index)\n        # Check univariate time series\n",
    "target_code": "\n    <DED>def fit(self, ts):\n        <IND>super().fit(ts)\n        # Check univariate time series\n",
    "warning_line": "    def fit(self, ts, component_index: Optional[int] = None):",
    "linter_report": {
      "rule_id": "Inconsistent override [14]",
      "message": " `darts.models.theta.FourTheta.fit` overrides method defined in `UnivariateForecastingModel` inconsistently. Could not find parameter `series` in overriding signature.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 218,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "unit8co/darts",
    "source_filename": "darts/models/theta.py",
    "target_filename": "darts/models/theta.py",
    "source_changeid": "2977f4f666e255b617ad980eab81d6ff6aad9db3^",
    "target_changeid": "2977f4f666e255b617ad980eab81d6ff6aad9db3",
    "predictions": [
      "\n <DED> def fit(self, ts, component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def fit(self, ts, component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "1": "\n <DED> def fit(self, ts: Optional[int], component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "2": "\n <DED> def fit(self, ts: Optional[int] = None, component_index: Optional[int] = None): \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n",
      "3": "\n <DED> def fit(self, ts, component_index=None): \n <IND> super().fit(ts, component_index=None) \n # Check univariate time series \n",
      "4": "\n <DED> def fit(self, ts, component_index: Optional[int] = None) -> None: \n <IND> super().fit(ts, component_index) \n # Check univariate time series \n"
    }
  },
  {
    "source_code": "\n    <DED>def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes:\n        <IND>raise NotImplementedError\n",
    "target_code": "\n    <DED>def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path, options: Dict[str, Any]) -> bytes:\n        <IND>raise NotImplementedError\n",
    "warning_line": "    def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes:",
    "linter_report": {
      "rule_id": "Inconsistent override [14]",
      "message": " `onlinejudge_verify.languages.csharpscript.CSharpScriptLanguage.bundle` overrides method defined in `Language` inconsistently. Could not find parameter `options` in overriding signature.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 112,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "online-judge-tools/verification-helper",
    "source_filename": "onlinejudge_verify/languages/csharpscript.py",
    "target_filename": "onlinejudge_verify/languages/csharpscript.py",
    "source_changeid": "97fda380fc5689b70152f868b9f96a073a2a62fc^",
    "target_changeid": "97fda380fc5689b70152f868b9f96a073a2a62fc",
    "predictions": [
      "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes: \n <IND> raise NotImplementedError \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> bytes: \n <IND> raise NotImplementedError \n",
      "1": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> str(bytes): \n <IND> raise NotImplementedError \n",
      "2": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> Bytes: \n <IND> raise NotImplementedError \n",
      "3": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path) -> str: \n <IND> raise NotImplementedError \n",
      "4": "\n <DED> def bundle(self, path: pathlib.Path, *, basedir: pathlib.Path): \n <IND> raise NotImplementedError \n"
    }
  },
  {
    "source_code": "    <DED><DED>def list_projects(self):\n        # type: (Text) -> List[Text]\n        <IND>try:\n",
    "target_code": "    <DED><DED>def list_projects(self):\n        # type: () -> List[Text]\n        <IND>try:\n",
    "warning_line": "    def list_projects(self):",
    "linter_report": {
      "rule_id": "Inconsistent override [14]",
      "message": " `rasa_nlu.persistor.AWSPersistor.list_projects` overrides method defined in `Persistor` inconsistently. Parameter of type `str` is not a supertype of the overridden parameter `Persistor`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 160,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "RasaHQ/rasa",
    "source_filename": "rasa_nlu/persistor.py",
    "target_filename": "rasa_nlu/persistor.py",
    "source_changeid": "b3b7eff357b0b8d2792ce2ca475ed5aa7538dada^",
    "target_changeid": "b3b7eff357b0b8d2792ce2ca475ed5aa7538dada",
    "predictions": [
      "<DED> <DED> def list_projects(self): \n # type: () -> List[Text] \n <IND> try: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> <DED> def list_projects(self): \n # type: () -> List[Text] \n <IND> try: \n",
      "1": "\n <DED> def list_projects(self): \n # type: () -> List[Text] \n <IND> try: \n",
      "2": "<IND> <DED> def list_projects(self): \n # type: () -> List[Text] \n <IND> try: \n",
      "3": "<DED> <DED> def list_projects(self): \n # type: (str) -> List[Text] \n <IND> try: \n",
      "4": "<DED> <DED> def list_projects(self): \n # type: (Text) -> List[Text] \n <IND> try: \n"
    }
  },
  {
    "source_code": "    <DED>def write(self, data):\n        # type: (bytes) -> int\n        <IND>if not self._mode.writing:\n",
    "target_code": "    <DED>def write(self, data):\n        # type: (Union[bytes, bytearray, memoryview, array.array[Any], mmap.mmap]) -> int\n        <IND>if not self._mode.writing:\n",
    "warning_line": "    def write(self, data):",
    "linter_report": {
      "rule_id": "Inconsistent override [14]",
      "message": " `fs.memoryfs._MemoryFile.write` overrides method defined in `io.RawIOBase` inconsistently. Parameter of type `bytes` is not a supertype of the overridden parameter `Union[array.array[typing.Any], bytearray, bytes, memoryview, mmap.mmap]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 192,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "PyFilesystem/pyfilesystem2",
    "source_filename": "fs/memoryfs.py",
    "target_filename": "fs/memoryfs.py",
    "source_changeid": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b^",
    "target_changeid": "ec8300b3dac2bfa68d59b3b290e40c3fb608976b",
    "predictions": [
      "<DED> def write(self, data): \n # type: () -> int \n <IND> if not self._mode.writing: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def write(self, data): \n # type: () -> int \n <IND> if not self._mode.writing: \n",
      "1": "<DED> def write(self, data): \n <IND> if not self._mode.writing: \n",
      "2": "<DED> def write(self, data): \n <DED> if not self._mode.writing: \n",
      "3": "<DED> def write(self, data): \n # type: () -> int \n <DED> if not self._mode.writing: \n",
      "4": "<DED> def write(self, data): \n \n if not self._mode.writing: \n"
    }
  },
  {
    "source_code": "\n    <DED>def format(self, record: str) -> str:\n        <IND>",
    "target_code": "\n    <DED>def format(self, record: logging.LogRecord) -> str:\n        <IND>",
    "warning_line": "    def format(self, record: str) -> str:",
    "linter_report": {
      "rule_id": "Inconsistent override [14]",
      "message": " `kedro.contrib.colors.logging.color_logger.ColorHandler.format` overrides method defined in `logging.Handler` inconsistently. Parameter of type `str` is not a supertype of the overridden parameter `logging.LogRecord`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 110,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "quantumblacklabs/kedro",
    "source_filename": "kedro/contrib/colors/logging/color_logger.py",
    "target_filename": "kedro/contrib/colors/logging/color_logger.py",
    "source_changeid": "49c095d0a747ce00b99727e358bb1f7f41106fe9^",
    "target_changeid": "49c095d0a747ce00b99727e358bb1f7f41106fe9",
    "predictions": [
      "\n <DED> def format(self, record: str) -> str: \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def format(self, record: str) -> str: \n <IND>",
      "1": "\n <DED> def format(self, record: logger.Str) -> str: \n <IND>",
      "2": "\n <DED> def format(self, record: logging.Handler.format) -> str: \n <IND>",
      "3": "\n <DED> def format(self, record: str) -> str: \n <IND>",
      "4": "\n <DED> def format(self, record: str) -> k: \n <IND>"
    }
  },
  {
    "source_code": "\n    <DED>def __or__(self, other: \"BitVec\") -> \"BitVecFunc\":\n        <IND>",
    "target_code": "\n    <DED>def __or__(self, other: Union[int, \"BitVec\"]) -> \"BitVecFunc\":\n        <IND>",
    "warning_line": "    def __or__(self, other: \"BitVec\") -> \"BitVecFunc\":",
    "linter_report": {
      "rule_id": "Inconsistent override [14]",
      "message": " `mythril.laser.smt.bitvecfunc.BitVecFunc.__or__` overrides method defined in `BitVec` inconsistently. Parameter of type `BitVec` is not a supertype of the overridden parameter `Union[BitVec, int]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 137,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ConsenSys/mythril",
    "source_filename": "mythril/laser/smt/bitvecfunc.py",
    "target_filename": "mythril/laser/smt/bitvecfunc.py",
    "source_changeid": "556d138d50ef5ce02bd725a0743f8c7bf3038ae9^",
    "target_changeid": "556d138d50ef5ce02bd725a0743f8c7bf3038ae9",
    "predictions": [
      "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc\": \n <IND>"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc\": \n <IND>",
      "1": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]]) -> \"BitVecFunc",
      "2": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str], Union[str]]]]) -> \"BitVecFunc\": \n <IND>",
      "3": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str]]]]) -> \"BitVecFunc\": \n <IND>",
      "4": "\n <DED> def __or__(self, other: Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str, Union[str], Union[str]]]]]]])"
    }
  },
  {
    "source_code": "<DED>class UserInDBBase(UserBase):\n    <IND>id: int = None\n\n",
    "target_code": "<DED>class UserInDBBase(UserBase):\n    <IND>id: Optional[int] = None\n\n",
    "warning_line": "    id: int = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `id` declared in class `UserInDBBase` has type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 26,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "tiangolo/full-stack-fastapi-postgresql",
    "source_filename": "{{cookiecutter.project_slug}}/backend/app/app/schemas/user.py",
    "target_filename": "{{cookiecutter.project_slug}}/backend/app/app/schemas/user.py",
    "source_changeid": "eed33d276d04a719e7555be6d0c4ccda42d49716^",
    "target_changeid": "eed33d276d04a719e7555be6d0c4ccda42d49716",
    "predictions": [
      "<DED> class UserInDBBase(UserBase): \n <IND> id: Optional[int] = None \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> class UserInDBBase(UserBase): \n <IND> id: Optional[int] = None \n \n",
      "1": "<DED> class UserInDBBase(UserBase): \n <IND> id = [] \n \n",
      "2": "<DED> class UserInDBBase(UserBase): \n <IND> id = \"\" \n \n",
      "3": "<DED> class UserInDBBase(UserBase): \n <IND> id = 0 \n \n",
      "4": "<DED> class UserInDBBase(UserBase): \n <IND> id = None \n \n"
    }
  },
  {
    "source_code": "    )\n    max_seq_length: int = field(\n        default=None,\n",
    "target_code": "    )\n    max_seq_length: Optional[int] = field(\n        default=None,\n",
    "warning_line": "    max_seq_length: int = field(",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `max_seq_length` declared in class `DataTrainingArguments` has type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 109,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "huggingface/transformers",
    "source_filename": "examples/pytorch/multiple-choice/run_swag.py",
    "target_filename": "examples/pytorch/multiple-choice/run_swag.py",
    "source_changeid": "fcf83011dffce3f2e8aad906f07c1ec14668f877^",
    "target_changeid": "fcf83011dffce3f2e8aad906f07c1ec14668f877",
    "predictions": [
      ") \n max_seq_length: Optional[int] = field( \n default=None, \n"
    ],
    "correct": true,
    "top_five": {
      "0": ") \n max_seq_length: Optional[int] = field( \n default=None, \n",
      "1": ") \n max_seq_length: typing.Optional[int] = field( \n default=None, \n",
      "2": ") \n max_seq_length=None \n default=None, \n",
      "3": ") \n max_seq_length: None = field( \n default=None, \n",
      "4": ") \n max_seq_length: Optional[int] = field( \n default=None, <IND>"
    }
  },
  {
    "source_code": "class ClearChargingProfilePayload:\n    <IND>id: int = None\n    connector_id: int = None\n    charging_profile_purpose: Optional[ChargingProfilePurposeType] = None\n    stack_level: int = None\n\n",
    "target_code": "class ClearChargingProfilePayload:\n    <IND>id: Optional[int] = None\n    connector_id: Optional[int] = None\n    charging_profile_purpose: Optional[ChargingProfilePurposeType] = None\n    stack_level: Optional[int] = None\n\n",
    "warning_line": "    stack_level: int = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `stack_level` declared in class `ClearChargingProfilePayload` has type `int` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 63,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "mobilityhouse/ocpp",
    "source_filename": "ocpp/v16/call.py",
    "target_filename": "ocpp/v16/call.py",
    "source_changeid": "d99886565233ef7fa99750d386ff35d2933bbe8c^",
    "target_changeid": "d99886565233ef7fa99750d386ff35d2933bbe8c",
    "predictions": [
      "class ClearChargingProfilePayload: \n <IND> id: Optional[int] = None \n connector_id: Optional[int] = None \n charging_profile_purpose: Optional[ChargingProfilePurposeType] = None \n stack_level: Optional[int] = None \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "class ClearChargingProfilePayload: \n <IND> id: Optional[int] = None \n connector_id: Optional[int] = None \n charging_profile_purpose: Optional[ChargingProfilePurposeType] = None \n stack_level: Optional[int] = None \n \n",
      "1": "class ClearChargingProfilePayload: \n <IND> id = None \n connector_id = None \n charging_profile_purpose: Optional[ChargingProfilePurposeType] = None \n stack_level: Optional[int] = None \n \n",
      "2": "class ClearChargingProfilePayload: \n <DED> id: Optional[int] = None \n connector_id: Optional[int] = None \n charging_profile_purpose: Optional[ChargingProfilePurposeType] = None \n stack_level: Optional[int] = None \n \n",
      "3": "class ClearChargingProfilePayload: \n <IND> id = None \n connector_id: Optional[int] = None \n charging_profile_purpose: Optional[ChargingProfilePurposeType] = None \n stack_level: Optional[int] = None \n \n",
      "4": "class ClearChargingProfilePayload: \n <IND> id: Optional[int] = None \n connector_id: Optional[int] = None \n charging_profile_purpose: Optional[ChargingProfilePurposeType] = None \n stack_level: Optional[int] = None \n <IND>"
    }
  },
  {
    "source_code": "        <DED>else:\n            <IND>self.context_embeddings: FlairEmbeddings = contextual_embeddings\n\n        # length is twice the original character LM embedding length\n        <DED>self.embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"\n",
    "target_code": "        <DED>else:\n            <IND>self.context_embeddings = contextual_embeddings\n\n        # length is twice the original character LM embedding length\n        <DED>self.__embedding_length = self.context_embeddings.embedding_length * 2\n        self.name = self.context_embeddings.name + \"-context\"\n",
    "warning_line": "        self.embedding_length = self.context_embeddings.embedding_length * 2",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `embedding_length` declared in class `PooledFlairEmbeddings` has type `BoundMethod[typing.Callable(PooledFlairEmbeddings.embedding_length)[[Named(self, PooledFlairEmbeddings)], int], PooledFlairEmbeddings]` but is used as type `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 807,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "flairNLP/flair",
    "source_filename": "flair/embeddings/token.py",
    "target_filename": "flair/embeddings/token.py",
    "source_changeid": "0b834f5167d11f06037398fcbe1554f244167e18^",
    "target_changeid": "0b834f5167d11f06037398fcbe1554f244167e18",
    "predictions": [
      "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "1": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <IND> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "2": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n \n self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "3": "<DED> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n",
      "4": "<IND> else: \n <IND> self.context_embeddings: FlairEmbeddings = contextual_embeddings \n # embedding length is twice the original character LM embedding length \n <DED> self.embedding_length = self.context_embeddings.embedding_length * 2 \n self.name = self.context_embeddings.name + \"-context\" \n"
    }
  },
  {
    "source_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: ObjcRuntimeDataParser = None\n        self._objc_method_list: List[ObjcMethodInfo] = None\n\n",
    "target_code": "        self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs\n        self._objc_helper: Optional[ObjcRuntimeDataParser] = None\n        self._objc_method_list: List[ObjcMethodInfo] = []\n\n",
    "warning_line": "        self._objc_method_list: List[ObjcMethodInfo] = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `_objc_method_list` declared in class `MachoAnalyzer` has type `List[strongarm.objc.objc_analyzer.ObjcMethodInfo]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 51,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "datatheorem/strongarm",
    "source_filename": "strongarm/macho/macho_analyzer.py",
    "target_filename": "strongarm/macho/macho_analyzer.py",
    "source_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8^",
    "target_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "predictions": [
      "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: Optional[ObjcRuntimeDataParser] = None \n self._objc_method_list: Optional[List[ObjcMethodInfo]] = None \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: Optional[ObjcRuntimeDataParser] = None \n self._objc_method_list: Optional[List[ObjcMethodInfo]] = None \n \n",
      "1": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: ObjcRuntimeDataParser = [] \n self._objc_method_list: List[ObjcMethodInfo] = [] \n \n",
      "2": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: ObjcRuntimeDataParser = \"\" \n self._objc_method_list: List[ObjcMethodInfo] = \"\" \n \n",
      "3": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: ObjcRuntimeDataParser = [] \n self._objc_method_list: ObjcRuntimeDataParser = [] \n \n",
      "4": "self.imp_stubs = MachoImpStubsParser(binary, self.cs).imp_stubs \n self._objc_helper: Optional[ObjcRuntimeDataParser] = None \n self._objc_method_list: Optional[List[ObjcMethodInfo]] = None \n <DED>"
    }
  },
  {
    "source_code": "\n    num_classes: int = None\n    names: List[str] = None\n    names_file: str = None\n    id: Optional[str] = None\n",
    "target_code": "\n    num_classes: Optional[int] = None\n    names: Optional[List[str]] = None\n    names_file: Optional[str] = None\n    id: Optional[str] = None\n",
    "warning_line": "    names: List[str] = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `names` declared in class `ClassLabel` has type `List[str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 551,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "huggingface/datasets",
    "source_filename": "src/datasets/features.py",
    "target_filename": "src/datasets/features.py",
    "source_changeid": "49e517a3d21392291d771872204594f43cd09532^",
    "target_changeid": "49e517a3d21392291d771872204594f43cd09532",
    "predictions": [
      "\n num_classes: Optional[int] = None \n names: Optional[List[str]] = None \n names_file: Optional[str] = None \n id: Optional[str] = None \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n num_classes: Optional[int] = None \n names: Optional[List[str]] = None \n names_file: Optional[str] = None \n id: Optional[str] = None \n",
      "1": "\n num_classes: Optional[Int] = None \n names: Optional[List[str]] = None \n names_file: Optional[str] = None \n id: Optional[str] = None \n",
      "2": "<DED> num_classes: Optional[int] = None \n names: Optional[List[str]] = None \n names_file: Optional[str] = None \n id: Optional[str] = None \n",
      "3": "\n num_classes: Optional[int] = None \n names: Optional[List[str]] = None \n names_file: Optional[str] = None \n id = Optional[str] = None \n",
      "4": "<IND> num_classes: Optional[int] = None \n names: Optional[List[str]] = None \n names_file: Optional[str] = None \n id: Optional[str] = None \n"
    }
  },
  {
    "source_code": "    supercarrier: bool = False\n    multiplier: bool = 1\n    generate_marks: bool = True\n",
    "target_code": "    supercarrier: bool = False\n    multiplier: float = 1\n    generate_marks: bool = True\n",
    "warning_line": "    multiplier: bool = 1",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `multiplier` declared in class `Settings` has type `bool` but is used as type `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 24,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dcs-liberation/dcs_liberation",
    "source_filename": "game/settings.py",
    "target_filename": "game/settings.py",
    "source_changeid": "e851223733ca24b8479dc9c4cfaf76cb724661a3^",
    "target_changeid": "e851223733ca24b8479dc9c4cfaf76cb724661a3",
    "predictions": [
      "supercarrier: bool = False \n multiplier: int = 1 \n generate_marks: bool = True \n"
    ],
    "correct": false,
    "top_five": {
      "0": "supercarrier: bool = False \n multiplier: int = 1 \n generate_marks: bool = True \n",
      "1": "supercarrier: int = False \n multiplier: int = 1 \n generate_marks: int = True \n",
      "2": "supercarrier: bool = False \n multiplier: int = 1 \n generate_marks: int = True \n",
      "3": "supercarrier: bool = False \n multiplier: bool = 1 \n generate_marks: bool = True \n",
      "4": "supercarrier: int = False \n multiplier: int = 1 \n generate_marks: bool = True \n"
    }
  },
  {
    "source_code": "        # StringValueType\n        <IND>self.template: str = template\n        self.params: dict = params\n        self.schema: dict = schema\n\n",
    "target_code": "        # StringValueType\n        <IND>self.template: Optional[str] = template\n        self.params: Optional[dict] = params\n        self.schema: Optional[dict] = schema\n\n",
    "warning_line": "        self.template: str = template",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `template` declared in class `RenderedAtomicValue` has type `str` but is used as type `Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 513,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "great-expectations/great_expectations",
    "source_filename": "great_expectations/render/types/__init__.py",
    "target_filename": "great_expectations/render/types/__init__.py",
    "source_changeid": "7af2f6232fdbdfb2a05ad44497f8b5dbf1657235^",
    "target_changeid": "7af2f6232fdbdfb2a05ad44497f8b5dbf1657235",
    "predictions": [
      "# StringValueType \n <IND> self.template: Optional[str] = template \n self.params: Optional[dict] = params \n self.schema: Optional[dict] = schema \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "# StringValueType \n <IND> self.template: Optional[str] = template \n self.params: Optional[dict] = params \n self.schema: Optional[dict] = schema \n \n",
      "1": "# StringValueType \n <DED> self.template: Optional[str] = template \n self.params: Optional[dict] = params \n self.schema: Optional[dict] = schema \n \n",
      "2": "# StringValueType \n \n self.template: Optional[str] = template \n self.params: Optional[dict] = params \n self.schema: Optional[dict] = schema \n \n",
      "3": "# StringValueType \n <IND> self.template = Optional[str] = template \n self.params: Optional[dict] = params \n self.schema: Optional[dict] = schema \n \n",
      "4": "# StringValueType <IND> self.template: Optional[str] = template \n self.params: Optional[dict] = params \n self.schema: Optional[dict] = schema \n \n"
    }
  },
  {
    "source_code": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    <IND>def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None:\n        <IND>self.held_object = obj        # type: InterpreterObject\n        self.subproject = subproject  # type: str\n\n",
    "target_code": "class ObjectHolder(T.Generic[TV_InterpreterObject]):\n    <IND>def __init__(self, obj: TV_InterpreterObject, subproject: str = '') -> None:\n        <IND>self.held_object = obj\n        self.subproject = subproject\n\n",
    "warning_line": "        self.subproject = subproject  # type: str",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `subproject` declared in class `ObjectHolder` has type `str` but is used as type `T.Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 65,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "mesonbuild/meson",
    "source_filename": "mesonbuild/interpreterbase.py",
    "target_filename": "mesonbuild/interpreterbase.py",
    "source_changeid": "b8e4600bb84c94c1efde93c186eba7a2f5305836^",
    "target_changeid": "b8e4600bb84c94c1efde93c186eba7a2f5305836",
    "predictions": [
      "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: T.Optional[str] \n self.subproject = subproject # type: T.Optional[str] \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: T.Optional[str] \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "1": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: InterpreterObject \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "2": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: Optional[T.Optional[str]] = None) -> None: \n <IND> self.held_object = obj # type: InterpreterObject \n self.subproject = subproject # type: Optional[str] \n \n",
      "3": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: T.Optional[str] = None) -> None: \n <IND> self.held_object = obj # type: T.Optional[InterpreterObject] \n self.subproject = subproject # type: T.Optional[str] \n \n",
      "4": "class ObjectHolder(T.Generic[TV_InterpreterObject]): \n <IND> def __init__(self, obj: InterpreterObject, subproject: Optional[T.Optional[str]] = None) -> None: \n <IND> self.held_object = obj # type: InterpreterObject \n self.subproject = subproject # type: T.Optional[str] \n \n"
    }
  },
  {
    "source_code": "        # pylint: disable=too-many-arguments\n        <IND>self.protocols: List[str] = protocols\n        self.pubsub: Pubsub = None\n\n",
    "target_code": "        # pylint: disable=too-many-arguments\n        <IND>self.protocols = list(protocols)\n        self.pubsub = None\n\n",
    "warning_line": "        self.protocols: List[str] = protocols",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `protocols` declared in class `GossipSub` has type `List[str]` but is used as type `Sequence[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 65,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "libp2p/py-libp2p",
    "source_filename": "libp2p/pubsub/gossipsub.py",
    "target_filename": "libp2p/pubsub/gossipsub.py",
    "source_changeid": "b2f496d081db5176636449d585dbbdba7f71061d^",
    "target_changeid": "b2f496d081db5176636449d585dbbdba7f71061d",
    "predictions": [
      "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: Pubsub = None \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: Pubsub = None \n \n",
      "1": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: Pubsub = [] \n \n",
      "2": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: List[str] = None \n \n",
      "3": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List = [] \n self.pubsub: Pubsub = None \n \n",
      "4": "# pylint: disable=too-many-arguments \n <IND> self.protocols: List[str] = [] \n self.pubsub: List[PubSub] = None \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n\n",
    "warning_line": "    name: str = ormar.String(max_length=100)",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `name` declared in class `Album` has type `str` but is used as type `ormar.fields.model_fields.String`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 22,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_new_annotation_style.py",
    "target_filename": "tests/test_new_annotation_style.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "1": "\n <IND> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "2": "\n \n id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "3": "<DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n",
      "4": "<IND> <DED> id = ormar.Integer(primary_key=True) \n name = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": "\n        <DED>self.memo_text: bytes = text\n        if not isinstance(text, bytes):\n            <IND>self.memo_text = bytes(text, encoding=\"utf-8\")\n\n",
    "target_code": "\n        <DED>if not isinstance(text, bytes):\n            <IND>text = bytes(text, encoding=\"utf-8\")\n        <DED>self.memo_text: bytes = text\n\n",
    "warning_line": "        self.memo_text: bytes = text",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `memo_text` declared in class `TextMemo` has type `bytes` but is used as type `Union[bytes, str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 99,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "StellarCN/py-stellar-base",
    "source_filename": "stellar_sdk/memo.py",
    "target_filename": "stellar_sdk/memo.py",
    "source_changeid": "fb330563ff2269540bfbfd662fa535080d1cc1f6^",
    "target_changeid": "fb330563ff2269540bfbfd662fa535080d1cc1f6",
    "predictions": [
      "\n <DED> self.memo_text: Union[bytes, bytes] = text \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> self.memo_text: Union[bytes, bytes] = text \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "1": "\n <DED> self.memo_text: bytes = text \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "2": "\n <DED> self.memo_text: Union[bytes, str] = bytes \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "3": "\n <DED> self.memo_text: bytes = [] \n if not isinstance(text, bytes): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n",
      "4": "\n <DED> self.memo_text: bytes = text \n if not isinstance(text): \n <IND> self.memo_text = bytes(text, encoding=\"utf-8\") \n \n"
    }
  },
  {
    "source_code": "\n    <DED>id: int = ormar.Integer(primary_key=True)\n    album: Album = ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title: str = ormar.String(max_length=100)\n\n",
    "target_code": "\n    <DED>id = ormar.Integer(primary_key=True)\n    album= ormar.ForeignKey(Album, related_name=\"cover_pictures\")\n    title = ormar.String(max_length=100)\n\n",
    "warning_line": "    title: str = ormar.String(max_length=100)",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `title` declared in class `Cover` has type `str` but is used as type `ormar.fields.model_fields.String`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 45,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "collerek/ormar",
    "source_filename": "tests/test_new_annotation_style.py",
    "target_filename": "tests/test_new_annotation_style.py",
    "source_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c^",
    "target_changeid": "7d5e291a19e2ed21f264a17970e6ffd31ef1c73c",
    "predictions": [
      "\n <DED> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title= ormar.String(max_length=100) \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n <DED> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title= ormar.String(max_length=100) \n \n",
      "1": "\n <DED> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "2": "\n <DED> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n",
      "3": "\n <IND> id = ormar.Integer(primary_key=True) \n album= ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title= ormar.String(max_length=100) \n \n",
      "4": "\n <IND> id = ormar.Integer(primary_key=True) \n album = ormar.ForeignKey(Album, related_name=\"cover_pictures\") \n title = ormar.String(max_length=100) \n \n"
    }
  },
  {
    "source_code": "    <IND>def __init__(self) -> None:\n        <IND>self._name = self.title = self.gender = self.description = self.short_description = None  # type: str\n        self.money = mud_context.config.player_money\n",
    "target_code": "    <IND>def __init__(self) -> None:\n        <IND>self._name = self.title = self.gender = self.description = self.short_description = \"\"\n        self.money = mud_context.config.player_money\n",
    "warning_line": "        self._name = self.title = self.gender = self.description = self.short_description = None  # type: str",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `_name` declared in class `PlayerNaming` has type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 20,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "irmen/Tale",
    "source_filename": "tale/charbuilder.py",
    "target_filename": "tale/charbuilder.py",
    "source_changeid": "0a78d4a821d7da405bf5335ba3741757f0b593fe^",
    "target_changeid": "0a78d4a821d7da405bf5335ba3741757f0b593fe",
    "predictions": [
      "<IND> def __init__(self) -> None: \n <IND> self._name = self.title = self.gender = self.description = self.short_description = \"\" \n self.money = mud_context.config.player_money \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> def __init__(self) -> None: \n <IND> self._name = self.title = self.gender = self.description = self.short_description = \"\" \n self.money = mud_context.config.player_money \n",
      "1": "<DED> def __init__(self) -> None: \n <IND> self._name = self.title = self.gender = self.description = self.short_description = \"\" \n self.money = mud_context.config.player_money \n",
      "2": "<IND> def __init__(self) -> None: \n <IND> self._name = self.title = self.gender = self.description = self.short_description = '' \n self.money = mud_context.config.player_money \n",
      "3": "<IND> def __init__(self) -> None: \n <DED> self._name = self.title = self.gender = self.description = self.short_description = \"\" \n self.money = mud_context.config.player_money \n",
      "4": "\n def __init__(self) -> None: \n <IND> self._name = self.title = self.gender = self.description = self.short_description = \"\" \n self.money = mud_context.config.player_money \n"
    }
  },
  {
    "source_code": "        val: Any = None\n        next: \"Deque._Node\" = None\n        prev: \"Deque._Node\" = None\n\n",
    "target_code": "        val: Any = None\n        next: Deque._Node | None = None\n        prev: Deque._Node | None = None\n\n",
    "warning_line": "        prev: \"Deque._Node\" = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `prev` declared in class `Deque._Node` has type `Deque._Node` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 55,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "TheAlgorithms/Python",
    "source_filename": "data_structures/queue/double_ended_queue.py",
    "target_filename": "data_structures/queue/double_ended_queue.py",
    "source_changeid": "8285913e81fb8f46b90d0e19da233862964c07dc^",
    "target_changeid": "8285913e81fb8f46b90d0e19da233862964c07dc",
    "predictions": [
      "val: Any = None \n next: Optional[\"Deque._Node\"] = None \n prev: Optional[\"Deque._Node\"] = None \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "val: Any = None \n next: Optional[\"Deque._Node\"] = None \n prev: Optional[\"Deque._Node\"] = None \n \n",
      "1": "val: Any = None \n next: Deque._Node | None = None \n prev: Deque._Node | None = None \n \n",
      "2": "val: Any = None \n next: Deque._Node = None \n prev: Deque._Node = None \n \n",
      "3": "val: Any = None \n next: \"Deque._Node\" = None \n prev: \"Deque._Node\" = None \n \n",
      "4": "val: Any = None \n next: Deque._Node() \n prev: Deque._Node() \n \n"
    }
  },
  {
    "source_code": "            m.author = self.chat_manager.self\n            m.chat = self.chat_manager.get_chat(channel, uid)\n            if not m.chat:\n                # Chat not found anyway, build a fake object\n",
    "target_code": "            m.author = self.chat_manager.self\n            m_chat = self.chat_manager.get_chat(channel, uid)\n            if not m_chat:\n                # Chat not found anyway, build a fake object\n",
    "warning_line": "            m.chat = self.chat_manager.get_chat(channel, uid)",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `chat` declared in class `ETMMsg` has type `efb_telegram_master.chat.ETMChat` but is used as type `Optional[efb_telegram_master.chat.ETMChat]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 271,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ehForwarderBot/efb-telegram-master",
    "source_filename": "efb_telegram_master/master_message.py",
    "target_filename": "efb_telegram_master/master_message.py",
    "source_changeid": "ba3d8d85152e2e58a8385a74f19be04c5c7a4fe6^",
    "target_changeid": "ba3d8d85152e2e58a8385a74f19be04c5c7a4fe6",
    "predictions": [
      "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, uid) \n if not m.chat: \n # Chat not found anyway, build a fake object \n"
    ],
    "correct": false,
    "top_five": {
      "0": "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, uid) \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "1": "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, efb_telegram_master.chat.ETMChat) \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "2": "m.author = self.chat_manager.self \n m.chat_manager = self.chat_manager.get_chat(channel, uid) \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "3": "m.author = self.chat_manager.self \n m.chat = self.chat_manager.get_chat(channel, uid).get_chat \n if not m.chat: \n # Chat not found anyway, build a fake object \n",
      "4": "m.author = self.chat_manager.self \n m.chat_manager = self.chat_manager.get_chat(channel, uid) \n if not m.chat_manager: \n # Chat not found anyway, build a fake object \n"
    }
  },
  {
    "source_code": "    <IND>request_class: Type[Response] = field()\n    extra_data: Tuple = None\n\n",
    "target_code": "    <IND>request_class: Type[Response] = field()\n    extra_data: Tuple = ()\n\n",
    "warning_line": "    extra_data: Tuple = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `extra_data` declared in class `RequestInfo` has type `typing.Tuple[typing.Any, ...]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 93,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "poljar/matrix-nio",
    "source_filename": "nio/client/http_client.py",
    "target_filename": "nio/client/http_client.py",
    "source_changeid": "bb2eeca8c4f591d828f657d466fd3ff1ef5842d8^",
    "target_changeid": "bb2eeca8c4f591d828f657d466fd3ff1ef5842d8",
    "predictions": [
      "<IND> request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n",
      "1": "<DED> request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n",
      "2": "\n request_class: Type[Response] = field() \n extra_data: Optional[Tuple] = None \n \n",
      "3": "<IND> request_class: Type[Response] = field() \n extra_data: Tuple \n \n",
      "4": "<IND> request_class: Type[Response] = field() \n extra_data: Optional[tuple] = None \n \n"
    }
  },
  {
    "source_code": "        <IND>\"\"\"Initialise driver.\"\"\"\n        self.hw_driver = None   # type: DriverPlatformInterface\n        super().__init__(machine, name)\n        self.delay = DelayManager(self.machine)\n        self.platform = None                # type: DriverPlatform\n\n",
    "target_code": "        <IND>\"\"\"Initialise driver.\"\"\"\n        self.hw_driver = None   # type: Optional[DriverPlatformInterface]\n        super().__init__(machine, name)\n        self.delay = DelayManager(self.machine)\n        self.platform = None                # type: Optional[DriverPlatform]\n\n",
    "warning_line": "        self.hw_driver = None   # type: DriverPlatformInterface",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `hw_driver` declared in class `Driver` has type `DriverPlatformInterface` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 36,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "missionpinball/mpf",
    "source_filename": "mpf/devices/driver.py",
    "target_filename": "mpf/devices/driver.py",
    "source_changeid": "4dbcd2cdbc16939332b76efdfeb1ae3a0ede0278^",
    "target_changeid": "4dbcd2cdbc16939332b76efdfeb1ae3a0ede0278",
    "predictions": [
      "<IND> \"\"\"Initialise driver.\"\"\" \n self.hw_driver = None # type: Optional[DriverPlatformInterface] \n super().__init__(machine, name) \n self.delay = DelayManager(self.machine) \n self.platform = None # type: Optional[DriverPlatform] \n \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> \"\"\"Initialise driver.\"\"\" \n self.hw_driver = None # type: Optional[DriverPlatformInterface] \n super().__init__(machine, name) \n self.delay = DelayManager(self.machine) \n self.platform = None # type: Optional[DriverPlatform] \n \n",
      "1": "<DED> \"\"\"Initialise driver.\"\"\" \n self.hw_driver = None # type: Optional[DriverPlatformInterface] \n super().__init__(machine, name) \n self.delay = DelayManager(self.machine) \n self.platform = None # type: Optional[DriverPlatform] \n \n",
      "2": "<IND> \"\"\"Initialise driver.\"\"\" \n self.hw_driver = \"\" # type: Optional[DriverPlatformInterface] \n super().__init__(machine, name) \n self.delay = DelayManager(self.machine) \n self.platform = \"\" # type: Optional[DriverPlatform] \n \n",
      "3": "\n \"\"\"Initialise driver.\"\"\" \n self.hw_driver = None # type: Optional[DriverPlatformInterface] \n super().__init__(machine, name) \n self.delay = DelayManager(self.machine) \n self.platform = None # type: Optional[DriverPlatform] \n \n",
      "4": "<IND> \"\"\"Initialise driver.\"\"\" \n self.hw_driver = \"\" # type: Optional[DriverPlatformInterface] \n super().__init__(machine, name) \n self.delay = DelayManager(self.machine) \n self.platform = None # type: Optional[DriverPlatform] \n \n"
    }
  },
  {
    "source_code": "    # Contains a hash of the public interface in incremental mode\n    interface_hash = \"\"  # type: str\n\n    # Options, specialized for this file\n    options = None  # type: Options\n\n",
    "target_code": "    # Contains a hash of the public interface in incremental mode\n    interface_hash: str = \"\"\n\n    # Options, specialized for this file\n    options: Options\n\n",
    "warning_line": "    options = None  # type: Options",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `options` declared in class `State` has type `Options` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1772,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "python/mypy",
    "source_filename": "mypy/build.py",
    "target_filename": "mypy/build.py",
    "source_changeid": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe^",
    "target_changeid": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "predictions": [
      "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options = None # type: Options \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options = None # type: Options \n \n",
      "1": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options: Optional[str] \n \n",
      "2": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: Optional[str] \n \n # Options, specialized for this file \n options = None # type: Optional[str] \n \n",
      "3": "# Contains a hash of the public interface in incremental mode \n interface_hash: Optional[str] = \"\" \n \n # Options, specialized for this file \n options: Optional[str] = None \n \n",
      "4": "# Contains a hash of the public interface in incremental mode \n interface_hash = \"\" # type: str \n \n # Options, specialized for this file \n options: Optional[str] = None \n \n"
    }
  },
  {
    "source_code": "    ioc_type: str\n    safe_ioc: str = None\n    query_subtype: Optional[str] = None\n",
    "target_code": "    ioc_type: str\n    safe_ioc: str = \"\"\n    query_subtype: Optional[str] = None\n",
    "warning_line": "    safe_ioc: str = None",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `safe_ioc` declared in class `LookupResult` has type `str` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 126,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "microsoft/msticpy",
    "source_filename": "msticpy/sectools/tiproviders/ti_provider_base.py",
    "target_filename": "msticpy/sectools/tiproviders/ti_provider_base.py",
    "source_changeid": "9a28ea1687acb5e18a44219fd090ad3ed83b0228^",
    "target_changeid": "9a28ea1687acb5e18a44219fd090ad3ed83b0228",
    "predictions": [
      "ioc_type: str \n safe_ioc: Optional[str] = None \n query_subtype: Optional[str] = None \n"
    ],
    "correct": false,
    "top_five": {
      "0": "ioc_type: str \n safe_ioc: Optional[str] = None \n query_subtype: Optional[str] = None \n",
      "1": "ioc_type: str \n safe_ioc: str \n query_subtype: Optional[str] = None \n",
      "2": "ioc_type: str \n safe_ioc: str = '' \n query_subtype: Optional[str] = None \n",
      "3": "ioc_type: str \n safe_ioc: str <IND> query_subtype: Optional[str] = None \n",
      "4": "ioc_type: str \n safe_ioc: str <DED> query_subtype: Optional[str] = None \n"
    }
  },
  {
    "source_code": "\n    <DED>ARG_REGS: List[str] = None                                  # A list of all the registers used for integral args, in order (names or offsets)\n    FP_ARG_REGS: List[str] = None                               # A list of all the registers used for floating point args, in order\n    STACKARG_SP_BUFF = 0                                        # The amount of stack space reserved between the saved return address\n",
    "target_code": "\n    <DED>ARG_REGS: List[str] = []                                    # A list of all the registers used for integral args, in order (names or offsets)\n    FP_ARG_REGS: List[str] = []                                 # A list of all the registers used for floating point args, in order\n    STACKARG_SP_BUFF = 0                                        # The amount of stack space reserved between the saved return address\n",
    "warning_line": "    ARG_REGS: List[str] = None                                  # A list of all the registers used for integral args, in order (names or offsets)",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `ARG_REGS` declared in class `SimCC` has type `List[str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 352,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "angr/angr",
    "source_filename": "angr/calling_conventions.py",
    "target_filename": "angr/calling_conventions.py",
    "source_changeid": "98cc88d3cb9a577fd001977d8515d43075aa619f^",
    "target_changeid": "98cc88d3cb9a577fd001977d8515d43075aa619f",
    "predictions": [
      "\n <DED> ARG_REGS: List[str] = [] # A list of all the registers used for integral args, in order (names or offsets) \n FP_ARG_REGS: List[str] = [] # A list of all the registers used for floating point args, in order \n STACKARG_SP_BUFF = 0 # The amount of stack space reserved between the saved return address \n"
    ],
    "correct": true,
    "top_five": {
      "0": "\n <DED> ARG_REGS: List[str] = [] # A list of all the registers used for integral args, in order (names or offsets) \n FP_ARG_REGS: List[str] = [] # A list of all the registers used for floating point args, in order \n STACKARG_SP_BUFF = 0 # The amount of stack space reserved between the saved return address \n",
      "1": "\n <DED> ARG_REGS: List[str] = None # A list of all the registers used for integral args, in order (names or offsets) \n FP_ARG_REGS: List[str] = None # A list of all the registers used for floating point args, in order \n STACKARG_SP_BUFF = 0 # The amount of stack space reserved between the saved return address \n",
      "2": "\n <IND> ARG_REGS: List[str] = [] # A list of all the registers used for integral args, in order (names or offsets) \n FP_ARG_REGS: List[str] = [] # A list of all the registers used for floating point args, in order \n STACKARG_SP_BUFF = 0 # The amount of stack space reserved between the saved return address \n",
      "3": "\n \n ARG_REGS: List[str] = [] # A list of all the registers used for integral args, in order (names or offsets) \n FP_ARG_REGS: List[str] = [] # A list of all the registers used for floating point args, in order \n STACKARG_SP_BUFF = 0 # The amount of stack space reserved between the saved return address \n",
      "4": "\n <DED> ARG_REGS: List[str] = [] # A list of all the registers used for integral args, in order (names or offsets) \n FP_ARG_REGS: List[str] = [] # A list of all the registers used for floating point args, in order \n STACKARG_SP_BUFF = 0 # The amount of stack space reserved between the saved return address \n \n"
    }
  },
  {
    "source_code": "\n    body: List[Union[Comment, Statement]] = field(default=list)\n",
    "target_code": "\n    __slots__ = {'lineno', 'col_offset', 'raw_text', 'text', 'body'}\n\n    body: List[Union[Comment, Statement]]\n",
    "warning_line": "    body: List[Union[Comment, Statement]] = field(default=list)",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `body` declared in class `Module` has type `List[Union[Comment, Statement]]` but is used as type `typing.Type[list]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 139,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "wemake-services/dotenv-linter",
    "source_filename": "dotenv_linter/grammar/fst.py",
    "target_filename": "dotenv_linter/grammar/fst.py",
    "source_changeid": "69892deec3de61824124bfe3e1da9182f1527ba6^",
    "target_changeid": "69892deec3de61824124bfe3e1da9182f1527ba6",
    "predictions": [
      "\n body: List[Comment, Statement] = field(default=list) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n body: List[Comment, Statement] = field(default=list) \n",
      "1": "\n body: List[Comment, Statement] = field(default=str) \n",
      "2": "\n body: List[Comment, Statement] = field(default=global[list]) \n",
      "3": "\n body: list[Comment, Statement] = field(default=list) \n",
      "4": "\n body: List[Comment, Statement] = field(default=field) \n"
    }
  },
  {
    "source_code": "        #  Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()  # type: frozenset[str]\n        self._used_values = frozenset()\n\n        self._compiled = None\n        self._valid = False  # type: str\n\n",
    "target_code": "        #  Keys of all settings that are referenced to in this function.\n        self._used_keys = frozenset()  # type: FrozenSet[str]\n        self._used_values = frozenset() # type: FrozenSet[str]\n\n        self._compiled = None\n        self._valid = False  # type: bool\n\n",
    "warning_line": "        self._valid = False  # type: str",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `_valid` declared in class `SettingFunction` has type `str` but is used as type `bool`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 39,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Uranium",
    "source_filename": "UM/Settings/SettingFunction.py",
    "target_filename": "UM/Settings/SettingFunction.py",
    "source_changeid": "f19f64136988856b95ba86888483c150f7c1a076^",
    "target_changeid": "f19f64136988856b95ba86888483c150f7c1a076",
    "predictions": [
      "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n",
      "1": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() # type: frozenset[str] \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n",
      "2": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() # type: frozenset[str] \n self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: str \n \n",
      "3": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() <DED> self._used_values = frozenset() \n self._compiled = None \n self._valid = False # type: bool \n \n",
      "4": "# Keys of all settings that are referenced to in this function. \n self._used_keys = frozenset() \n self._used_values = frozenset() \n self._compiled = False \n self._valid = False # type: bool \n \n"
    }
  },
  {
    "source_code": "            # wait at least 2 mins to try again\n            <IND>self.online_lookup_timeout = time.time() + 2 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
    "target_code": "            # wait at least 2 mins to try again\n            <IND>self.online_lookup_timeout = int(time.time()) + 2 * 60\n            log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole)\n",
    "warning_line": "            self.online_lookup_timeout = time.time() + 2 * 60",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `online_lookup_timeout` declared in class `SignatureDB` has type `int` but is used as type `float`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 229,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "ConsenSys/mythril",
    "source_filename": "mythril/support/signatures.py",
    "target_filename": "mythril/support/signatures.py",
    "source_changeid": "d35bb7892f2ebde220103b105d49bf6ec8a5d5e6^",
    "target_changeid": "d35bb7892f2ebde220103b105d49bf6ec8a5d5e6",
    "predictions": [
      "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 2 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 2 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "1": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + \"\" \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "2": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 0 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "3": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + '60' \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n",
      "4": "# wait at least 2 mins to try again \n <IND> self.online_lookup_timeout = time.time() + 0.5 * 60 \n log.warning(\"Online lookup failed, not retrying for 2min: %s\", fbdole) \n"
    }
  },
  {
    "source_code": "\n    messages = None  # type: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker = None  # type: Optional[str]\n\n",
    "target_code": "\n    messages: List[str]\n    use_stdout = False\n    # Can be set in case there was a module with a blocking error\n    module_with_blocker: Optional[str] = None\n\n",
    "warning_line": "    messages = None  # type: List[str]",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `messages` declared in class `CompileError` has type `List[str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 730,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "python/mypy",
    "source_filename": "mypy/errors.py",
    "target_filename": "mypy/errors.py",
    "source_changeid": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe^",
    "target_changeid": "f98f78216ba9d6ab68c8e69c19e9f3c7926c5efe",
    "predictions": [
      "\n messages: List[str] \n use_stdout: List[str] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n"
    ],
    "correct": false,
    "top_five": {
      "0": "\n messages: List[str] \n use_stdout: List[str] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "1": "\n messages = None # type: Optional[List[str]] \n use_stdout = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker = None # type: Optional[str] \n \n",
      "2": "\n messages: List[str] \n use_stdout: Optional[stdout] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "3": "\n messages: Optional[List[str]] \n use_stdout: Optional[False] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n",
      "4": "\n messages: Optional[List[str]] \n use_stdout: Optional[stdout] = False \n # Can be set in case there was a module with a blocking error \n module_with_blocker: Optional[str] \n \n"
    }
  },
  {
    "source_code": "    STACKARG_SP_DIFF = 0                                        # The amount of stack space reserved for the return address\n    CALLER_SAVED_REGS: List[str] = None                         # Caller-saved registers\n    RETURN_ADDR: SimFunctionArgument = None                     # The location where the return address is stored, as a SimFunctionArgument\n",
    "target_code": "    STACKARG_SP_DIFF = 0                                        # The amount of stack space reserved for the return address\n    CALLER_SAVED_REGS: List[str] = []                           # Caller-saved registers\n    RETURN_ADDR: SimFunctionArgument = None                     # The location where the return address is stored, as a SimFunctionArgument\n",
    "warning_line": "    CALLER_SAVED_REGS: List[str] = None                         # Caller-saved registers",
    "linter_report": {
      "rule_id": "Incompatible attribute type [8]",
      "message": " Attribute `CALLER_SAVED_REGS` declared in class `SimCC` has type `List[str]` but is used as type `None`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 357,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "angr/angr",
    "source_filename": "angr/calling_conventions.py",
    "target_filename": "angr/calling_conventions.py",
    "source_changeid": "98cc88d3cb9a577fd001977d8515d43075aa619f^",
    "target_changeid": "98cc88d3cb9a577fd001977d8515d43075aa619f",
    "predictions": [
      "STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] = [] # Caller-saved registers \n RETURN_ADDR: SimFunctionArgument = None # The location where the return address is stored, as a SimFunctionArgument \n"
    ],
    "correct": true,
    "top_five": {
      "0": "STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] = [] # Caller-saved registers \n RETURN_ADDR: SimFunctionArgument = None # The location where the return address is stored, as a SimFunctionArgument \n",
      "1": "STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] = [] # Caller-saved registers \n RETURN_ADDR: SimFunctionArgument = None # The location where the return address is stored, as a SimFunctionArgument \n STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] =",
      "2": "STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] = [] \n RETURN_ADDR: SimFunctionArgument = None # The location where the return address is stored, as a SimFunctionArgument \n",
      "3": "STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] = [] # Caller-saved registers \n RETURN_ADDR: SimFunctionArgument = [] # The location where the return address is stored, as a SimFunctionArgument \n",
      "4": "STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n CALLER_SAVED_REGS: List[str] = [] # Caller-saved registers \n RETURN_ADDR: SimFunctionArgument = None # The location where the return address is stored, as a SimFunctionArgument \n STACKARG_SP_DIFF = 0 # The amount of stack space reserved for the return address \n"
    }
  },
  {
    "source_code": "                <IND>if not ignoreObjectAttribs:\n                    <IND>outfile.write(line.encode('utf8')+'\\n')\n                <DED>else:\n",
    "target_code": "                <IND>if not ignoreObjectAttribs:\n                    <IND>outfile.write(line+'\\n')\n                <DED>else:\n",
    "warning_line": "                    outfile.write(line.encode('utf8')+'\\n')",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `+` is not supported for operand types `bytes` and `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 111,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "psychopy/psychopy",
    "source_filename": "psychopy/tests/test_app/test_builder/genComponsTemplate.py",
    "target_filename": "psychopy/tests/test_app/test_builder/genComponsTemplate.py",
    "source_changeid": "f120e91f49d9f6b0d7fe7f4de0e42f4fbf9295a3^",
    "target_changeid": "f120e91f49d9f6b0d7fe7f4de0e42f4fbf9295a3",
    "predictions": [
      "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <DED> else: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <DED> else: \n",
      "1": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n').encode('utf8') \n <DED> else: \n",
      "2": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <IND> else: \n",
      "3": "<IND> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n \n else: \n",
      "4": "<DED> if not ignoreObjectAttribs: \n <IND> outfile.write(line+' \\ n') \n <DED> else: \n"
    }
  },
  {
    "source_code": "        <DED>else:\n            <IND>assert datetime_before < trial.datetime_start < datetime_after\n            assert trial.datetime_complete is None\n\n",
    "target_code": "        <DED>else:\n            <IND>assert trial.datetime_start is not None\n            assert trial.datetime_complete is None\n            assert datetime_before < trial.datetime_start < datetime_after\n\n",
    "warning_line": "            assert datetime_before < trial.datetime_start < datetime_after",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `<` is not supported for operand types `typing.Optional[datetime]` and `datetime`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 396,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "optuna/optuna",
    "source_filename": "tests/storages_tests/test_storages.py",
    "target_filename": "tests/storages_tests/test_storages.py",
    "source_changeid": "8917099bb57bb168116e0cb4343ddb82876abb04^",
    "target_changeid": "8917099bb57bb168116e0cb4343ddb82876abb04",
    "predictions": [
      "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n",
      "1": "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n",
      "2": "<DED> else: \n <IND> assert trial.datetime_start is not None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n",
      "3": "<DED> else: \n <IND> assert trial.datetime_complete is None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n \n",
      "4": "<DED> else: \n <IND> assert trial.datetime_start is not None \n assert trial.datetime_complete is None \n assert datetime_before  trial.datetime_start  datetime_after \n \n"
    }
  },
  {
    "source_code": "            <IND>return self.label\n        <DED>elif self.label < label:\n            <IND>if self.right:\n",
    "target_code": "            <IND>return self.label\n        <DED>elif self.label is not None and self.label < label:\n            <IND>if self.right:\n",
    "warning_line": "        elif self.label < label:",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `<` is not supported for operand types `typing.Optional[int]` and `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 383,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "TheAlgorithms/Python",
    "source_filename": "data_structures/binary_tree/red_black_tree.py",
    "target_filename": "data_structures/binary_tree/red_black_tree.py",
    "source_changeid": "7a605766fe7fe79a00ba1f30447877be4b77a6f2^",
    "target_changeid": "7a605766fe7fe79a00ba1f30447877be4b77a6f2",
    "predictions": [
      "<IND> return self.label \n <DED> elif self.label is not None and self.label  label: \n <IND> if self.right: \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<IND> return self.label \n <DED> elif self.label is not None and self.label  label: \n <IND> if self.right: \n",
      "1": "<IND> return self.label \n <DED> elif self.label is not None and self.label is not None and self.label  label: \n <IND> if self.right: \n",
      "2": "<IND> return self.label \n <IND> elif self.label is not None and self.label  label: \n <IND> if self.right: \n",
      "3": "<IND> return self.label \n \n <DED> elif self.label is not None and self.label  label: \n <IND> if self.right: \n",
      "4": "<IND> return self.label \n <DED> elif self.label  int: \n <IND> if self.right: \n"
    }
  },
  {
    "source_code": "    ):\n        <IND>set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\n",
    "target_code": "    ):\n        <IND>if cfg_key is None:\n            <IND>cfg_key = camelCaseify(trait)\n        <DED>set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\n",
    "warning_line": "        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `+` is not supported for operand types `str` and `typing.Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 291,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jupyterhub/zero-to-jupyterhub-k8s",
    "source_filename": "images/hub/jupyterhub_config.py",
    "target_filename": "images/hub/jupyterhub_config.py",
    "source_changeid": "4e9b4a22f516a7f7545c1cfebe440f0b2dde5a6d^",
    "target_changeid": "4e9b4a22f516a7f7545c1cfebe440f0b2dde5a6d",
    "predictions": [
      "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n",
      "1": "): \n <IND> assert cfg_authenticator is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n",
      "2": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.') \n",
      "3": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, cfg_key) \n",
      "4": "): \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key) \n \n"
    }
  },
  {
    "source_code": "        if self._enable_request_benchmarking:\n            <IND>time_spent = time.time() - request_data.start_time\n            Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
    "target_code": "        if self._enable_request_benchmarking:\n            <IND>time_spent = None  # type: Optional[float]\n            if request_data.start_time is not None:\n                <IND>time_spent = time.time() - request_data.start_time\n            <DED>Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\",\n",
    "warning_line": "            time_spent = time.time() - request_data.start_time",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `-` is not supported for operand types `float` and `Optional[float]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 340,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "Ultimaker/Uranium",
    "source_filename": "UM/TaskManagement/HttpRequestManager.py",
    "target_filename": "UM/TaskManagement/HttpRequestManager.py",
    "source_changeid": "cc9ae324e35ef54e418133f15dc30844a86aa963^",
    "target_changeid": "cc9ae324e35ef54e418133f15dc30844a86aa963",
    "predictions": [
      "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - Optional[request_data.start_time] \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n"
    ],
    "correct": false,
    "top_five": {
      "0": "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - Optional[request_data.start_time] \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "1": "if self._enable_request_benchmarking: \n <IND> time_spent = float(time.time() - request_data.start_time) \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "2": "if self._enable_request_benchmarking: \n <IND> if self._enable_request_benchmarking is not None: \n <IND> time_spent = time.time() - request_data.start_time \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "3": "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - request_data.start_time \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n",
      "4": "if self._enable_request_benchmarking: \n <IND> time_spent = time.time() - float(request_data.start_time) \n Logger.log(\"d\", \"Request [%s] finished, took %s seconds, pending for %s seconds\", \n"
    }
  },
  {
    "source_code": "                <IND>tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n        <DED><DED>return tot - travel_time - self.HOLD_TIME\n",
    "target_code": "                <IND>tot = flight.flight_plan.tot_for_waypoint(tot_waypoint)\n                if tot is None:\n                    <IND>logging.error(f\"TOT waypoint for {flight} has no TOT\")\n                    tot = self.package.time_over_target\n        <DED><DED><DED>return tot - travel_time - self.HOLD_TIME\n",
    "warning_line": "        return tot - travel_time - self.HOLD_TIME",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `-` is not supported for operand types `Optional[timedelta]` and `timedelta`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 136,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "dcs-liberation/dcs_liberation",
    "source_filename": "gen/flights/traveltime.py",
    "target_filename": "gen/flights/traveltime.py",
    "source_changeid": "8eef1eaa7cdcd8f9672a93dc5e8f9771a1ce9a3d^",
    "target_changeid": "8eef1eaa7cdcd8f9672a93dc5e8f9771a1ce9a3d",
    "predictions": [
      "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - self.HOLD_TIME \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - self.HOLD_TIME \n",
      "1": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> assert tot is not None \n return tot - travel_time - self.HOLD_TIME \n",
      "2": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - (self.HOLD_TIME) \n",
      "3": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - str(self.HOLD_TIME) \n",
      "4": "<IND> tot = flight.flight_plan.tot_for_waypoint(tot_waypoint) \n <DED> <DED> return tot - travel_time - 0 \n"
    }
  },
  {
    "source_code": "    result = scatter_workflow(range=3)\n    assert \"output\" in result\n",
    "target_code": "    result = scatter_workflow(range=3)\n    assert isinstance(result, dict)\n    assert \"output\" in result\n",
    "warning_line": "    assert \"output\" in result",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `in` is not supported for right operand type `Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], typing.MutableSequence[Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], bool, float, int, str]], typing.MutableSequence[Union[None, typing.MutableMapping[str, Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], typing.MutableSequence[Union[None, typing.MutableMapping[str, typing.Any], typing.MutableSequence[typing.Any], bool, float, int, str]], bool, float, int, str]], bool, float, int, str]], str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1378,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "common-workflow-language/cwltool",
    "source_filename": "tests/test_examples.py",
    "target_filename": "tests/test_examples.py",
    "source_changeid": "189a496366d46754f96c7aefa0db7f3e26bd5453^",
    "target_changeid": "189a496366d46754f96c7aefa0db7f3e26bd5453",
    "predictions": [
      "\n if not isinstance(str, args): int = 0; for ( <DED> in args) if not isinstance(str, args) -> None: \n"
    ],
    "correct": false,
    "top_five": {
      "0": "result = scatter_workflow(range=3) \n assert \"output\" in result \n",
      "1": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "2": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "3": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n",
      "4": "result = scatter_workflow(range=3) \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n assert output is not None \n"
    }
  },
  {
    "source_code": "        <DED>msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        search_space_start_idx = msgsend_idx - 3\n",
    "target_code": "        <DED>msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address)\n        if not msgsend_idx:\n            <IND>raise ValueError(f'instruction index not found for address {msgsend_instr.address}')\n\n        <DED>search_space_start_idx = msgsend_idx - 3\n",
    "warning_line": "        search_space_start_idx = msgsend_idx - 3",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `-` is not supported for operand types `Optional[int]` and `int`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 317,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "datatheorem/strongarm",
    "source_filename": "strongarm/objc/objc_analyzer.py",
    "target_filename": "strongarm/objc/objc_analyzer.py",
    "source_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8^",
    "target_changeid": "ab620d78b4ce7f933cedc25960307f2c3b03c1a8",
    "predictions": [
      "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n assert msgsend_idx is not None \n search_space_start_idx = msgsend_idx - 3 \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n assert msgsend_idx is not None \n search_space_start_idx = msgsend_idx - 3 \n",
      "1": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n search_space_start_idx = int(msgsend_idx) - 3 \n",
      "2": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n return self._get_instruction_index_of_address(msgsend_instr.address) \n search_space_start_idx = int(msgsend_idx) - 3 \n",
      "3": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n return self._get_instruction_index_of_address(msgsend_instr.address) \n search_space_start_idx = msgsend_idx - 3 \n",
      "4": "<DED> msgsend_idx = self._get_instruction_index_of_address(msgsend_instr.address) \n assert isinstance(msgsend_idx, int, search_space_start_idx) - 3 \n"
    }
  },
  {
    "source_code": "    <DED>def check_validation_begin(self, executor) -> bool:\n        <IND>if self.only_training:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
    "target_code": "    <DED>def check_validation_begin(self, executor) -> bool:\n        <IND>if self.only_training and self.start_time is not None:\n            <IND>self.accumulated_time += time_now() - self.start_time\n",
    "warning_line": "            self.accumulated_time += time_now() - self.start_time",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `-` is not supported for operand types `float` and `Optional[float]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 284,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "asyml/texar-pytorch",
    "source_filename": "texar/torch/run/condition.py",
    "target_filename": "texar/torch/run/condition.py",
    "source_changeid": "eddb39e91420aa61675cae9bf6479d43432e18ef^",
    "target_changeid": "eddb39e91420aa61675cae9bf6479d43432e18ef",
    "predictions": [
      "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n"
    ],
    "correct": false,
    "top_five": {
      "0": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "1": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training and self.start_time is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "2": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += float(time_now() - self.start_time) \n",
      "3": "<DED> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is None: \n <IND> self.accumulated_time += time_now() - self.start_time \n",
      "4": "<IND> def check_validation_begin(self, executor) -> bool: \n <IND> if self.only_training is not None: \n <IND> self.accumulated_time += time_now() - self.start_time \n"
    }
  },
  {
    "source_code": "        self.pin_memory = pin_memory\n        if downsample is not None and not (0 < self.downsample <= 1):\n            <IND>raise ValueError(\"Downsample value should be in the range (0, 1]\")\n",
    "target_code": "        self.pin_memory = pin_memory\n        if downsample is not None and not (0 < downsample <= 1):\n            <IND>raise ValueError(\"Downsample value should be in the range (0, 1]\")\n",
    "warning_line": "        if downsample is not None and not (0 < self.downsample <= 1):",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `<` is not supported for operand types `int` and `Optional[float]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 247,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "asappresearch/flambe",
    "source_filename": "flambe/sampler/base.py",
    "target_filename": "flambe/sampler/base.py",
    "source_changeid": "2cc0612eea63f75261911392ec48ab84eda9f0f9^",
    "target_changeid": "2cc0612eea63f75261911392ec48ab84eda9f0f9",
    "predictions": [
      "self.pin_memory = pin_memory \n if downsample is not None and not (0  downsample = 1): \n <IND> raise ValueError(\"Downsample value should be in the range (0, 1]\") \n"
    ],
    "correct": true,
    "top_five": {
      "0": "self.pin_memory = pin_memory \n if downsample is not None and not (0  downsample = 1): \n <IND> raise ValueError(\"Downsample value should be in the range (0, 1]\") \n",
      "1": "self.pin_memory = pin_memory \n if downsample is not None and not (0  int(self.downsample) = 1): \n <IND> raise ValueError(\"Downsample value should be in the range (0, 1]\") \n",
      "2": "self.pin_memory = pin_memory \n if downsample is not None and not (0  float(self.downsample) = 1): \n <IND> raise ValueError(\"Downsample value should be in the range (0, 1]\") \n",
      "3": "self.pin_memory = pin_memory \n if downsample is None and not (0  downsample = 1): \n <IND> raise ValueError(\"Downsample value should be in the range (0, 1]\") \n",
      "4": "self.pin_memory = pin_memory \n if downsample is not None and not (0  downsample = 1): \n <DED> raise ValueError(\"Downsample value should be in the range (0, 1]\") \n"
    }
  },
  {
    "source_code": "        }\n    <DED>dl_root = downloads_dir() + '/cloud_watch_logs/'\n    summary_data['log_download_path'] = '{}{}'.format(dl_root, scan_time)\n",
    "target_code": "        }\n    <DED>dl_root = str(downloads_dir()) + '/cloud_watch_logs/'\n    summary_data['log_download_path'] = '{}{}'.format(dl_root, scan_time)\n",
    "warning_line": "    dl_root = downloads_dir() + '/cloud_watch_logs/'",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `+` is not supported for operand types `pathlib.Path` and `str`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 161,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "RhinoSecurityLabs/pacu",
    "source_filename": "pacu/modules/cloudwatch__download_logs/main.py",
    "target_filename": "pacu/modules/cloudwatch__download_logs/main.py",
    "source_changeid": "54b0de44c8fc862e652d0efb54077d0d1385f333^",
    "target_changeid": "54b0de44c8fc862e652d0efb54077d0d1385f333",
    "predictions": [
      "} \n <DED> dl_root = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "} \n <DED> dl_root = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "1": "} \n <DED> dl_root = downloads_dir() + str('/cloud_watch_logs/') \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "2": "} \n <DED> dl_root = downloads_dir(pathlib.Path) + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "3": "} \n <IND> dl_root = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n",
      "4": "} \n <DED> dl_root_dir = downloads_dir() + '/cloud_watch_logs/' \n summary_data['log_download_path'] ='{ } { } '.format(dl_root, scan_time) \n"
    }
  },
  {
    "source_code": "    for trait, cfg_key in common_oauth_traits:\n        <IND>set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
    "target_code": "    for trait, cfg_key in common_oauth_traits:\n        <IND>if cfg_key is None:\n            <IND>cfg_key = camelCaseify(trait)\n        <DED>set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\n",
    "warning_line": "        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `+` is not supported for operand types `str` and `typing.Optional[str]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 279,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "jupyterhub/zero-to-jupyterhub-k8s",
    "source_filename": "images/hub/jupyterhub_config.py",
    "target_filename": "images/hub/jupyterhub_config.py",
    "source_changeid": "4e9b4a22f516a7f7545c1cfebe440f0b2dde5a6d^",
    "target_changeid": "4e9b4a22f516a7f7545c1cfebe440f0b2dde5a6d",
    "predictions": [
      "for trait, cfg_key in common_oauth_traits: \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n"
    ],
    "correct": false,
    "top_five": {
      "0": "for trait, cfg_key in common_oauth_traits: \n <IND> assert cfg_key is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "1": "for trait, cfg_key in common_oauth_traits: \n <IND> assert isinstance(trait, cfg_key) \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "2": "for trait, cfg_key in common_oauth_traits: \n <IND> assert c.GitLabOAuthenticator is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "3": "for trait, cfg_key in common_oauth_traits: \n <IND> assert cfg_authenticator is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key) \n",
      "4": "for trait, cfg_key in common_oauth_traits: \n <IND> assert c.GitLabOAuthenticator is not None \n set_config_if_not_none(c.GitLabOAuthenticator, trait, cfg_key) \n"
    }
  },
  {
    "source_code": "    for t in trials:\n        <IND>assert datetime_before < t.datetime_start < datetime_after\n        if t.state.is_finished():\n            <IND>assert datetime_before < t.datetime_complete < datetime_after\n",
    "target_code": "    for t in trials:\n        <IND>assert t.datetime_start is not None\n        assert datetime_before < t.datetime_start < datetime_after\n        if t.state.is_finished():\n            <IND>assert t.datetime_complete is not None\n            assert datetime_before < t.datetime_complete < datetime_after\n",
    "warning_line": "        assert datetime_before < t.datetime_start < datetime_after",
    "linter_report": {
      "rule_id": "Unsupported operand [58]",
      "message": " `<` is not supported for operand types `datetime` and `typing.Optional[datetime]`.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 424,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "optuna/optuna",
    "source_filename": "tests/storages_tests/test_storages.py",
    "target_filename": "tests/storages_tests/test_storages.py",
    "source_changeid": "8917099bb57bb168116e0cb4343ddb82876abb04^",
    "target_changeid": "8917099bb57bb168116e0cb4343ddb82876abb04",
    "predictions": [
      "for t in trials: \n <IND> assert t.datetime_start is not None \n assert datetime_before  t.datetime_start  datetime_after \n if t.state.is_finished(): \n <IND> assert t.datetime_complete is not None \n assert datetime_before  t.datetime_complete  datetime_after \n"
    ],
    "correct": true,
    "top_five": {
      "0": "for t in trials: \n <IND> assert t.datetime_start is not None \n assert datetime_before  t.datetime_start  datetime_after \n if t.state.is_finished(): \n <IND> assert t.datetime_complete is not None \n assert datetime_before  t.datetime_complete  datetime_after \n",
      "1": "for t in trials: \n <DED> assert t.datetime_start is not None \n assert datetime_before  t.datetime_start  datetime_after \n if t.state.is_finished(): \n <IND> assert t.datetime_complete is not None \n assert datetime_before  t.datetime_complete  datetime_after \n",
      "2": "for t in trials: \n <IND> assert t.datetime_start is not None \n assert datetime_before  t.datetime_start  datetime_after \n if t.state.is_finished(): \n <DED> assert t.datetime_complete is not None \n assert datetime_before  t.datetime_complete  datetime_after \n",
      "3": "for t in trials: \n <IND> assert t.datetime_start is not None <DED> assert datetime_before  t.datetime_start  datetime_after \n if t.state.is_finished(): \n <IND> assert t.datetime_complete is not None \n assert datetime_before  t.datetime_complete  datetime_after \n",
      "4": "for t in trials: \n <IND> assert t.datetime_start is not None \n assert datetime_before  t.datetime_start  datetime_after \n if t.state.is_finished(): \n \n assert t.datetime_complete is not None \n assert datetime_before  t.datetime_complete  datetime_after \n"
    }
  },
  {
    "source_code": "    <DED>def __aiter__(self) -> AsyncIterator:\n        <IND>return aiter(self._stream())\n",
    "target_code": "    <DED>def __aiter__(self) -> AsyncIterator:\n        <IND>return aiter(self._stream)\n",
    "warning_line": "        return aiter(self._stream())",
    "linter_report": {
      "rule_id": "Call error [29]",
      "message": " `faust.types.streams.StreamT[typing.Any]` is not a function.",
      "evidence": "",
      "col_begin": "",
      "col_end": "",
      "line_begin": 1123,
      "line_end": "",
      "severity": ""
    },
    "instructions": [],
    "source_file": "",
    "target_file": "",
    "repo": "robinhood/faust",
    "source_filename": "faust/agents/agent.py",
    "target_filename": "faust/agents/agent.py",
    "source_changeid": "51de861ada304a1763a4872811274818a8ee0851^",
    "target_changeid": "51de861ada304a1763a4872811274818a8ee0851",
    "predictions": [
      "<DED> def __aiter__(self) -> AsyncIterator: \n <IND> return aiter(self._stream) \n"
    ],
    "correct": true,
    "top_five": {
      "0": "<DED> def __aiter__(self) -> AsyncIterator: \n <IND> return aiter(self._stream) \n",
      "1": "<IND> def __aiter__(self) -> AsyncIterator: \n <IND> return aiter(self._stream) \n",
      "2": "\n def __aiter__(self) -> AsyncIterator: \n <IND> return aiter(self._stream) \n",
      "3": "<DED> def __aiter__(self) -> AsyncIterator: \n <IND> return aiter(self._streams[0]) \n",
      "4": "<DED> def __aiter__(self) -> AsyncIterator: \n <IND> return aiter(self._stream()) \n"
    }
  }
]